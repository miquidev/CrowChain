"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@noble";
exports.ids = ["vendor-chunks/@noble"];
exports.modules = {

/***/ "(ssr)/./node_modules/@noble/curves/esm/_shortw_utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: () => (/* binding */ createCurve),\n/* harmony export */   getHash: () => (/* binding */ getHash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(ssr)/./node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs)=>(0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs)),\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash)=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({\n            ...curveDef,\n            ...getHash(hash)\n        });\n    return Object.freeze({\n        ...create(defHash),\n        create\n    });\n} //# sourceMappingURL=_shortw_utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vX3Nob3J0d191dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLG9FQUFvRSxHQUMxQjtBQUNxQjtBQUNQO0FBQ3hELHdDQUF3QztBQUNqQyxTQUFTSSxRQUFRQyxJQUFJO0lBQ3hCLE9BQU87UUFDSEE7UUFDQUwsTUFBTSxDQUFDTSxLQUFLLEdBQUdDLE9BQVNQLHdEQUFJQSxDQUFDSyxNQUFNQyxLQUFLTCxnRUFBV0EsSUFBSU07UUFDdkRMLFdBQVdBLDhEQUFBQTtJQUNmO0FBQ0o7QUFDTyxTQUFTTSxZQUFZQyxRQUFRLEVBQUVDLE9BQU87SUFDekMsTUFBTUMsU0FBUyxDQUFDTixPQUFTRixxRUFBV0EsQ0FBQztZQUFFLEdBQUdNLFFBQVE7WUFBRSxHQUFHTCxRQUFRQyxLQUFLO1FBQUM7SUFDckUsT0FBT08sT0FBT0MsTUFBTSxDQUFDO1FBQUUsR0FBR0YsT0FBT0QsUUFBUTtRQUFFQztJQUFPO0FBQ3RELEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2ZhcHAvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vX3Nob3J0d191dGlscy5qcz9mMjQ0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IGhtYWMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL2htYWMnO1xuaW1wb3J0IHsgY29uY2F0Qnl0ZXMsIHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyB3ZWllcnN0cmFzcyB9IGZyb20gJy4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMnO1xuLy8gY29ubmVjdHMgbm9ibGUtY3VydmVzIHRvIG5vYmxlLWhhc2hlc1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhhc2goaGFzaCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGhhc2gsXG4gICAgICAgIGhtYWM6IChrZXksIC4uLm1zZ3MpID0+IGhtYWMoaGFzaCwga2V5LCBjb25jYXRCeXRlcyguLi5tc2dzKSksXG4gICAgICAgIHJhbmRvbUJ5dGVzLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ3VydmUoY3VydmVEZWYsIGRlZkhhc2gpIHtcbiAgICBjb25zdCBjcmVhdGUgPSAoaGFzaCkgPT4gd2VpZXJzdHJhc3MoeyAuLi5jdXJ2ZURlZiwgLi4uZ2V0SGFzaChoYXNoKSB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLmNyZWF0ZShkZWZIYXNoKSwgY3JlYXRlIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3Nob3J0d191dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiaG1hYyIsImNvbmNhdEJ5dGVzIiwicmFuZG9tQnl0ZXMiLCJ3ZWllcnN0cmFzcyIsImdldEhhc2giLCJoYXNoIiwia2V5IiwibXNncyIsImNyZWF0ZUN1cnZlIiwiY3VydmVEZWYiLCJkZWZIYXNoIiwiY3JlYXRlIiwiT2JqZWN0IiwiZnJlZXplIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/esm/_shortw_utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/esm/abstract/curve.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/curve.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateBasic: () => (/* binding */ validateBasic),\n/* harmony export */   wNAF: () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Abelian group utilities\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item)=>{\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W)=>{\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return {\n            windows,\n            windowSize\n        };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder (elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while(n > _0n){\n                if (n & _1n) p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n         * - 𝑊 is the window size\n         * - 𝑛 is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */ precomputeWindow (elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for(let window = 0; window < windows; window++){\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for(let i = 1; i < windowSize; i++){\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */ wNAF (W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for(let window = 0; window < windows; window++){\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                } else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return {\n                p,\n                f\n            };\n        },\n        wNAFCached (P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        }\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n        n: \"bigint\",\n        h: \"bigint\",\n        Gx: \"field\",\n        Gy: \"field\"\n    }, {\n        nBitLength: \"isSafeInteger\",\n        nByteLength: \"isSafeInteger\"\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{\n            p: curve.Fp.ORDER\n        }\n    });\n} //# sourceMappingURL=curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvY3VydmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLG9FQUFvRSxHQUNwRSwwQkFBMEI7QUFDNEI7QUFDVjtBQUM1QyxNQUFNRyxNQUFNQyxPQUFPO0FBQ25CLE1BQU1DLE1BQU1ELE9BQU87QUFDbkIsNkRBQTZEO0FBQzdELG1HQUFtRztBQUNuRyx5REFBeUQ7QUFDekQsNERBQTREO0FBQzVELCtFQUErRTtBQUMvRSxvR0FBb0c7QUFDcEcsb0dBQW9HO0FBQ3BHLHFDQUFxQztBQUNyQyxrR0FBa0c7QUFDbEcsZ0dBQWdHO0FBQ2hHLDhDQUE4QztBQUN2QyxTQUFTRSxLQUFLQyxDQUFDLEVBQUVDLElBQUk7SUFDeEIsTUFBTUMsa0JBQWtCLENBQUNDLFdBQVdDO1FBQ2hDLE1BQU1DLE1BQU1ELEtBQUtFLE1BQU07UUFDdkIsT0FBT0gsWUFBWUUsTUFBTUQ7SUFDN0I7SUFDQSxNQUFNRyxPQUFPLENBQUNDO1FBQ1YsTUFBTUMsVUFBVUMsS0FBS0MsSUFBSSxDQUFDVixPQUFPTyxLQUFLLEdBQUcsY0FBYztRQUN2RCxNQUFNSSxhQUFhLEtBQU1KLENBQUFBLElBQUksSUFBSSwwQkFBMEI7UUFDM0QsT0FBTztZQUFFQztZQUFTRztRQUFXO0lBQ2pDO0lBQ0EsT0FBTztRQUNIVjtRQUNBLHVDQUF1QztRQUN2Q1csY0FBYUMsR0FBRyxFQUFFQyxDQUFDO1lBQ2YsSUFBSUMsSUFBSWhCLEVBQUVpQixJQUFJO1lBQ2QsSUFBSUMsSUFBSUo7WUFDUixNQUFPQyxJQUFJbkIsSUFBSztnQkFDWixJQUFJbUIsSUFBSWpCLEtBQ0prQixJQUFJQSxFQUFFRyxHQUFHLENBQUNEO2dCQUNkQSxJQUFJQSxFQUFFRSxNQUFNO2dCQUNaTCxNQUFNakI7WUFDVjtZQUNBLE9BQU9rQjtRQUNYO1FBQ0E7Ozs7Ozs7OztTQVNDLEdBQ0RLLGtCQUFpQlAsR0FBRyxFQUFFTixDQUFDO1lBQ25CLE1BQU0s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RCx5REFBY0EsQ0FBQ3VELE9BQU87UUFDbEJuQyxHQUFHO1FBQ0hxQyxHQUFHO1FBQ0hDLElBQUk7UUFDSkMsSUFBSTtJQUNSLEdBQUc7UUFDQ0MsWUFBWTtRQUNaQyxhQUFhO0lBQ2pCO0lBQ0EsZUFBZTtJQUNmLE9BQU9DLE9BQU9DLE1BQU0sQ0FBQztRQUNqQixHQUFHaEUsb0RBQU9BLENBQUN3RCxNQUFNbkMsQ0FBQyxFQUFFbUMsTUFBTUssVUFBVSxDQUFDO1FBQ3JDLEdBQUdMLEtBQUs7UUFDUixHQUFHO1lBQUVsQyxHQUFHa0MsTUFBTUMsRUFBRSxDQUFDUSxLQUFLO1FBQUMsQ0FBQztJQUM1QjtBQUNKLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2ZhcHAvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvY3VydmUuanM/NjFkOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBBYmVsaWFuIGdyb3VwIHV0aWxpdGllc1xuaW1wb3J0IHsgdmFsaWRhdGVGaWVsZCwgbkxlbmd0aCB9IGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgeyB2YWxpZGF0ZU9iamVjdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuLy8gRWxsaXB0aWMgY3VydmUgbXVsdGlwbGljYXRpb24gb2YgUG9pbnQgYnkgc2NhbGFyLiBGcmFnaWxlLlxuLy8gU2NhbGFycyBzaG91bGQgYWx3YXlzIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcjogdGhpcyBzaG91bGQgYmUgY2hlY2tlZCBpbnNpZGUgb2YgYSBjdXJ2ZSBpdHNlbGYuXG4vLyBDcmVhdGVzIHByZWNvbXB1dGF0aW9uIHRhYmxlcyBmb3IgZmFzdCBtdWx0aXBsaWNhdGlvbjpcbi8vIC0gcHJpdmF0ZSBzY2FsYXIgaXMgc3BsaXQgYnkgZml4ZWQgc2l6ZSB3aW5kb3dzIG9mIFcgYml0c1xuLy8gLSBldmVyeSB3aW5kb3cgcG9pbnQgaXMgY29sbGVjdGVkIGZyb20gd2luZG93J3MgdGFibGUgJiBhZGRlZCB0byBhY2N1bXVsYXRvclxuLy8gLSBzaW5jZSB3aW5kb3dzIGFyZSBkaWZmZXJlbnQsIHNhbWUgcG9pbnQgaW5zaWRlIHRhYmxlcyB3b24ndCBiZSBhY2Nlc3NlZCBtb3JlIHRoYW4gb25jZSBwZXIgY2FsY1xuLy8gLSBlYWNoIG11bHRpcGxpY2F0aW9uIGlzICdNYXRoLmNlaWwoQ1VSVkVfT1JERVIgLyDwnZGKKSArIDEnIHBvaW50IGFkZGl0aW9ucyAoZml4ZWQgZm9yIGFueSBzY2FsYXIpXG4vLyAtICsxIHdpbmRvdyBpcyBuZWNjZXNzYXJ5IGZvciB3TkFGXG4vLyAtIHdOQUYgcmVkdWNlcyB0YWJsZSBzaXplOiAyeCBsZXNzIG1lbW9yeSArIDJ4IGZhc3RlciBnZW5lcmF0aW9uLCBidXQgMTAlIHNsb3dlciBtdWx0aXBsaWNhdGlvblxuLy8gVE9ETzogUmVzZWFyY2ggcmV0dXJuaW5nIDJkIEpTIGFycmF5IG9mIHdpbmRvd3MsIGluc3RlYWQgb2YgYSBzaW5nbGUgd2luZG93LiBUaGlzIHdvdWxkIGFsbG93XG4vLyB3aW5kb3dzIHRvIGJlIGluIGRpZmZlcmVudCBtZW1vcnkgbG9jYXRpb25zXG5leHBvcnQgZnVuY3Rpb24gd05BRihjLCBiaXRzKSB7XG4gICAgY29uc3QgY29uc3RUaW1lTmVnYXRlID0gKGNvbmRpdGlvbiwgaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBuZWcgPSBpdGVtLm5lZ2F0ZSgpO1xuICAgICAgICByZXR1cm4gY29uZGl0aW9uID8gbmVnIDogaXRlbTtcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSAoVykgPT4ge1xuICAgICAgICBjb25zdCB3aW5kb3dzID0gTWF0aC5jZWlsKGJpdHMgLyBXKSArIDE7IC8vICsxLCBiZWNhdXNlXG4gICAgICAgIGNvbnN0IHdpbmRvd1NpemUgPSAyICoqIChXIC0gMSk7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgIHJldHVybiB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnN0VGltZU5lZ2F0ZSxcbiAgICAgICAgLy8gbm9uLWNvbnN0IHRpbWUgbXVsdGlwbGljYXRpb24gbGFkZGVyXG4gICAgICAgIHVuc2FmZUxhZGRlcihlbG0sIG4pIHtcbiAgICAgICAgICAgIGxldCBwID0gYy5aRVJPO1xuICAgICAgICAgICAgbGV0IGQgPSBlbG07XG4gICAgICAgICAgICB3aGlsZSAobiA+IF8wbikge1xuICAgICAgICAgICAgICAgIGlmIChuICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgbiA+Pj0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgd05BRiBwcmVjb21wdXRhdGlvbiB3aW5kb3cuIFVzZWQgZm9yIGNhY2hpbmcuXG4gICAgICAgICAqIERlZmF1bHQgd2luZG93IHNpemUgaXMgc2V0IGJ5IGB1dGlscy5wcmVjb21wdXRlKClgIGFuZCBpcyBlcXVhbCB0byA4LlxuICAgICAgICAgKiBOdW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGRlcGVuZHMgb24gdGhlIGN1cnZlIHNpemU6XG4gICAgICAgICAqIDJeKPCdkYriiJIxKSAqIChNYXRoLmNlaWwo8J2RmyAvIPCdkYopICsgMSksIHdoZXJlOlxuICAgICAgICAgKiAtIPCdkYogaXMgdGhlIHdpbmRvdyBzaXplXG4gICAgICAgICAqIC0g8J2RmyBpcyB0aGUgYml0bGVuZ3RoIG9mIHRoZSBjdXJ2ZSBvcmRlci5cbiAgICAgICAgICogRm9yIGEgMjU2LWJpdCBjdXJ2ZSBhbmQgd2luZG93IHNpemUgOCwgdGhlIG51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgaXMgMTI4ICogMzMgPSA0MjI0LlxuICAgICAgICAgKiBAcmV0dXJucyBwcmVjb21wdXRlZCBwb2ludCB0YWJsZXMgZmxhdHRlbmVkIHRvIGEgc2luZ2xlIGFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlV2luZG93KGVsbSwgVykge1xuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgICAgICBsZXQgcCA9IGVsbTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gcDtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IHA7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgLy8gPTEsIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3aW5kb3dTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50cyBlYyBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgICAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiBAcGFyYW0gcHJlY29tcHV0ZXMgcHJlY29tcHV0ZWQgdGFibGVzXG4gICAgICAgICAqIEBwYXJhbSBuIHNjYWxhciAod2UgZG9uJ3QgY2hlY2sgaGVyZSwgYnV0IHNob3VsZCBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXIpXG4gICAgICAgICAqIEByZXR1cm5zIHJlYWwgYW5kIGZha2UgKGZvciBjb25zdC10aW1lKSBwb2ludHNcbiAgICAgICAgICovXG4gICAgICAgIHdOQUYoVywgcHJlY29tcHV0ZXMsIG4pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IG1heWJlIGNoZWNrIHRoYXQgc2NhbGFyIGlzIGxlc3MgdGhhbiBncm91cCBvcmRlcj8gd05BRiBiZWhhdmlvdXMgaXMgdW5kZWZpbmVkIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gQnV0IG5lZWQgdG8gY2FyZWZ1bGx5IHJlbW92ZSBvdGhlciBjaGVja3MgYmVmb3JlIHdOQUYuIE9SREVSID09IGJpdHMgaGVyZVxuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xuICAgICAgICAgICAgbGV0IHAgPSBjLlpFUk87XG4gICAgICAgICAgICBsZXQgZiA9IGMuQkFTRTtcbiAgICAgICAgICAgIGNvbnN0IG1hc2sgPSBCaWdJbnQoMiAqKiBXIC0gMSk7IC8vIENyZWF0ZSBtYXNrIHdpdGggVyBvbmVzOiAwYjExMTEgZm9yIFc9NCBldGMuXG4gICAgICAgICAgICBjb25zdCBtYXhOdW1iZXIgPSAyICoqIFc7XG4gICAgICAgICAgICBjb25zdCBzaGlmdEJ5ID0gQmlnSW50KFcpO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB3aW5kb3cgKiB3aW5kb3dTaXplO1xuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgVyBiaXRzLlxuICAgICAgICAgICAgICAgIGxldCB3Yml0cyA9IE51bWJlcihuICYgbWFzayk7XG4gICAgICAgICAgICAgICAgLy8gU2hpZnQgbnVtYmVyIGJ5IFcgYml0cy5cbiAgICAgICAgICAgICAgICBuID4+PSBzaGlmdEJ5O1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBiaXRzIGFyZSBiaWdnZXIgdGhhbiBtYXggc2l6ZSwgd2UnbGwgc3BsaXQgdGhvc2UuXG4gICAgICAgICAgICAgICAgLy8gKzIyNCA9PiAyNTYgLSAzMlxuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA+IHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBuICs9IF8xbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjb2RlIHdhcyBmaXJzdCB3cml0dGVuIHdpdGggYXNzdW1wdGlvbiB0aGF0ICdmJyBhbmQgJ3AnIHdpbGwgbmV2ZXIgYmUgaW5maW5pdHkgcG9pbnQ6XG4gICAgICAgICAgICAgICAgLy8gc2luY2UgZWFjaCBhZGRpdGlvbiBpcyBtdWx0aXBsaWVkIGJ5IDIgKiogVywgaXQgY2Fubm90IGNhbmNlbCBlYWNoIG90aGVyLiBIb3dldmVyLFxuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5lZ2F0ZSBub3c6IGl0IGlzIHBvc3NpYmxlIHRoYXQgbmVnYXRlZCBlbGVtZW50IGZyb20gbG93IHZhbHVlXG4gICAgICAgICAgICAgICAgLy8gd291bGQgYmUgdGhlIHNhbWUgYXMgaGlnaCBlbGVtZW50LCB3aGljaCB3aWxsIGNyZWF0ZSBjYXJyeSBpbnRvIG5leHQgd2luZG93LlxuICAgICAgICAgICAgICAgIC8vIEl0J3Mgbm90IG9idmlvdXMgaG93IHRoaXMgY2FuIGZhaWwsIGJ1dCBzdGlsbCB3b3J0aCBpbnZlc3RpZ2F0aW5nIGxhdGVyLlxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIG9udG8gWmVybyBwb2ludC5cbiAgICAgICAgICAgICAgICAvLyBBZGQgcmFuZG9tIHBvaW50IGluc2lkZSBjdXJyZW50IHdpbmRvdyB0byBmLlxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldDEgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MiA9IG9mZnNldCArIE1hdGguYWJzKHdiaXRzKSAtIDE7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDEgPSB3aW5kb3cgJSAyICE9PSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmQyID0gd2JpdHMgPCAwO1xuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbW9zdCBpbXBvcnRhbnQgcGFydCBmb3IgY29uc3QtdGltZSBnZXRQdWJsaWNLZXlcbiAgICAgICAgICAgICAgICAgICAgZiA9IGYuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMSwgcHJlY29tcHV0ZXNbb2Zmc2V0MV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDIsIHByZWNvbXB1dGVzW29mZnNldDJdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSklULWNvbXBpbGVyIHNob3VsZCBub3QgZWxpbWluYXRlIGYgaGVyZSwgc2luY2UgaXQgd2lsbCBsYXRlciBiZSB1c2VkIGluIG5vcm1hbGl6ZVooKVxuICAgICAgICAgICAgLy8gRXZlbiBpZiB0aGUgdmFyaWFibGUgaXMgc3RpbGwgdW51c2VkLCB0aGVyZSBhcmUgc29tZSBjaGVja3Mgd2hpY2ggd2lsbFxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXhjZXB0aW9uLCBzbyBjb21waWxlciBuZWVkcyB0byBwcm92ZSB0aGV5IHdvbid0IGhhcHBlbiwgd2hpY2ggaXMgaGFyZC5cbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlcmUgaXMgYSB3YXkgdG8gRiBiZSBpbmZpbml0eS1wb2ludCBldmVuIGlmIHAgaXMgbm90LFxuICAgICAgICAgICAgLy8gd2hpY2ggbWFrZXMgaXQgbGVzcyBjb25zdC10aW1lOiBhcm91bmQgMSBiaWdpbnQgbXVsdGlwbHkuXG4gICAgICAgICAgICByZXR1cm4geyBwLCBmIH07XG4gICAgICAgIH0sXG4gICAgICAgIHdOQUZDYWNoZWQoUCwgcHJlY29tcHV0ZXNNYXAsIG4sIHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgVyA9IFAuX1dJTkRPV19TSVpFIHx8IDE7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgcHJlY29tcHV0ZXMgb24gYSBmaXJzdCBydW4sIHJldXNlIHRoZW0gYWZ0ZXJcbiAgICAgICAgICAgIGxldCBjb21wID0gcHJlY29tcHV0ZXNNYXAuZ2V0KFApO1xuICAgICAgICAgICAgaWYgKCFjb21wKSB7XG4gICAgICAgICAgICAgICAgY29tcCA9IHRoaXMucHJlY29tcHV0ZVdpbmRvdyhQLCBXKTtcbiAgICAgICAgICAgICAgICBpZiAoVyAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVjb21wdXRlc01hcC5zZXQoUCwgdHJhbnNmb3JtKGNvbXApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53TkFGKFcsIGNvbXAsIG4pO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVCYXNpYyhjdXJ2ZSkge1xuICAgIHZhbGlkYXRlRmllbGQoY3VydmUuRnApO1xuICAgIHZhbGlkYXRlT2JqZWN0KGN1cnZlLCB7XG4gICAgICAgIG46ICdiaWdpbnQnLFxuICAgICAgICBoOiAnYmlnaW50JyxcbiAgICAgICAgR3g6ICdmaWVsZCcsXG4gICAgICAgIEd5OiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgbkJpdExlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBuQnl0ZUxlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgIH0pO1xuICAgIC8vIFNldCBkZWZhdWx0c1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgLi4ubkxlbmd0aChjdXJ2ZS5uLCBjdXJ2ZS5uQml0TGVuZ3RoKSxcbiAgICAgICAgLi4uY3VydmUsXG4gICAgICAgIC4uLnsgcDogY3VydmUuRnAuT1JERVIgfSxcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWN1cnZlLmpzLm1hcCJdLCJuYW1lcyI6WyJ2YWxpZGF0ZUZpZWxkIiwibkxlbmd0aCIsInZhbGlkYXRlT2JqZWN0IiwiXzBuIiwiQmlnSW50IiwiXzFuIiwid05BRiIsImMiLCJiaXRzIiwiY29uc3RUaW1lTmVnYXRlIiwiY29uZGl0aW9uIiwiaXRlbSIsIm5lZyIsIm5lZ2F0ZSIsIm9wdHMiLCJXIiwid2luZG93cyIsIk1hdGgiLCJjZWlsIiwid2luZG93U2l6ZSIsInVuc2FmZUxhZGRlciIsImVsbSIsIm4iLCJwIiwiWkVSTyIsImQiLCJhZGQiLCJkb3VibGUiLCJwcmVjb21wdXRlV2luZG93IiwicG9pbnRzIiwiYmFzZSIsIndpbmRvdyIsInB1c2giLCJpIiwicHJlY29tcHV0ZXMiLCJmIiwiQkFTRSIsIm1hc2siLCJtYXhOdW1iZXIiLCJzaGlmdEJ5Iiwib2Zmc2V0Iiwid2JpdHMiLCJOdW1iZXIiLCJvZmZzZXQxIiwib2Zmc2V0MiIsImFicyIsImNvbmQxIiwiY29uZDIiLCJ3TkFGQ2FjaGVkIiwiUCIsInByZWNvbXB1dGVzTWFwIiwidHJhbnNmb3JtIiwiX1dJTkRPV19TSVpFIiwiY29tcCIsImdldCIsInNldCIsInZhbGlkYXRlQmFzaWMiLCJjdXJ2ZSIsIkZwIiwiaCIsIkd4IiwiR3kiLCJuQml0TGVuZ3RoIiwibkJ5dGVMZW5ndGgiLCJPYmplY3QiLCJmcmVlemUiLCJPUkRFUiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/esm/abstract/curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!******************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   expand_message_xmd: () => (/* binding */ expand_message_xmd),\n/* harmony export */   expand_message_xof: () => (/* binding */ expand_message_xof),\n/* harmony export */   hash_to_field: () => (/* binding */ hash_to_field),\n/* harmony export */   isogenyMap: () => (/* binding */ isogenyMap)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << 8 * length) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({\n        length\n    }).fill(0);\n    for(let i = length - 1; i >= 0; i--){\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for(let i = 0; i < a.length; i++){\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item)) throw new Error(\"number expected\");\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255) DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(\"H2C-OVERSIZE-DST-\"), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255) throw new Error(\"Invalid xmd length\");\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for(let i = 1; i <= ell; i++){\n        const args = [\n            strxor(b_0, b[i - 1]),\n            i2osp(i + 1, 1),\n            DST_prime\n        ];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil(2 * k / 8);\n        DST = H.create({\n            dkLen\n        }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(\"H2C-OVERSIZE-DST-\")).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255) throw new Error(\"expand_message_xof: invalid lenInBytes\");\n    return H.create({\n        dkLen: lenInBytes\n    }).update(msg).update(i2osp(lenInBytes, 2))// 2. DST_prime = DST || I2OSP(len(DST), 1)\n    .update(DST).update(i2osp(DST.length, 1)).digest();\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */ function hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\n        DST: \"stringOrUint8Array\",\n        p: \"bigint\",\n        m: \"isSafeInteger\",\n        k: \"isSafeInteger\",\n        hash: \"hash\"\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    anum(count);\n    const DST = typeof _DST === \"string\" ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === \"xmd\") {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    } else if (expand === \"xof\") {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    } else if (expand === \"_internal_pass\") {\n        // for internal tests only\n        prb = msg;\n    } else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for(let i = 0; i < count; i++){\n        const e = new Array(m);\n        for(let j = 0; j < m; j++){\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i)=>Array.from(i).reverse());\n    return (x, y)=>{\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val)=>val.reduce((acc, i)=>field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return {\n            x,\n            y\n        };\n    };\n}\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== \"function\") throw new Error(\"mapToCurve() must be defined\");\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve (msg, options) {\n            const u = hash_to_field(msg, 2, {\n                ...def,\n                DST: def.DST,\n                ...options\n            });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve (msg, options) {\n            const u = hash_to_field(msg, 1, {\n                ...def,\n                DST: def.encodeDST,\n                ...options\n            });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        }\n    };\n} //# sourceMappingURL=hash-to-curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQW1DO0FBQzREO0FBQy9GLDZGQUE2RjtBQUM3RixNQUFNTSxRQUFRTCxzREFBZUE7QUFDN0IsNENBQTRDO0FBQzVDLFNBQVNNLE1BQU1DLEtBQUssRUFBRUMsTUFBTTtJQUN4QixJQUFJRCxRQUFRLEtBQUtBLFNBQVMsS0FBTSxJQUFJQyxRQUFTO1FBQ3pDLE1BQU0sSUFBSUMsTUFBTSxDQUFDLHNCQUFzQixFQUFFRixNQUFNLFFBQVEsRUFBRUMsT0FBTyxDQUFDO0lBQ3JFO0lBQ0EsTUFBTUUsTUFBTUMsTUFBTUMsSUFBSSxDQUFDO1FBQUVKO0lBQU8sR0FBR0ssSUFBSSxDQUFDO0lBQ3hDLElBQUssSUFBSUMsSUFBSU4sU0FBUyxHQUFHTSxLQUFLLEdBQUdBLElBQUs7UUFDbENKLEdBQUcsQ0FBQ0ksRUFBRSxHQUFHUCxRQUFRO1FBQ2pCQSxXQUFXO0lBQ2Y7SUFDQSxPQUFPLElBQUlRLFdBQVdMO0FBQzFCO0FBQ0EsU0FBU00sT0FBT0MsQ0FBQyxFQUFFQyxDQUFDO0lBQ2hCLE1BQU1DLE1BQU0sSUFBSUosV0FBV0UsRUFBRVQsTUFBTTtJQUNuQyxJQUFLLElBQUlNLElBQUksR0FBR0EsSUFBSUcsRUFBRVQsTUFBTSxFQUFFTSxJQUFLO1FBQy9CSyxHQUFHLENBQUNMLEVBQUUsR0FBR0csQ0FBQyxDQUFDSCxFQUFFLEdBQUdJLENBQUMsQ0FBQ0osRUFBRTtJQUN4QjtJQUNBLE9BQU9LO0FBQ1g7QUFDQSxTQUFTQyxLQUFLQyxJQUFJO0lBQ2QsSUFBSSxDQUFDQyxPQUFPQyxhQUFhLENBQUNGLE9BQ3RCLE1BQU0sSUFBSVosTUFBTTtBQUN4QjtBQUNBLG9HQUFvRztBQUNwRyx1REFBdUQ7QUFDaEQsU0FBU2UsbUJBQW1CQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsVUFBVSxFQUFFQyxDQUFDO0lBQ3REM0IsaURBQU1BLENBQUN3QjtJQUNQeEIsaURBQU1BLENBQUN5QjtJQUNQTixLQUFLTztJQUNMLHVEQUF1RDtJQUN2RCxJQUFJRCxJQUFJbEIsTUFBTSxHQUFHLEtBQ2JrQixNQUFNRSxFQUFFMUIsc0RBQVdBLENBQUNDLHNEQUFXQSxDQUFDLHNCQUFzQnVCO0lBQzFELE1BQU0sRUFBRUcsV0FBV0MsVUFBVSxFQUFFQyxVQUFVQyxVQUFVLEVBQUUsR0FBR0o7SUFDeEQsTUFBTUssTUFBTUMsS0FBS0MsSUFBSSxDQUFDUixhQUFhRztJQUNuQyxJQUFJRyxNQUFNLEtBQ04sTUFBTSxJQUFJeEIsTUFBTTtJQUNwQixNQUFNMkIsWUFBWWxDLHNEQUFXQSxDQUFDd0IsS0FBS3BCLE1BQU1vQixJQUFJbEIsTUFBTSxFQUFFO0lBQ3JELE1BQU02QixRQUFRL0IsTUFBTSxHQUFHMEI7SUFDdkIsTUFBTU0sWUFBWWhDLE1BQU1xQixZQUFZLElBQUksbUJBQW1CO0lBQzNELE1BQU1ULElBQUksSUFBSVAsTUFBTXNCO0lBQ3BCLE1BQU1NLE1BQU1YLEVBQUUxQixzREFBV0EsQ0FBQ21DLE9BQU9aLEtBQUthLFdBQVdoQyxNQUFNLEdBQUcsSUFBSThCO0lBQzlEbEIsQ0FBQyxDQUFDLEVBQUUsR0FBR1UsRUFBRTFCLHNEQUFXQSxDQUFDcUMsS0FBS2pDLE1BQU0sR0FBRyxJQUFJOEI7SUFDdkMsSUFBSyxJQUFJdEIsSUFBSSxHQUFHQSxLQUFLbUIsS0FBS25CLElBQUs7UUFDM0IsTUFBTTBCLE9BQU87WUFBQ3hCLE9BQU91QixLQUFLckIsQ0FBQyxDQUFDSixJQUFJLEVBQUU7WUFBR1IsTUFBTVEsSUFBSSxHQUFHO1lBQUlzQjtTQUFVO1FBQ2hFbEIsQ0FBQyxDQUFDSixFQUFFLEdBQUdjLEVBQUUxQixzREFBV0EsSUFBSXNDO0lBQzVCO0lBQ0EsTUFBTUMsc0JBQXNCdkMsc0RBQVdBLElBQUlnQjtJQUMzQyxPQUFPdUIsb0JBQW9CQyxLQUFLLENBQUMsR0FBR2Y7QUFDeEM7QUFDQSx1RkFBdUY7QUFDdkYsNERBQTREO0FBQzVELGlFQUFpRTtBQUNqRSxrRUFBa0U7QUFDbEUsdURBQXVEO0FBQ2hELFNBQVNnQixtQkFBbUJsQixHQUFHLEVBQUVDLEdBQUcsRUFBRUMsVUFBVSxFQUFFaUIsQ0FBQyxFQUFFaEIsQ0FBQztJQUN6RDNCLGlEQUFNQSxDQUFDd0I7SUFDUHhCLGlEQUFNQSxDQUFDeUI7SUFDUE4sS0FBS087SUFDTCx1REFBdUQ7SUFDdkQsb0ZBQW9GO0lBQ3BGLElBQUlELElBQUlsQixNQUFNLEdBQUcsS0FBSztRQUNsQixNQUFNcUMsUUFBUVgsS0FBS0MsSUFBSSxDQUFDLElBQUtTLElBQUs7UUFDbENsQixNQUFNRSxFQUFFa0IsTUFBTSxDQUFDO1lBQUVEO1FBQU0sR0FBR0UsTUFBTSxDQUFDNUMsc0RBQVdBLENBQUMsc0JBQXNCNEMsTUFBTSxDQUFDckIsS0FBS3NCLE1BQU07SUFDekY7SUFDQSxJQUFJckIsYUFBYSxTQUFTRCxJQUFJbEIsTUFBTSxHQUFHLEtBQ25DLE1BQU0sSUFBSUMsTUFBTTtJQUNwQixPQUFRbUIsRUFBRWtCLE1BQU0sQ0FBQztRQUFFRCxPQUFPbEI7SUFBVyxHQUNoQ29CLE1BQU0sQ0FBQ3RCLEtBQ1BzQixNQUFNLENBQUN6QyxNQUFNcUIsWUFBWSxHQUMxQiwyQ0FBMkM7S0FDMUNvQixNQUFNLENBQUNyQixLQUNQcUIsTUFBTSxDQUFDekMsTUFBTW9CLElBQUlsQixNQUFNLEVBQUUsSUFDekJ3QyxNQUFNO0FBQ2Y7QUFDQTs7Ozs7OztDQU9DLEdBQ00sU0FBU0MsY0FBY3hCLEdBQUcsRUFBRXlCLEtBQUssRUFBRUMsT0FBTztJQUM3Qy9DLHlEQUFjQSxDQUFDK0MsU0FBUztRQUNwQnpCLEtBQUs7UUFDTDBCLEdBQUc7UUFDSEMsR0FBRztRQUNIVCxHQUFHO1FBQ0hVLE1BQU07SUFDVjtJQUNBLE1BQU0sRUFBRUYsQ0FBQyxFQUFFUixDQUFDLEVBQUVTLENBQUMsRUFBRUMsSUFBSSxFQUFFQyxNQUFNLEVBQUU3QixLQUFLOEIsSUFBSSxFQUFFLEdBQUdMO0lBQzdDbEQsaURBQU1BLENBQUN3QjtJQUNQTCxLQUFLOEI7SUFDTCxNQUFNeEIsTUFBTSxPQUFPOEIsU0FBUyxXQUFXckQsc0RBQVdBLENBQUNxRCxRQUFRQTtJQUMzRCxNQUFNQyxRQUFRTCxFQUFFTSxRQUFRLENBQUMsR0FBR2xELE1BQU07SUFDbEMsTUFBTW1ELElBQUl6QixLQUFLQyxJQUFJLENBQUMsQ0FBQ3NCLFFBQVFiLENBQUFBLElBQUssSUFBSSx1Q0FBdUM7SUFDN0UsTUFBTWdCLGVBQWVWLFFBQVFHLElBQUlNO0lBQ2pDLElBQUlFLEtBQUssc0JBQXNCO0lBQy9CLElBQUlOLFdBQVcsT0FBTztRQUNsQk0sTUFBTXJDLG1CQUFtQkMsS0FBS0MsS0FBS2tDLGNBQWNOO0lBQ3JELE9BQ0ssSUFBSUMsV0FBVyxPQUFPO1FBQ3ZCTSxNQUFNbEIsbUJBQW1CbEIsS0FBS0MsS0FBS2tDLGNBQWNoQixHQUFHVTtJQUN4RCxPQUNLLElBQUlDLFdBQVcsa0JBQWtCO1FBQ2xDLDBCQUEwQjtRQUMxQk0sTUFBTXBDO0lBQ1YsT0FDSztRQUNELE1BQU0sSUFBSWhCLE1BQU07SUFDcEI7SUFDQSxNQUFNcUQsSUFBSSxJQUFJbkQsTUFBTXVDO0lBQ3BCLElBQUssSUFBSXBDLElBQUksR0FBR0EsSUFBSW9DLE9BQU9wQyxJQUFLO1FBQzVCLE1BQU1pRCxJQUFJLElBQUlwRCxNQUFNMEM7UUFDcEIsSUFBSyxJQUFJVyxJQUFJLEdBQUdBLElBQUlYLEdBQUdXLElBQUs7WUFDeEIsTUFBTUMsYUFBYU4sSUFBS0ssQ0FBQUEsSUFBSWxELElBQUl1QyxDQUFBQTtZQUNoQyxNQUFNYSxLQUFLTCxJQUFJTSxRQUFRLENBQUNGLFlBQVlBLGFBQWFOO1lBQ2pESSxDQUFDLENBQUNDLEVBQUUsR0FBR2pFLGdEQUFHQSxDQUFDTSxNQUFNNkQsS0FBS2Q7UUFDMUI7UUFDQVUsQ0FBQyxDQUFDaEQsRUFBRSxHQUFHaUQ7SUFDWDtJQUNBLE9BQU9EO0FBQ1g7QUFDTyxTQUFTTSxXQUFXQyxLQUFLLEVBQUVDLEdBQUc7SUFDakMsNkJBQTZCO0lBQzdCLE1BQU1DLFFBQVFELElBQUlBLEdBQUcsQ0FBQyxDQUFDeEQsSUFBTUgsTUFBTUMsSUFBSSxDQUFDRSxHQUFHMEQsT0FBTztJQUNsRCxPQUFPLENBQUNDLEdBQUdDO1FBQ1AsTUFBTSxDQUFDQyxNQUFNQyxNQUFNQyxNQUFNQyxLQUFLLEdBQUdQLE1BQU1ELEdBQUcsQ0FBQyxDQUFDUyxNQUFRQSxJQUFJQyxNQUFNLENBQUMsQ0FBQ0MsS0FBS25FLElBQU11RCxNQUFNYSxHQUFHLENBQUNiLE1BQU1jLEdBQUcsQ0FBQ0YsS0FBS1IsSUFBSTNEO1FBQ3hHMkQsSUFBSUosTUFBTWUsR0FBRyxDQUFDVCxNQUFNQyxPQUFPLGNBQWM7UUFDekNGLElBQUlMLE1BQU1jLEdBQUcsQ0FBQ1QsR0FBR0wsTUFBTWUsR0FBRyxDQUFDUCxNQUFNQyxRQUFRLG9CQUFvQjtRQUM3RCxPQUFPO1lBQUVMO1lBQUdDO1FBQUU7SUFDbEI7QUFDSjtBQUNPLFNBQVNXLGFBQWFDLEtBQUssRUFBRUMsVUFBVSxFQUFFQyxHQUFHO0lBQy9DLElBQUksT0FBT0QsZUFBZSxZQUN0QixNQUFNLElBQUk5RSxNQUFNO0lBQ3BCLE9BQU87UUFDSCx5Q0FBeUM7UUFDekMsc0VBQXNFO1FBQ3RFZ0YsYUFBWWhFLEdBQUcsRUFBRTBCLE9BQU87WUFDcEIsTUFBTVcsSUFBSWIsY0FBY3hCLEtBQUssR0FBRztnQkFBRSxHQUFHK0QsR0FBRztnQkFBRTlELEtBQUs4RCxJQUFJOUQsR0FBRztnQkFBRSxHQUFHeUIsT0FBTztZQUFDO1lBQ25FLE1BQU11QyxLQUFLSixNQUFNSyxVQUFVLENBQUNKLFdBQVd6QixDQUFDLENBQUMsRUFBRTtZQUMzQyxNQUFNOEIsS0FBS04sTUFBTUssVUFBVSxDQUFDSixXQUFXekIsQ0FBQyxDQUFDLEVBQUU7WUFDM0MsTUFBTStCLElBQUlILEdBQUdSLEdBQUcsQ0FBQ1UsSUFBSUUsYUFBYTtZQUNsQ0QsRUFBRUUsY0FBYztZQUNoQixPQUFPRjtRQUNYO1FBQ0EseUNBQXlDO1FBQ3pDLHdFQUF3RTtRQUN4RUcsZUFBY3ZFLEdBQUcsRUFBRTBCLE9BQU87WUFDdEIsTUFBTVcsSUFBSWIsY0FBY3hCLEtBQUssR0FBRztnQkFBRSxHQUFHK0QsR0FBRztnQkFBRTlELEtBQUs4RCxJQUFJUyxTQUFTO2dCQUFFLEdBQUc5QyxPQUFPO1lBQUM7WUFDekUsTUFBTTBDLElBQUlQLE1BQU1LLFVBQVUsQ0FBQ0osV0FBV3pCLENBQUMsQ0FBQyxFQUFFLEdBQUdnQyxhQUFhO1lBQzFERCxFQUFFRSxjQUFjO1lBQ2hCLE9BQU9GO1FBQ1g7SUFDSjtBQUNKLEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2ZhcHAvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcz8yMGQyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1vZCB9IGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgeyBieXRlc1RvTnVtYmVyQkUsIGFieXRlcywgY29uY2F0Qnl0ZXMsIHV0ZjhUb0J5dGVzLCB2YWxpZGF0ZU9iamVjdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gT2N0ZXQgU3RyZWFtIHRvIEludGVnZXIuIFwic3BlY1wiIGltcGxlbWVudGF0aW9uIG9mIG9zMmlwIGlzIDIuNXggc2xvd2VyIHZzIGJ5dGVzVG9OdW1iZXJCRS5cbmNvbnN0IG9zMmlwID0gYnl0ZXNUb051bWJlckJFO1xuLy8gSW50ZWdlciB0byBPY3RldCBTdHJlYW0gKG51bWJlclRvQnl0ZXNCRSlcbmZ1bmN0aW9uIGkyb3NwKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IDEgPDwgKDggKiBsZW5ndGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYmFkIEkyT1NQIGNhbGw6IHZhbHVlPSR7dmFsdWV9IGxlbmd0aD0ke2xlbmd0aH1gKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aCB9KS5maWxsKDApO1xuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICByZXNbaV0gPSB2YWx1ZSAmIDB4ZmY7XG4gICAgICAgIHZhbHVlID4+Pj0gODtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlcyk7XG59XG5mdW5jdGlvbiBzdHJ4b3IoYSwgYikge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGEubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYVtpXSBeIGJbaV07XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBhbnVtKGl0ZW0pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGl0ZW0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWJlciBleHBlY3RlZCcpO1xufVxuLy8gUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGEgY3J5cHRvZ3JhcGhpYyBoYXNoIGZ1bmN0aW9uIEggdGhhdCBvdXRwdXRzIGIgYml0c1xuLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuMVxuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuSW5CeXRlcywgSCkge1xuICAgIGFieXRlcyhtc2cpO1xuICAgIGFieXRlcyhEU1QpO1xuICAgIGFudW0obGVuSW5CeXRlcyk7XG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuM1xuICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICBEU1QgPSBIKGNvbmNhdEJ5dGVzKHV0ZjhUb0J5dGVzKCdIMkMtT1ZFUlNJWkUtRFNULScpLCBEU1QpKTtcbiAgICBjb25zdCB7IG91dHB1dExlbjogYl9pbl9ieXRlcywgYmxvY2tMZW46IHJfaW5fYnl0ZXMgfSA9IEg7XG4gICAgY29uc3QgZWxsID0gTWF0aC5jZWlsKGxlbkluQnl0ZXMgLyBiX2luX2J5dGVzKTtcbiAgICBpZiAoZWxsID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgeG1kIGxlbmd0aCcpO1xuICAgIGNvbnN0IERTVF9wcmltZSA9IGNvbmNhdEJ5dGVzKERTVCwgaTJvc3AoRFNULmxlbmd0aCwgMSkpO1xuICAgIGNvbnN0IFpfcGFkID0gaTJvc3AoMCwgcl9pbl9ieXRlcyk7XG4gICAgY29uc3QgbF9pX2Jfc3RyID0gaTJvc3AobGVuSW5CeXRlcywgMik7IC8vIGxlbl9pbl9ieXRlc19zdHJcbiAgICBjb25zdCBiID0gbmV3IEFycmF5KGVsbCk7XG4gICAgY29uc3QgYl8wID0gSChjb25jYXRCeXRlcyhaX3BhZCwgbXNnLCBsX2lfYl9zdHIsIGkyb3NwKDAsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBiWzBdID0gSChjb25jYXRCeXRlcyhiXzAsIGkyb3NwKDEsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBlbGw7IGkrKykge1xuICAgICAgICBjb25zdCBhcmdzID0gW3N0cnhvcihiXzAsIGJbaSAtIDFdKSwgaTJvc3AoaSArIDEsIDEpLCBEU1RfcHJpbWVdO1xuICAgICAgICBiW2ldID0gSChjb25jYXRCeXRlcyguLi5hcmdzKSk7XG4gICAgfVxuICAgIGNvbnN0IHBzZXVkb19yYW5kb21fYnl0ZXMgPSBjb25jYXRCeXRlcyguLi5iKTtcbiAgICByZXR1cm4gcHNldWRvX3JhbmRvbV9ieXRlcy5zbGljZSgwLCBsZW5JbkJ5dGVzKTtcbn1cbi8vIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhbiBleHRlbmRhYmxlLW91dHB1dCBmdW5jdGlvbiAoWE9GKSBILlxuLy8gMS4gVGhlIGNvbGxpc2lvbiByZXNpc3RhbmNlIG9mIEggTVVTVCBiZSBhdCBsZWFzdCBrIGJpdHMuXG4vLyAyLiBIIE1VU1QgYmUgYW4gWE9GIHRoYXQgaGFzIGJlZW4gcHJvdmVkIGluZGlmZmVyZW50aWFibGUgZnJvbVxuLy8gICAgYSByYW5kb20gb3JhY2xlIHVuZGVyIGEgcmVhc29uYWJsZSBjcnlwdG9ncmFwaGljIGFzc3VtcHRpb24uXG4vLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4yXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBrLCBIKSB7XG4gICAgYWJ5dGVzKG1zZyk7XG4gICAgYWJ5dGVzKERTVCk7XG4gICAgYW51bShsZW5JbkJ5dGVzKTtcbiAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4zXG4gICAgLy8gRFNUID0gSCgnSDJDLU9WRVJTSVpFLURTVC0nIHx8IGFfdmVyeV9sb25nX0RTVCwgTWF0aC5jZWlsKChsZW5JbkJ5dGVzICogaykgLyA4KSk7XG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgY29uc3QgZGtMZW4gPSBNYXRoLmNlaWwoKDIgKiBrKSAvIDgpO1xuICAgICAgICBEU1QgPSBILmNyZWF0ZSh7IGRrTGVuIH0pLnVwZGF0ZSh1dGY4VG9CeXRlcygnSDJDLU9WRVJTSVpFLURTVC0nKSkudXBkYXRlKERTVCkuZGlnZXN0KCk7XG4gICAgfVxuICAgIGlmIChsZW5JbkJ5dGVzID4gNjU1MzUgfHwgRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94b2Y6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIHJldHVybiAoSC5jcmVhdGUoeyBka0xlbjogbGVuSW5CeXRlcyB9KVxuICAgICAgICAudXBkYXRlKG1zZylcbiAgICAgICAgLnVwZGF0ZShpMm9zcChsZW5JbkJ5dGVzLCAyKSlcbiAgICAgICAgLy8gMi4gRFNUX3ByaW1lID0gRFNUIHx8IEkyT1NQKGxlbihEU1QpLCAxKVxuICAgICAgICAudXBkYXRlKERTVClcbiAgICAgICAgLnVwZGF0ZShpMm9zcChEU1QubGVuZ3RoLCAxKSlcbiAgICAgICAgLmRpZ2VzdCgpKTtcbn1cbi8qKlxuICogSGFzaGVzIGFyYml0cmFyeS1sZW5ndGggYnl0ZSBzdHJpbmdzIHRvIGEgbGlzdCBvZiBvbmUgb3IgbW9yZSBlbGVtZW50cyBvZiBhIGZpbml0ZSBmaWVsZCBGXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMlxuICogQHBhcmFtIG1zZyBhIGJ5dGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1lc3NhZ2UgdG8gaGFzaFxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgRiB0byBvdXRwdXRcbiAqIEBwYXJhbSBvcHRpb25zIGB7RFNUOiBzdHJpbmcsIHA6IGJpZ2ludCwgbTogbnVtYmVyLCBrOiBudW1iZXIsIGV4cGFuZDogJ3htZCcgfCAneG9mJywgaGFzaDogSH1gLCBzZWUgYWJvdmVcbiAqIEByZXR1cm5zIFt1XzAsIC4uLiwgdV8oY291bnQgLSAxKV0sIGEgbGlzdCBvZiBmaWVsZCBlbGVtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hfdG9fZmllbGQobXNnLCBjb3VudCwgb3B0aW9ucykge1xuICAgIHZhbGlkYXRlT2JqZWN0KG9wdGlvbnMsIHtcbiAgICAgICAgRFNUOiAnc3RyaW5nT3JVaW50OEFycmF5JyxcbiAgICAgICAgcDogJ2JpZ2ludCcsXG4gICAgICAgIG06ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgazogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgfSk7XG4gICAgY29uc3QgeyBwLCBrLCBtLCBoYXNoLCBleHBhbmQsIERTVDogX0RTVCB9ID0gb3B0aW9ucztcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhbnVtKGNvdW50KTtcbiAgICBjb25zdCBEU1QgPSB0eXBlb2YgX0RTVCA9PT0gJ3N0cmluZycgPyB1dGY4VG9CeXRlcyhfRFNUKSA6IF9EU1Q7XG4gICAgY29uc3QgbG9nMnAgPSBwLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBMID0gTWF0aC5jZWlsKChsb2cycCArIGspIC8gOCk7IC8vIHNlY3Rpb24gNS4xIG9mIGlldGYgZHJhZnQgbGluayBhYm92ZVxuICAgIGNvbnN0IGxlbl9pbl9ieXRlcyA9IGNvdW50ICogbSAqIEw7XG4gICAgbGV0IHByYjsgLy8gcHNldWRvX3JhbmRvbV9ieXRlc1xuICAgIGlmIChleHBhbmQgPT09ICd4bWQnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuX2luX2J5dGVzLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAneG9mJykge1xuICAgICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaywgaGFzaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGFuZCA9PT0gJ19pbnRlcm5hbF9wYXNzJykge1xuICAgICAgICAvLyBmb3IgaW50ZXJuYWwgdGVzdHMgb25seVxuICAgICAgICBwcmIgPSBtc2c7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZCBtdXN0IGJlIFwieG1kXCIgb3IgXCJ4b2ZcIicpO1xuICAgIH1cbiAgICBjb25zdCB1ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgZSA9IG5ldyBBcnJheShtKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsbV9vZmZzZXQgPSBMICogKGogKyBpICogbSk7XG4gICAgICAgICAgICBjb25zdCB0diA9IHByYi5zdWJhcnJheShlbG1fb2Zmc2V0LCBlbG1fb2Zmc2V0ICsgTCk7XG4gICAgICAgICAgICBlW2pdID0gbW9kKG9zMmlwKHR2KSwgcCk7XG4gICAgICAgIH1cbiAgICAgICAgdVtpXSA9IGU7XG4gICAgfVxuICAgIHJldHVybiB1O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzb2dlbnlNYXAoZmllbGQsIG1hcCkge1xuICAgIC8vIE1ha2Ugc2FtZSBvcmRlciBhcyBpbiBzcGVjXG4gICAgY29uc3QgQ09FRkYgPSBtYXAubWFwKChpKSA9PiBBcnJheS5mcm9tKGkpLnJldmVyc2UoKSk7XG4gICAgcmV0dXJuICh4LCB5KSA9PiB7XG4gICAgICAgIGNvbnN0IFt4TnVtLCB4RGVuLCB5TnVtLCB5RGVuXSA9IENPRUZGLm1hcCgodmFsKSA9PiB2YWwucmVkdWNlKChhY2MsIGkpID0+IGZpZWxkLmFkZChmaWVsZC5tdWwoYWNjLCB4KSwgaSkpKTtcbiAgICAgICAgeCA9IGZpZWxkLmRpdih4TnVtLCB4RGVuKTsgLy8geE51bSAvIHhEZW5cbiAgICAgICAgeSA9IGZpZWxkLm11bCh5LCBmaWVsZC5kaXYoeU51bSwgeURlbikpOyAvLyB5ICogKHlOdW0gLyB5RGV2KVxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIYXNoZXIoUG9pbnQsIG1hcFRvQ3VydmUsIGRlZikge1xuICAgIGlmICh0eXBlb2YgbWFwVG9DdXJ2ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlKCkgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gRW5jb2RlcyBieXRlIHN0cmluZyB0byBlbGxpcHRpYyBjdXJ2ZS5cbiAgICAgICAgLy8gaGFzaF90b19jdXJ2ZSBmcm9tIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tM1xuICAgICAgICBoYXNoVG9DdXJ2ZShtc2csIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBoYXNoX3RvX2ZpZWxkKG1zZywgMiwgeyAuLi5kZWYsIERTVDogZGVmLkRTVCwgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHUwID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMF0pKTtcbiAgICAgICAgICAgIGNvbnN0IHUxID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMV0pKTtcbiAgICAgICAgICAgIGNvbnN0IFAgPSB1MC5hZGQodTEpLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9LFxuICAgICAgICAvLyBFbmNvZGVzIGJ5dGUgc3RyaW5nIHRvIGVsbGlwdGljIGN1cnZlLlxuICAgICAgICAvLyBlbmNvZGVfdG9fY3VydmUgZnJvbSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTNcbiAgICAgICAgZW5jb2RlVG9DdXJ2ZShtc2csIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBoYXNoX3RvX2ZpZWxkKG1zZywgMSwgeyAuLi5kZWYsIERTVDogZGVmLmVuY29kZURTVCwgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVswXSkpLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLXRvLWN1cnZlLmpzLm1hcCJdLCJuYW1lcyI6WyJtb2QiLCJieXRlc1RvTnVtYmVyQkUiLCJhYnl0ZXMiLCJjb25jYXRCeXRlcyIsInV0ZjhUb0J5dGVzIiwidmFsaWRhdGVPYmplY3QiLCJvczJpcCIsImkyb3NwIiwidmFsdWUiLCJsZW5ndGgiLCJFcnJvciIsInJlcyIsIkFycmF5IiwiZnJvbSIsImZpbGwiLCJpIiwiVWludDhBcnJheSIsInN0cnhvciIsImEiLCJiIiwiYXJyIiwiYW51bSIsIml0ZW0iLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiZXhwYW5kX21lc3NhZ2VfeG1kIiwibXNnIiwiRFNUIiwibGVuSW5CeXRlcyIsIkgiLCJvdXRwdXRMZW4iLCJiX2luX2J5dGVzIiwiYmxvY2tMZW4iLCJyX2luX2J5dGVzIiwiZWxsIiwiTWF0aCIsImNlaWwiLCJEU1RfcHJpbWUiLCJaX3BhZCIsImxfaV9iX3N0ciIsImJfMCIsImFyZ3MiLCJwc2V1ZG9fcmFuZG9tX2J5dGVzIiwic2xpY2UiLCJleHBhbmRfbWVzc2FnZV94b2YiLCJrIiwiZGtMZW4iLCJjcmVhdGUiLCJ1cGRhdGUiLCJkaWdlc3QiLCJoYXNoX3RvX2ZpZWxkIiwiY291bnQiLCJvcHRpb25zIiwicCIsIm0iLCJoYXNoIiwiZXhwYW5kIiwiX0RTVCIsImxvZzJwIiwidG9TdHJpbmciLCJMIiwibGVuX2luX2J5dGVzIiwicHJiIiwidSIsImUiLCJqIiwiZWxtX29mZnNldCIsInR2Iiwic3ViYXJyYXkiLCJpc29nZW55TWFwIiwiZmllbGQiLCJtYXAiLCJDT0VGRiIsInJldmVyc2UiLCJ4IiwieSIsInhOdW0iLCJ4RGVuIiwieU51bSIsInlEZW4iLCJ2YWwiLCJyZWR1Y2UiLCJhY2MiLCJhZGQiLCJtdWwiLCJkaXYiLCJjcmVhdGVIYXNoZXIiLCJQb2ludCIsIm1hcFRvQ3VydmUiLCJkZWYiLCJoYXNoVG9DdXJ2ZSIsInUwIiwiZnJvbUFmZmluZSIsInUxIiwiUCIsImNsZWFyQ29mYWN0b3IiLCJhc3NlcnRWYWxpZGl0eSIsImVuY29kZVRvQ3VydmUiLCJlbmNvZGVEU1QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js":
/*!************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/modular.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FpDiv: () => (/* binding */ FpDiv),\n/* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),\n/* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),\n/* harmony export */   FpPow: () => (/* binding */ FpPow),\n/* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),\n/* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),\n/* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),\n/* harmony export */   getFieldBytesLength: () => (/* binding */ getFieldBytesLength),\n/* harmony export */   getMinHashLength: () => (/* binding */ getMinHashLength),\n/* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),\n/* harmony export */   mapHashToField: () => (/* binding */ mapHashToField),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   nLength: () => (/* binding */ nLength),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   pow2: () => (/* binding */ pow2),\n/* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),\n/* harmony export */   validateField: () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Utilities for modular arithmetics and finite fields\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */ // TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n) throw new Error(\"Expected power/modulo > 0\");\n    if (modulo === _1n) return _0n;\n    let res = _1n;\n    while(power > _0n){\n        if (power & _1n) res = res * num % modulo;\n        num = num * num % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while(power-- > _0n){\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while(a !== _0n){\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n) throw new Error(\"invert: does not exist\");\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */ function tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ≡ 1    if a is a square (mod p)\n    // (a | p) ≡ -1   if a is not a square (mod p)\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for(Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);\n    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n    for(Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++);\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error(\"Cannot find square root\");\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while(!Fp.eql(b, Fp.ONE)){\n            if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for(let t2 = Fp.sqr(b); m < r; m++){\n                if (Fp.eql(t2, Fp.ONE)) break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P ≡ 3 (mod 4)\n    // √n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // P ≡ 9 (mod 16)\n    if (P % _16n === _9n) {\n    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n    // Means we cannot use sqrt for constants at all!\n    //\n    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    // sqrt = (x) => {\n    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n    // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo)=>(mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    \"create\",\n    \"isValid\",\n    \"is0\",\n    \"neg\",\n    \"inv\",\n    \"sqrt\",\n    \"sqr\",\n    \"eql\",\n    \"add\",\n    \"sub\",\n    \"mul\",\n    \"pow\",\n    \"div\",\n    \"addN\",\n    \"subN\",\n    \"mulN\",\n    \"sqrN\"\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: \"bigint\",\n        MASK: \"bigint\",\n        BYTES: \"isSafeInteger\",\n        BITS: \"isSafeInteger\"\n    };\n    const opts = FIELD_FIELDS.reduce((map, val)=>{\n        map[val] = \"function\";\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */ function FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n) throw new Error(\"Expected power > 0\");\n    if (power === _0n) return f.ONE;\n    if (power === _1n) return num;\n    let p = f.ONE;\n    let d = num;\n    while(power > _0n){\n        if (power & _1n) p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */ function FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i)=>{\n        if (f.is0(num)) return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i)=>{\n        if (f.is0(num)) return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === \"bigint\" ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x)=>{\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return {\n        nBitLength: _nBitLength,\n        nByteLength\n    };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */ function Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n) throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048) throw new Error(\"Field lengths over 2048 bytes are not supported\");\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num)=>mod(num, ORDER),\n        isValid: (num)=>{\n            if (typeof num !== \"bigint\") throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num)=>num === _0n,\n        isOdd: (num)=>(num & _1n) === _1n,\n        neg: (num)=>mod(-num, ORDER),\n        eql: (lhs, rhs)=>lhs === rhs,\n        sqr: (num)=>mod(num * num, ORDER),\n        add: (lhs, rhs)=>mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs)=>mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs)=>mod(lhs * rhs, ORDER),\n        pow: (num, power)=>FpPow(f, num, power),\n        div: (lhs, rhs)=>mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num)=>num * num,\n        addN: (lhs, rhs)=>lhs + rhs,\n        subN: (lhs, rhs)=>lhs - rhs,\n        mulN: (lhs, rhs)=>lhs * rhs,\n        inv: (num)=>invert(num, ORDER),\n        sqrt: redef.sqrt || ((n)=>sqrtP(f, n)),\n        invertBatch: (lst)=>FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c)=>c ? b : a,\n        toBytes: (num)=>isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES),\n        fromBytes: (bytes)=>{\n            if (bytes.length !== BYTES) throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        }\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */ function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"privateHash\", hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */ function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== \"bigint\") throw new Error(\"field order must be bigint\");\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */ function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */ function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024) throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n} //# sourceMappingURL=modular.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9kdWxhci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxvRUFBb0UsR0FDcEUsc0RBQXNEO0FBQ2lGO0FBQ3ZJLGtCQUFrQjtBQUNsQixNQUFNTyxNQUFNQyxPQUFPLElBQUlDLE1BQU1ELE9BQU8sSUFBSUUsTUFBTUYsT0FBTyxJQUFJRyxNQUFNSCxPQUFPO0FBQ3RFLGtCQUFrQjtBQUNsQixNQUFNSSxNQUFNSixPQUFPLElBQUlLLE1BQU1MLE9BQU8sSUFBSU0sTUFBTU4sT0FBTztBQUNyRCxrQkFBa0I7QUFDbEIsTUFBTU8sTUFBTVAsT0FBTyxJQUFJUSxPQUFPUixPQUFPO0FBQ3JDLHdCQUF3QjtBQUNqQixTQUFTUyxJQUFJQyxDQUFDLEVBQUVDLENBQUM7SUFDcEIsTUFBTUMsU0FBU0YsSUFBSUM7SUFDbkIsT0FBT0MsVUFBVWIsTUFBTWEsU0FBU0QsSUFBSUM7QUFDeEM7QUFDQTs7Ozs7Q0FLQyxHQUNELG9DQUFvQztBQUM3QixTQUFTQyxJQUFJQyxHQUFHLEVBQUVDLEtBQUssRUFBRUMsTUFBTTtJQUNsQyxJQUFJQSxVQUFVakIsT0FBT2dCLFFBQVFoQixLQUN6QixNQUFNLElBQUlrQixNQUFNO0lBQ3BCLElBQUlELFdBQVdmLEtBQ1gsT0FBT0Y7SUFDWCxJQUFJbUIsTUFBTWpCO0lBQ1YsTUFBT2MsUUFBUWhCLElBQUs7UUFDaEIsSUFBSWdCLFFBQVFkLEtBQ1JpQixNQUFNLE1BQU9KLE1BQU9FO1FBQ3hCRixNQUFNLE1BQU9BLE1BQU9FO1FBQ3BCRCxVQUFVZDtJQUNkO0lBQ0EsT0FBT2lCO0FBQ1g7QUFDQSwwREFBMEQ7QUFDbkQsU0FBU0MsS0FBS0MsQ0FBQyxFQUFFTCxLQUFLLEVBQUVDLE1BQU07SUFDakMsSUFBSUUsTUFBTUU7SUFDVixNQUFPTCxVQUFVaEIsSUFBSztRQUNsQm1CLE9BQU9BO1FBQ1BBLE9BQU9GO0lBQ1g7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MERBQWVBLENBQUNzSTtJQUMzRCxPQUFPeEgsSUFBSUssS0FBS29ILGFBQWFqSSxPQUFPQTtBQUN4QztBQUNBOzs7OztDQUtDLEdBQ00sU0FBU29JLG9CQUFvQkMsVUFBVTtJQUMxQyxJQUFJLE9BQU9BLGVBQWUsVUFDdEIsTUFBTSxJQUFJckgsTUFBTTtJQUNwQixNQUFNc0gsWUFBWUQsV0FBV3JDLFFBQVEsQ0FBQyxHQUFHaEIsTUFBTTtJQUMvQyxPQUFPa0IsS0FBS0MsSUFBSSxDQUFDbUMsWUFBWTtBQUNqQztBQUNBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNDLGlCQUFpQkYsVUFBVTtJQUN2QyxNQUFNckQsU0FBU29ELG9CQUFvQkM7SUFDbkMsT0FBT3JELFNBQVNrQixLQUFLQyxJQUFJLENBQUNuQixTQUFTO0FBQ3ZDO0FBQ0E7Ozs7Ozs7Ozs7OztDQVlDLEdBQ00sU0FBU3dELGVBQWVDLEdBQUcsRUFBRUosVUFBVSxFQUFFL0IsT0FBTyxLQUFLO0lBQ3hELE1BQU1vQyxNQUFNRCxJQUFJekQsTUFBTTtJQUN0QixNQUFNMkQsV0FBV1Asb0JBQW9CQztJQUNyQyxNQUFNRixTQUFTSSxpQkFBaUJGO0lBQ2hDLGlHQUFpRztJQUNqRyxJQUFJSyxNQUFNLE1BQU1BLE1BQU1QLFVBQVVPLE1BQU0sTUFDbEMsTUFBTSxJQUFJMUgsTUFBTSxDQUFDLFNBQVMsRUFBRW1ILE9BQU8sMEJBQTBCLEVBQUVPLElBQUksQ0FBQztJQUN4RSxNQUFNN0gsTUFBTXlGLE9BQU81RywwREFBZUEsQ0FBQytJLE9BQU85SSwwREFBZUEsQ0FBQzhJO0lBQzFELCtFQUErRTtJQUMvRSxNQUFNRyxVQUFVcEksSUFBSUssS0FBS3dILGFBQWFySSxPQUFPQTtJQUM3QyxPQUFPc0csT0FBTzdHLDBEQUFlQSxDQUFDbUosU0FBU0QsWUFBWW5KLDBEQUFlQSxDQUFDb0osU0FBU0Q7QUFDaEYsRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jZmFwcC8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzPzBjYTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gVXRpbGl0aWVzIGZvciBtb2R1bGFyIGFyaXRobWV0aWNzIGFuZCBmaW5pdGUgZmllbGRzXG5pbXBvcnQgeyBiaXRNYXNrLCBudW1iZXJUb0J5dGVzQkUsIG51bWJlclRvQnl0ZXNMRSwgYnl0ZXNUb051bWJlckJFLCBieXRlc1RvTnVtYmVyTEUsIGVuc3VyZUJ5dGVzLCB2YWxpZGF0ZU9iamVjdCwgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfNG4gPSBCaWdJbnQoNCksIF81biA9IEJpZ0ludCg1KSwgXzhuID0gQmlnSW50KDgpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfOW4gPSBCaWdJbnQoOSksIF8xNm4gPSBCaWdJbnQoMTYpO1xuLy8gQ2FsY3VsYXRlcyBhIG1vZHVsbyBiXG5leHBvcnQgZnVuY3Rpb24gbW9kKGEsIGIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhICUgYjtcbiAgICByZXR1cm4gcmVzdWx0ID49IF8wbiA/IHJlc3VsdCA6IGIgKyByZXN1bHQ7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IHJhaXNlIG51bSB0byBwb3dlciBhbmQgZG8gbW9kdWxhciBkaXZpc2lvbi5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqIEBleGFtcGxlXG4gKiBwb3coMm4sIDZuLCAxMW4pIC8vIDY0biAlIDExbiA9PSA5blxuICovXG4vLyBUT0RPOiB1c2UgZmllbGQgdmVyc2lvbiAmJiByZW1vdmVcbmV4cG9ydCBmdW5jdGlvbiBwb3cobnVtLCBwb3dlciwgbW9kdWxvKSB7XG4gICAgaWYgKG1vZHVsbyA8PSBfMG4gfHwgcG93ZXIgPCBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcG93ZXIvbW9kdWxvID4gMCcpO1xuICAgIGlmIChtb2R1bG8gPT09IF8xbilcbiAgICAgICAgcmV0dXJuIF8wbjtcbiAgICBsZXQgcmVzID0gXzFuO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICByZXMgPSAocmVzICogbnVtKSAlIG1vZHVsbztcbiAgICAgICAgbnVtID0gKG51bSAqIG51bSkgJSBtb2R1bG87XG4gICAgICAgIHBvd2VyID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBEb2VzIHggXiAoMiBeIHBvd2VyKSBtb2QgcC4gcG93MigzMCwgNCkgPT0gMzAgXiAoMiBeIDQpXG5leHBvcnQgZnVuY3Rpb24gcG93Mih4LCBwb3dlciwgbW9kdWxvKSB7XG4gICAgbGV0IHJlcyA9IHg7XG4gICAgd2hpbGUgKHBvd2VyLS0gPiBfMG4pIHtcbiAgICAgICAgcmVzICo9IHJlcztcbiAgICAgICAgcmVzICU9IG1vZHVsbztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIEludmVyc2VzIG51bWJlciBvdmVyIG1vZHVsb1xuZXhwb3J0IGZ1bmN0aW9uIGludmVydChudW1iZXIsIG1vZHVsbykge1xuICAgIGlmIChudW1iZXIgPT09IF8wbiB8fCBtb2R1bG8gPD0gXzBuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52ZXJ0OiBleHBlY3RlZCBwb3NpdGl2ZSBpbnRlZ2VycywgZ290IG49JHtudW1iZXJ9IG1vZD0ke21vZHVsb31gKTtcbiAgICB9XG4gICAgLy8gRXVjbGlkZWFuIEdDRCBodHRwczovL2JyaWxsaWFudC5vcmcvd2lraS9leHRlbmRlZC1ldWNsaWRlYW4tYWxnb3JpdGhtL1xuICAgIC8vIEZlcm1hdCdzIGxpdHRsZSB0aGVvcmVtIFwiQ1QtbGlrZVwiIHZlcnNpb24gaW52KG4pID0gbl4obS0yKSBtb2QgbSBpcyAzMHggc2xvd2VyLlxuICAgIGxldCBhID0gbW9kKG51bWJlciwgbW9kdWxvKTtcbiAgICBsZXQgYiA9IG1vZHVsbztcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBsZXQgeCA9IF8wbiwgeSA9IF8xbiwgdSA9IF8xbiwgdiA9IF8wbjtcbiAgICB3aGlsZSAoYSAhPT0gXzBuKSB7XG4gICAgICAgIC8vIEpJVCBhcHBsaWVzIG9wdGltaXphdGlvbiBpZiB0aG9zZSB0d28gbGluZXMgZm9sbG93IGVhY2ggb3RoZXJcbiAgICAgICAgY29uc3QgcSA9IGIgLyBhO1xuICAgICAgICBjb25zdCByID0gYiAlIGE7XG4gICAgICAgIGNvbnN0IG0gPSB4IC0gdSAqIHE7XG4gICAgICAgIGNvbnN0IG4gPSB5IC0gdiAqIHE7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBiID0gYSwgYSA9IHIsIHggPSB1LCB5ID0gdiwgdSA9IG0sIHYgPSBuO1xuICAgIH1cbiAgICBjb25zdCBnY2QgPSBiO1xuICAgIGlmIChnY2QgIT09IF8xbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZlcnQ6IGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgcmV0dXJuIG1vZCh4LCBtb2R1bG8pO1xufVxuLyoqXG4gKiBUb25lbGxpLVNoYW5rcyBzcXVhcmUgcm9vdCBzZWFyY2ggYWxnb3JpdGhtLlxuICogMS4gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEyKVxuICogMi4gU3F1YXJlIFJvb3RzIGZyb20gMTsgMjQsIDUxLCAxMCB0byBEYW4gU2hhbmtzXG4gKiBXaWxsIHN0YXJ0IGFuIGluZmluaXRlIGxvb3AgaWYgZmllbGQgb3JkZXIgUCBpcyBub3QgcHJpbWUuXG4gKiBAcGFyYW0gUCBmaWVsZCBvcmRlclxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB0YWtlcyBmaWVsZCBGcCAoY3JlYXRlZCBmcm9tIFApIGFuZCBudW1iZXIgblxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9uZWxsaVNoYW5rcyhQKSB7XG4gICAgLy8gTGVnZW5kcmUgY29uc3RhbnQ6IHVzZWQgdG8gY2FsY3VsYXRlIExlZ2VuZHJlIHN5bWJvbCAoYSB8IHApLFxuICAgIC8vIHdoaWNoIGRlbm90ZXMgdGhlIHZhbHVlIG9mIGFeKChwLTEpLzIpIChtb2QgcCkuXG4gICAgLy8gKGEgfCBwKSDiiaEgMSAgICBpZiBhIGlzIGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAtMSAgIGlmIGEgaXMgbm90IGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAwICAgIGlmIGEg4omhIDAgKG1vZCBwKVxuICAgIGNvbnN0IGxlZ2VuZHJlQyA9IChQIC0gXzFuKSAvIF8ybjtcbiAgICBsZXQgUSwgUywgWjtcbiAgICAvLyBTdGVwIDE6IEJ5IGZhY3RvcmluZyBvdXQgcG93ZXJzIG9mIDIgZnJvbSBwIC0gMSxcbiAgICAvLyBmaW5kIHEgYW5kIHMgc3VjaCB0aGF0IHAgLSAxID0gcSooMl5zKSB3aXRoIHEgb2RkXG4gICAgZm9yIChRID0gUCAtIF8xbiwgUyA9IDA7IFEgJSBfMm4gPT09IF8wbjsgUSAvPSBfMm4sIFMrKylcbiAgICAgICAgO1xuICAgIC8vIFN0ZXAgMjogU2VsZWN0IGEgbm9uLXNxdWFyZSB6IHN1Y2ggdGhhdCAoeiB8IHApIOKJoSAtMSBhbmQgc2V0IGMg4omhIHpxXG4gICAgZm9yIChaID0gXzJuOyBaIDwgUCAmJiBwb3coWiwgbGVnZW5kcmVDLCBQKSAhPT0gUCAtIF8xbjsgWisrKVxuICAgICAgICA7XG4gICAgLy8gRmFzdC1wYXRoXG4gICAgaWYgKFMgPT09IDEpIHtcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaUZhc3QoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFNsb3ctcGF0aFxuICAgIGNvbnN0IFExZGl2MiA9IChRICsgXzFuKSAvIF8ybjtcbiAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaVNsb3coRnAsIG4pIHtcbiAgICAgICAgLy8gU3RlcCAwOiBDaGVjayB0aGF0IG4gaXMgaW5kZWVkIGEgc3F1YXJlOiAobiB8IHApIHNob3VsZCBub3QgYmUg4omhIC0xXG4gICAgICAgIGlmIChGcC5wb3cobiwgbGVnZW5kcmVDKSA9PT0gRnAubmVnKEZwLk9ORSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgIGxldCByID0gUztcbiAgICAgICAgLy8gVE9ETzogd2lsbCBmYWlsIGF0IEZwMi9ldGNcbiAgICAgICAgbGV0IGcgPSBGcC5wb3coRnAubXVsKEZwLk9ORSwgWiksIFEpOyAvLyB3aWxsIHVwZGF0ZSBib3RoIHggYW5kIGJcbiAgICAgICAgbGV0IHggPSBGcC5wb3cobiwgUTFkaXYyKTsgLy8gZmlyc3QgZ3Vlc3MgYXQgdGhlIHNxdWFyZSByb290XG4gICAgICAgIGxldCBiID0gRnAucG93KG4sIFEpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgZnVkZ2UgZmFjdG9yXG4gICAgICAgIHdoaWxlICghRnAuZXFsKGIsIEZwLk9ORSkpIHtcbiAgICAgICAgICAgIGlmIChGcC5lcWwoYiwgRnAuWkVSTykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZwLlpFUk87IC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RvbmVsbGklRTIlODAlOTNTaGFua3NfYWxnb3JpdGhtICg0LiBJZiB0ID0gMCwgcmV0dXJuIHIgPSAwKVxuICAgICAgICAgICAgLy8gRmluZCBtIHN1Y2ggYl4oMl5tKT09MVxuICAgICAgICAgICAgbGV0IG0gPSAxO1xuICAgICAgICAgICAgZm9yIChsZXQgdDIgPSBGcC5zcXIoYik7IG0gPCByOyBtKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoRnAuZXFsKHQyLCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0MiA9IEZwLnNxcih0Mik7IC8vIHQyICo9IHQyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOT1RFOiByLW0tMSBjYW4gYmUgYmlnZ2VyIHRoYW4gMzIsIG5lZWQgdG8gY29udmVydCB0byBiaWdpbnQgYmVmb3JlIHNoaWZ0LCBvdGhlcndpc2UgdGhlcmUgd2lsbCBiZSBvdmVyZmxvd1xuICAgICAgICAgICAgY29uc3QgZ2UgPSBGcC5wb3coZywgXzFuIDw8IEJpZ0ludChyIC0gbSAtIDEpKTsgLy8gZ2UgPSAyXihyLW0tMSlcbiAgICAgICAgICAgIGcgPSBGcC5zcXIoZ2UpOyAvLyBnID0gZ2UgKiBnZVxuICAgICAgICAgICAgeCA9IEZwLm11bCh4LCBnZSk7IC8vIHggKj0gZ2VcbiAgICAgICAgICAgIGIgPSBGcC5tdWwoYiwgZyk7IC8vIGIgKj0gZ1xuICAgICAgICAgICAgciA9IG07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnQoUCkge1xuICAgIC8vIE5PVEU6IGRpZmZlcmVudCBhbGdvcml0aG1zIGNhbiBnaXZlIGRpZmZlcmVudCByb290cywgaXQgaXMgdXAgdG8gdXNlciB0byBkZWNpZGUgd2hpY2ggb25lIHRoZXkgd2FudC5cbiAgICAvLyBGb3IgZXhhbXBsZSB0aGVyZSBpcyBGcFNxcnRPZGQvRnBTcXJ0RXZlbiB0byBjaG9pY2Ugcm9vdCBiYXNlZCBvbiBvZGRuZXNzICh1c2VkIGZvciBoYXNoLXRvLWN1cnZlKS5cbiAgICAvLyBQIOKJoSAzIChtb2QgNClcbiAgICAvLyDiiJpuID0gbl4oKFArMSkvNClcbiAgICBpZiAoUCAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIE5vdCBhbGwgcm9vdHMgcG9zc2libGUhXG4gICAgICAgIC8vIGNvbnN0IE9SREVSID1cbiAgICAgICAgLy8gICAweDFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYWFhYm47XG4gICAgICAgIC8vIGNvbnN0IE5VTSA9IDcyMDU3NTk0MDM3OTI3ODE2bjtcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3FydDNtb2Q0KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgICAgICAgICAvLyBUaHJvdyBpZiByb290KioyICE9IG5cbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEF0a2luIGFsZ29yaXRobSBmb3IgcSDiiaEgNSAobW9kIDgpLCBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKHBhZ2UgMTApXG4gICAgaWYgKFAgJSBfOG4gPT09IF81bikge1xuICAgICAgICBjb25zdCBjMSA9IChQIC0gXzVuKSAvIF84bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQ1bW9kOChGcCwgbikge1xuICAgICAgICAgICAgY29uc3QgbjIgPSBGcC5tdWwobiwgXzJuKTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBGcC5wb3cobjIsIGMxKTtcbiAgICAgICAgICAgIGNvbnN0IG52ID0gRnAubXVsKG4sIHYpO1xuICAgICAgICAgICAgY29uc3QgaSA9IEZwLm11bChGcC5tdWwobnYsIF8ybiksIHYpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLm11bChudiwgRnAuc3ViKGksIEZwLk9ORSkpO1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gUCDiiaEgOSAobW9kIDE2KVxuICAgIGlmIChQICUgXzE2biA9PT0gXzluKSB7XG4gICAgICAgIC8vIE5PVEU6IHRvbmVsbGkgaXMgdG9vIHNsb3cgZm9yIGJscy1GcDIgY2FsY3VsYXRpb25zIGV2ZW4gb24gc3RhcnRcbiAgICAgICAgLy8gTWVhbnMgd2UgY2Fubm90IHVzZSBzcXJ0IGZvciBjb25zdGFudHMgYXQgYWxsIVxuICAgICAgICAvL1xuICAgICAgICAvLyBjb25zdCBjMSA9IEZwLnNxcnQoRnAubmVnYXRlKEZwLk9ORSkpOyAvLyAgMS4gYzEgPSBzcXJ0KC0xKSBpbiBGLCBpLmUuLCAoYzFeMikgPT0gLTEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjMiA9IEZwLnNxcnQoYzEpOyAgICAgICAgICAgICAgICAvLyAgMi4gYzIgPSBzcXJ0KGMxKSBpbiBGLCBpLmUuLCAoYzJeMikgPT0gYzEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjMyA9IEZwLnNxcnQoRnAubmVnYXRlKGMxKSk7ICAgICAvLyAgMy4gYzMgPSBzcXJ0KC1jMSkgaW4gRiwgaS5lLiwgKGMzXjIpID09IC1jMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGM0ID0gKFAgKyBfN24pIC8gXzE2bjsgICAgICAgICAgIC8vICA0LiBjNCA9IChxICsgNykgLyAxNiAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICAgICAgLy8gc3FydCA9ICh4KSA9PiB7XG4gICAgICAgIC8vICAgbGV0IHR2MSA9IEZwLnBvdyh4LCBjNCk7ICAgICAgICAgICAgIC8vICAxLiB0djEgPSB4XmM0XG4gICAgICAgIC8vICAgbGV0IHR2MiA9IEZwLm11bChjMSwgdHYxKTsgICAgICAgICAgIC8vICAyLiB0djIgPSBjMSAqIHR2MVxuICAgICAgICAvLyAgIGNvbnN0IHR2MyA9IEZwLm11bChjMiwgdHYxKTsgICAgICAgICAvLyAgMy4gdHYzID0gYzIgKiB0djFcbiAgICAgICAgLy8gICBsZXQgdHY0ID0gRnAubXVsKGMzLCB0djEpOyAgICAgICAgICAgLy8gIDQuIHR2NCA9IGMzICogdHYxXG4gICAgICAgIC8vICAgY29uc3QgZTEgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgNS4gIGUxID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgY29uc3QgZTIgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MyksIHgpOyAvLyAgNi4gIGUyID0gKHR2M14yKSA9PSB4XG4gICAgICAgIC8vICAgdHYxID0gRnAuY21vdih0djEsIHR2MiwgZTEpOyAvLyAgNy4gdHYxID0gQ01PVih0djEsIHR2MiwgZTEpICAjIFNlbGVjdCB0djIgaWYgKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgdHYyID0gRnAuY21vdih0djQsIHR2MywgZTIpOyAvLyAgOC4gdHYyID0gQ01PVih0djQsIHR2MywgZTIpICAjIFNlbGVjdCB0djMgaWYgKHR2M14yKSA9PSB4XG4gICAgICAgIC8vICAgY29uc3QgZTMgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgOS4gIGUzID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgcmV0dXJuIEZwLmNtb3YodHYxLCB0djIsIGUzKTsgLy8gIDEwLiAgeiA9IENNT1YodHYxLCB0djIsIGUzKSAgIyBTZWxlY3QgdGhlIHNxcnQgZnJvbSB0djEgYW5kIHR2MlxuICAgICAgICAvLyB9XG4gICAgfVxuICAgIC8vIE90aGVyIGNhc2VzOiBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG1cbiAgICByZXR1cm4gdG9uZWxsaVNoYW5rcyhQKTtcbn1cbi8vIExpdHRsZS1lbmRpYW4gY2hlY2sgZm9yIGZpcnN0IExFIGJpdCAobGFzdCBCRSBiaXQpO1xuZXhwb3J0IGNvbnN0IGlzTmVnYXRpdmVMRSA9IChudW0sIG1vZHVsbykgPT4gKG1vZChudW0sIG1vZHVsbykgJiBfMW4pID09PSBfMW47XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IEZJRUxEX0ZJRUxEUyA9IFtcbiAgICAnY3JlYXRlJywgJ2lzVmFsaWQnLCAnaXMwJywgJ25lZycsICdpbnYnLCAnc3FydCcsICdzcXInLFxuICAgICdlcWwnLCAnYWRkJywgJ3N1YicsICdtdWwnLCAncG93JywgJ2RpdicsXG4gICAgJ2FkZE4nLCAnc3ViTicsICdtdWxOJywgJ3Nxck4nXG5dO1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRmllbGQoZmllbGQpIHtcbiAgICBjb25zdCBpbml0aWFsID0ge1xuICAgICAgICBPUkRFUjogJ2JpZ2ludCcsXG4gICAgICAgIE1BU0s6ICdiaWdpbnQnLFxuICAgICAgICBCWVRFUzogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBCSVRTOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgfTtcbiAgICBjb25zdCBvcHRzID0gRklFTERfRklFTERTLnJlZHVjZSgobWFwLCB2YWwpID0+IHtcbiAgICAgICAgbWFwW3ZhbF0gPSAnZnVuY3Rpb24nO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH0sIGluaXRpYWwpO1xuICAgIHJldHVybiB2YWxpZGF0ZU9iamVjdChmaWVsZCwgb3B0cyk7XG59XG4vLyBHZW5lcmljIGZpZWxkIGZ1bmN0aW9uc1xuLyoqXG4gKiBTYW1lIGFzIGBwb3dgIGJ1dCBmb3IgRnA6IG5vbi1jb25zdGFudC10aW1lLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBQb3coZiwgbnVtLCBwb3dlcikge1xuICAgIC8vIFNob3VsZCBoYXZlIHNhbWUgc3BlZWQgYXMgcG93IGZvciBiaWdpbnRzXG4gICAgLy8gVE9ETzogYmVuY2htYXJrIVxuICAgIGlmIChwb3dlciA8IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb3dlciA+IDAnKTtcbiAgICBpZiAocG93ZXIgPT09IF8wbilcbiAgICAgICAgcmV0dXJuIGYuT05FO1xuICAgIGlmIChwb3dlciA9PT0gXzFuKVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIGxldCBwID0gZi5PTkU7XG4gICAgbGV0IGQgPSBudW07XG4gICAgd2hpbGUgKHBvd2VyID4gXzBuKSB7XG4gICAgICAgIGlmIChwb3dlciAmIF8xbilcbiAgICAgICAgICAgIHAgPSBmLm11bChwLCBkKTtcbiAgICAgICAgZCA9IGYuc3FyKGQpO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgaW52ZXJ0IGFuIGFycmF5IG9mIEZpZWxkIGVsZW1lbnRzLlxuICogYGludigwKWAgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGAgaGVyZTogbWFrZSBzdXJlIHRvIHRocm93IGFuIGVycm9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBJbnZlcnRCYXRjaChmLCBudW1zKSB7XG4gICAgY29uc3QgdG1wID0gbmV3IEFycmF5KG51bXMubGVuZ3RoKTtcbiAgICAvLyBXYWxrIGZyb20gZmlyc3QgdG8gbGFzdCwgbXVsdGlwbHkgdGhlbSBieSBlYWNoIG90aGVyIE1PRCBwXG4gICAgY29uc3QgbGFzdE11bHRpcGxpZWQgPSBudW1zLnJlZHVjZSgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKGYuaXMwKG51bSkpXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB0bXBbaV0gPSBhY2M7XG4gICAgICAgIHJldHVybiBmLm11bChhY2MsIG51bSk7XG4gICAgfSwgZi5PTkUpO1xuICAgIC8vIEludmVydCBsYXN0IGVsZW1lbnRcbiAgICBjb25zdCBpbnZlcnRlZCA9IGYuaW52KGxhc3RNdWx0aXBsaWVkKTtcbiAgICAvLyBXYWxrIGZyb20gbGFzdCB0byBmaXJzdCwgbXVsdGlwbHkgdGhlbSBieSBpbnZlcnRlZCBlYWNoIG90aGVyIE1PRCBwXG4gICAgbnVtcy5yZWR1Y2VSaWdodCgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKGYuaXMwKG51bSkpXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB0bXBbaV0gPSBmLm11bChhY2MsIHRtcFtpXSk7XG4gICAgICAgIHJldHVybiBmLm11bChhY2MsIG51bSk7XG4gICAgfSwgaW52ZXJ0ZWQpO1xuICAgIHJldHVybiB0bXA7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBEaXYoZiwgbGhzLCByaHMpIHtcbiAgICByZXR1cm4gZi5tdWwobGhzLCB0eXBlb2YgcmhzID09PSAnYmlnaW50JyA/IGludmVydChyaHMsIGYuT1JERVIpIDogZi5pbnYocmhzKSk7XG59XG4vLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgVHJ1ZSB3aGVuZXZlciB0aGUgdmFsdWUgeCBpcyBhIHNxdWFyZSBpbiB0aGUgZmllbGQgRi5cbmV4cG9ydCBmdW5jdGlvbiBGcElzU3F1YXJlKGYpIHtcbiAgICBjb25zdCBsZWdlbmRyZUNvbnN0ID0gKGYuT1JERVIgLSBfMW4pIC8gXzJuOyAvLyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICByZXR1cm4gKHgpID0+IHtcbiAgICAgICAgY29uc3QgcCA9IGYucG93KHgsIGxlZ2VuZHJlQ29uc3QpO1xuICAgICAgICByZXR1cm4gZi5lcWwocCwgZi5aRVJPKSB8fCBmLmVxbChwLCBmLk9ORSk7XG4gICAgfTtcbn1cbi8vIENVUlZFLm4gbGVuZ3Roc1xuZXhwb3J0IGZ1bmN0aW9uIG5MZW5ndGgobiwgbkJpdExlbmd0aCkge1xuICAgIC8vIEJpdCBzaXplLCBieXRlIHNpemUgb2YgQ1VSVkUublxuICAgIGNvbnN0IF9uQml0TGVuZ3RoID0gbkJpdExlbmd0aCAhPT0gdW5kZWZpbmVkID8gbkJpdExlbmd0aCA6IG4udG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IG5CeXRlTGVuZ3RoID0gTWF0aC5jZWlsKF9uQml0TGVuZ3RoIC8gOCk7XG4gICAgcmV0dXJuIHsgbkJpdExlbmd0aDogX25CaXRMZW5ndGgsIG5CeXRlTGVuZ3RoIH07XG59XG4vKipcbiAqIEluaXRpYWxpemVzIGEgZmluaXRlIGZpZWxkIG92ZXIgcHJpbWUuICoqTm9uLXByaW1lcyBhcmUgbm90IHN1cHBvcnRlZC4qKlxuICogRG8gbm90IGluaXQgaW4gbG9vcDogc2xvdy4gVmVyeSBmcmFnaWxlOiBhbHdheXMgcnVuIGEgYmVuY2htYXJrIG9uIGEgY2hhbmdlLlxuICogTWFqb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uczpcbiAqICogYSkgZGVub3JtYWxpemVkIG9wZXJhdGlvbnMgbGlrZSBtdWxOIGluc3RlYWQgb2YgbXVsXG4gKiAqIGIpIHNhbWUgb2JqZWN0IHNoYXBlOiBuZXZlciBhZGQgb3IgcmVtb3ZlIGtleXNcbiAqICogYykgT2JqZWN0LmZyZWV6ZVxuICogQHBhcmFtIE9SREVSIHByaW1lIHBvc2l0aXZlIGJpZ2ludFxuICogQHBhcmFtIGJpdExlbiBob3cgbWFueSBiaXRzIHRoZSBmaWVsZCBjb25zdW1lc1xuICogQHBhcmFtIGlzTEUgKGRlZjogZmFsc2UpIGlmIGVuY29kaW5nIC8gZGVjb2Rpbmcgc2hvdWxkIGJlIGluIGxpdHRsZS1lbmRpYW5cbiAqIEBwYXJhbSByZWRlZiBvcHRpb25hbCBmYXN0ZXIgcmVkZWZpbml0aW9ucyBvZiBzcXJ0IGFuZCBvdGhlciBtZXRob2RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGaWVsZChPUkRFUiwgYml0TGVuLCBpc0xFID0gZmFsc2UsIHJlZGVmID0ge30pIHtcbiAgICBpZiAoT1JERVIgPD0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIEZpZWxkIE9SREVSID4gMCwgZ290ICR7T1JERVJ9YCk7XG4gICAgY29uc3QgeyBuQml0TGVuZ3RoOiBCSVRTLCBuQnl0ZUxlbmd0aDogQllURVMgfSA9IG5MZW5ndGgoT1JERVIsIGJpdExlbik7XG4gICAgaWYgKEJZVEVTID4gMjA0OClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWVsZCBsZW5ndGhzIG92ZXIgMjA0OCBieXRlcyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgIGNvbnN0IHNxcnRQID0gRnBTcXJ0KE9SREVSKTtcbiAgICBjb25zdCBmID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIE9SREVSLFxuICAgICAgICBCSVRTLFxuICAgICAgICBCWVRFUyxcbiAgICAgICAgTUFTSzogYml0TWFzayhCSVRTKSxcbiAgICAgICAgWkVSTzogXzBuLFxuICAgICAgICBPTkU6IF8xbixcbiAgICAgICAgY3JlYXRlOiAobnVtKSA9PiBtb2QobnVtLCBPUkRFUiksXG4gICAgICAgIGlzVmFsaWQ6IChudW0pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZmllbGQgZWxlbWVudDogZXhwZWN0ZWQgYmlnaW50LCBnb3QgJHt0eXBlb2YgbnVtfWApO1xuICAgICAgICAgICAgcmV0dXJuIF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVI7IC8vIDAgaXMgdmFsaWQgZWxlbWVudCwgYnV0IGl0J3Mgbm90IGludmVydGlibGVcbiAgICAgICAgfSxcbiAgICAgICAgaXMwOiAobnVtKSA9PiBudW0gPT09IF8wbixcbiAgICAgICAgaXNPZGQ6IChudW0pID0+IChudW0gJiBfMW4pID09PSBfMW4sXG4gICAgICAgIG5lZzogKG51bSkgPT4gbW9kKC1udW0sIE9SREVSKSxcbiAgICAgICAgZXFsOiAobGhzLCByaHMpID0+IGxocyA9PT0gcmhzLFxuICAgICAgICBzcXI6IChudW0pID0+IG1vZChudW0gKiBudW0sIE9SREVSKSxcbiAgICAgICAgYWRkOiAobGhzLCByaHMpID0+IG1vZChsaHMgKyByaHMsIE9SREVSKSxcbiAgICAgICAgc3ViOiAobGhzLCByaHMpID0+IG1vZChsaHMgLSByaHMsIE9SREVSKSxcbiAgICAgICAgbXVsOiAobGhzLCByaHMpID0+IG1vZChsaHMgKiByaHMsIE9SREVSKSxcbiAgICAgICAgcG93OiAobnVtLCBwb3dlcikgPT4gRnBQb3coZiwgbnVtLCBwb3dlciksXG4gICAgICAgIGRpdjogKGxocywgcmhzKSA9PiBtb2QobGhzICogaW52ZXJ0KHJocywgT1JERVIpLCBPUkRFUiksXG4gICAgICAgIC8vIFNhbWUgYXMgYWJvdmUsIGJ1dCBkb2Vzbid0IG5vcm1hbGl6ZVxuICAgICAgICBzcXJOOiAobnVtKSA9PiBudW0gKiBudW0sXG4gICAgICAgIGFkZE46IChsaHMsIHJocykgPT4gbGhzICsgcmhzLFxuICAgICAgICBzdWJOOiAobGhzLCByaHMpID0+IGxocyAtIHJocyxcbiAgICAgICAgbXVsTjogKGxocywgcmhzKSA9PiBsaHMgKiByaHMsXG4gICAgICAgIGludjogKG51bSkgPT4gaW52ZXJ0KG51bSwgT1JERVIpLFxuICAgICAgICBzcXJ0OiByZWRlZi5zcXJ0IHx8ICgobikgPT4gc3FydFAoZiwgbikpLFxuICAgICAgICBpbnZlcnRCYXRjaDogKGxzdCkgPT4gRnBJbnZlcnRCYXRjaChmLCBsc3QpLFxuICAgICAgICAvLyBUT0RPOiBkbyB3ZSByZWFsbHkgbmVlZCBjb25zdGFudCBjbW92P1xuICAgICAgICAvLyBXZSBkb24ndCBoYXZlIGNvbnN0LXRpbWUgYmlnaW50cyBhbnl3YXksIHNvIHByb2JhYmx5IHdpbGwgYmUgbm90IHZlcnkgdXNlZnVsXG4gICAgICAgIGNtb3Y6IChhLCBiLCBjKSA9PiAoYyA/IGIgOiBhKSxcbiAgICAgICAgdG9CeXRlczogKG51bSkgPT4gKGlzTEUgPyBudW1iZXJUb0J5dGVzTEUobnVtLCBCWVRFUykgOiBudW1iZXJUb0J5dGVzQkUobnVtLCBCWVRFUykpLFxuICAgICAgICBmcm9tQnl0ZXM6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gQllURVMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGcC5mcm9tQnl0ZXM6IGV4cGVjdGVkICR7QllURVN9LCBnb3QgJHtieXRlcy5sZW5ndGh9YCk7XG4gICAgICAgICAgICByZXR1cm4gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShieXRlcykgOiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGYpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydE9kZChGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRgKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IHJvb3QgOiBGcC5uZWcocm9vdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0RXZlbihGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRgKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IEZwLm5lZyhyb290KSA6IHJvb3Q7XG59XG4vKipcbiAqIFwiQ29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIFNhbWUgYXMgbWFwS2V5VG9GaWVsZCwgYnV0IGFjY2VwdHMgbGVzcyBieXRlcyAoNDAgaW5zdGVhZCBvZiA0OCBmb3IgMzItYnl0ZSBmaWVsZCkuXG4gKiBXaGljaCBtYWtlcyBpdCBzbGlnaHRseSBtb3JlIGJpYXNlZCwgbGVzcyBzZWN1cmUuXG4gKiBAZGVwcmVjYXRlZCB1c2UgbWFwS2V5VG9GaWVsZCBpbnN0ZWFkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoVG9Qcml2YXRlU2NhbGFyKGhhc2gsIGdyb3VwT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGhhc2ggPSBlbnN1cmVCeXRlcygncHJpdmF0ZUhhc2gnLCBoYXNoKTtcbiAgICBjb25zdCBoYXNoTGVuID0gaGFzaC5sZW5ndGg7XG4gICAgY29uc3QgbWluTGVuID0gbkxlbmd0aChncm91cE9yZGVyKS5uQnl0ZUxlbmd0aCArIDg7XG4gICAgaWYgKG1pbkxlbiA8IDI0IHx8IGhhc2hMZW4gPCBtaW5MZW4gfHwgaGFzaExlbiA+IDEwMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaGFzaFRvUHJpdmF0ZVNjYWxhcjogZXhwZWN0ZWQgJHttaW5MZW59LTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAke2hhc2hMZW59YCk7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShoYXNoKSA6IGJ5dGVzVG9OdW1iZXJCRShoYXNoKTtcbiAgICByZXR1cm4gbW9kKG51bSwgZ3JvdXBPcmRlciAtIF8xbikgKyBfMW47XG59XG4vKipcbiAqIFJldHVybnMgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIGNvbnN1bWVkIGJ5IHRoZSBmaWVsZCBlbGVtZW50LlxuICogRm9yIGV4YW1wbGUsIDMyIGJ5dGVzIGZvciB1c3VhbCAyNTYtYml0IHdlaWVyc3RyYXNzIGN1cnZlLlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIGZpZWxkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpIHtcbiAgICBpZiAodHlwZW9mIGZpZWxkT3JkZXIgIT09ICdiaWdpbnQnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpZWxkIG9yZGVyIG11c3QgYmUgYmlnaW50Jyk7XG4gICAgY29uc3QgYml0TGVuZ3RoID0gZmllbGRPcmRlci50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgcmV0dXJuIE1hdGguY2VpbChiaXRMZW5ndGggLyA4KTtcbn1cbi8qKlxuICogUmV0dXJucyBtaW5pbWFsIGFtb3VudCBvZiBieXRlcyB0aGF0IGNhbiBiZSBzYWZlbHkgcmVkdWNlZFxuICogYnkgZmllbGQgb3JkZXIuXG4gKiBTaG91bGQgYmUgMl4tMTI4IGZvciAxMjgtYml0IGN1cnZlIHN1Y2ggYXMgUDI1Ni5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiB0YXJnZXQgaGFzaFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcbiAgICByZXR1cm4gbGVuZ3RoICsgTWF0aC5jZWlsKGxlbmd0aCAvIDIpO1xufVxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBDYW4gdGFrZSAobiArIG4vMikgb3IgbW9yZSBieXRlcyBvZiB1bmlmb3JtIGlucHV0IGUuZy4gZnJvbSBDU1BSTkcgb3IgS0RGXG4gKiBhbmQgY29udmVydCB0aGVtIGludG8gcHJpdmF0ZSBzY2FsYXIsIHdpdGggdGhlIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gKiBOZWVkcyBhdCBsZWFzdCA0OCBieXRlcyBvZiBpbnB1dCBmb3IgMzItYnl0ZSBwcml2YXRlIGtleS5cbiAqIGh0dHBzOi8vcmVzZWFyY2gua3VkZWxza2lzZWN1cml0eS5jb20vMjAyMC8wNy8yOC90aGUtZGVmaW5pdGl2ZS1ndWlkZS10by1tb2R1bG8tYmlhcy1hbmQtaG93LXRvLWF2b2lkLWl0L1xuICogRklQUyAxODYtNSwgQS4yIGh0dHBzOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZGV0YWlsL2ZpcHMvMTg2LzUvZmluYWxcbiAqIFJGQyA5MzgwLCBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTVcbiAqIEBwYXJhbSBoYXNoIGhhc2ggb3V0cHV0IGZyb20gU0hBMyBvciBhIHNpbWlsYXIgZnVuY3Rpb25cbiAqIEBwYXJhbSBncm91cE9yZGVyIHNpemUgb2Ygc3ViZ3JvdXAgLSAoZS5nLiBzZWNwMjU2azEuQ1VSVkUubilcbiAqIEBwYXJhbSBpc0xFIGludGVycHJldCBoYXNoIGJ5dGVzIGFzIExFIG51bVxuICogQHJldHVybnMgdmFsaWQgcHJpdmF0ZSBzY2FsYXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcEhhc2hUb0ZpZWxkKGtleSwgZmllbGRPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbGVuID0ga2V5Lmxlbmd0aDtcbiAgICBjb25zdCBmaWVsZExlbiA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgY29uc3QgbWluTGVuID0gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKTtcbiAgICAvLyBObyBzbWFsbCBudW1iZXJzOiBuZWVkIHRvIHVuZGVyc3RhbmQgYmlhcyBzdG9yeS4gTm8gaHVnZSBudW1iZXJzOiBlYXNpZXIgdG8gZGV0ZWN0IEpTIHRpbWluZ3MuXG4gICAgaWYgKGxlbiA8IDE2IHx8IGxlbiA8IG1pbkxlbiB8fCBsZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7bWluTGVufS0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJHtsZW59YCk7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJCRShrZXkpIDogYnl0ZXNUb051bWJlckxFKGtleSk7XG4gICAgLy8gYG1vZCh4LCAxMSlgIGNhbiBzb21ldGltZXMgcHJvZHVjZSAwLiBgbW9kKHgsIDEwKSArIDFgIGlzIHRoZSBzYW1lLCBidXQgbm8gMFxuICAgIGNvbnN0IHJlZHVjZWQgPSBtb2QobnVtLCBmaWVsZE9yZGVyIC0gXzFuKSArIF8xbjtcbiAgICByZXR1cm4gaXNMRSA/IG51bWJlclRvQnl0ZXNMRShyZWR1Y2VkLCBmaWVsZExlbikgOiBudW1iZXJUb0J5dGVzQkUocmVkdWNlZCwgZmllbGRMZW4pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxhci5qcy5tYXAiXSwibmFtZXMiOlsiYml0TWFzayIsIm51bWJlclRvQnl0ZXNCRSIsIm51bWJlclRvQnl0ZXNMRSIsImJ5dGVzVG9OdW1iZXJCRSIsImJ5dGVzVG9OdW1iZXJMRSIsImVuc3VyZUJ5dGVzIiwidmFsaWRhdGVPYmplY3QiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJfM24iLCJfNG4iLCJfNW4iLCJfOG4iLCJfOW4iLCJfMTZuIiwibW9kIiwiYSIsImIiLCJyZXN1bHQiLCJwb3ciLCJudW0iLCJwb3dlciIsIm1vZHVsbyIsIkVycm9yIiwicmVzIiwicG93MiIsIngiLCJpbnZlcnQiLCJudW1iZXIiLCJ5IiwidSIsInYiLCJxIiwiciIsIm0iLCJuIiwiZ2NkIiwidG9uZWxsaVNoYW5rcyIsIlAiLCJsZWdlbmRyZUMiLCJRIiwiUyIsIloiLCJwMWRpdjQiLCJ0b25lbGxpRmFzdCIsIkZwIiwicm9vdCIsImVxbCIsInNxciIsIlExZGl2MiIsInRvbmVsbGlTbG93IiwibmVnIiwiT05FIiwiZyIsIm11bCIsIlpFUk8iLCJ0MiIsImdlIiwiRnBTcXJ0Iiwic3FydDNtb2Q0IiwiYzEiLCJzcXJ0NW1vZDgiLCJuMiIsIm52IiwiaSIsInN1YiIsImlzTmVnYXRpdmVMRSIsIkZJRUxEX0ZJRUxEUyIsInZhbGlkYXRlRmllbGQiLCJmaWVsZCIsImluaXRpYWwiLCJPUkRFUiIsIk1BU0siLCJCWVRFUyIsIkJJVFMiLCJvcHRzIiwicmVkdWNlIiwibWFwIiwidmFsIiwiRnBQb3ciLCJmIiwicCIsImQiLCJGcEludmVydEJhdGNoIiwibnVtcyIsInRtcCIsIkFycmF5IiwibGVuZ3RoIiwibGFzdE11bHRpcGxpZWQiLCJhY2MiLCJpczAiLCJpbnZlcnRlZCIsImludiIsInJlZHVjZVJpZ2h0IiwiRnBEaXYiLCJsaHMiLCJyaHMiLCJGcElzU3F1YXJlIiwibGVnZW5kcmVDb25zdCIsIm5MZW5ndGgiLCJuQml0TGVuZ3RoIiwiX25CaXRMZW5ndGgiLCJ1bmRlZmluZWQiLCJ0b1N0cmluZyIsIm5CeXRlTGVuZ3RoIiwiTWF0aCIsImNlaWwiLCJGaWVsZCIsImJpdExlbiIsImlzTEUiLCJyZWRlZiIsInNxcnRQIiwiT2JqZWN0IiwiZnJlZXplIiwiY3JlYXRlIiwiaXNWYWxpZCIsImlzT2RkIiwiYWRkIiwiZGl2Iiwic3FyTiIsImFkZE4iLCJzdWJOIiwibXVsTiIsInNxcnQiLCJpbnZlcnRCYXRjaCIsImxzdCIsImNtb3YiLCJjIiwidG9CeXRlcyIsImZyb21CeXRlcyIsImJ5dGVzIiwiRnBTcXJ0T2RkIiwiZWxtIiwiRnBTcXJ0RXZlbiIsImhhc2hUb1ByaXZhdGVTY2FsYXIiLCJoYXNoIiwiZ3JvdXBPcmRlciIsImhhc2hMZW4iLCJtaW5MZW4iLCJnZXRGaWVsZEJ5dGVzTGVuZ3RoIiwiZmllbGRPcmRlciIsImJpdExlbmd0aCIsImdldE1pbkhhc2hMZW5ndGgiLCJtYXBIYXNoVG9GaWVsZCIsImtleSIsImxlbiIsImZpZWxkTGVuIiwicmVkdWNlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/utils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abytes: () => (/* binding */ abytes),\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nfunction isBytes(a) {\n    return a instanceof Uint8Array || a != null && typeof a === \"object\" && a.constructor.name === \"Uint8Array\";\n}\nfunction abytes(item) {\n    if (!isBytes(item)) throw new Error(\"Uint8Array expected\");\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    // Big Endian\n    return BigInt(hex === \"\" ? \"0\" : `0x${hex}`);\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = {\n    _0: 48,\n    _9: 57,\n    _A: 65,\n    _F: 70,\n    _a: 97,\n    _f: 102\n};\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2) throw new Error(\"padded hex string expected, got unpadded hex of length \" + hl);\n    const array = new Uint8Array(al);\n    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, \"0\"));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */ function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === \"string\") {\n        try {\n            res = hexToBytes(hex);\n        } catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    } else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    } else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === \"number\" && len !== expectedLength) throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */ function concatBytes(...arrays) {\n    let sum = 0;\n    for(let i = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length) return false;\n    let diff = 0;\n    for(let i = 0; i < a.length; i++)diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */ function bitLen(n) {\n    let len;\n    for(len = 0; n > _0n; n >>= _1n, len += 1);\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */ function bitGet(n, pos) {\n    return n >> BigInt(pos) & _1n;\n}\n/**\n * Sets single bit at position.\n */ function bitSet(n, pos, value) {\n    return n | (value ? _1n : _0n) << BigInt(pos);\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */ const bitMask = (n)=>(_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data)=>new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr)=>Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */ function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== \"number\" || hashLen < 2) throw new Error(\"hashLen must be a number\");\n    if (typeof qByteLen !== \"number\" || qByteLen < 2) throw new Error(\"qByteLen must be a number\");\n    if (typeof hmacFn !== \"function\") throw new Error(\"hmacFn must be a function\");\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = ()=>{\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b)=>hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n())=>{\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([\n            0x00\n        ]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0) return;\n        k = h(u8fr([\n            0x01\n        ]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = ()=>{\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000) throw new Error(\"drbg: tried 1000 values\");\n        let len = 0;\n        const out = [];\n        while(len < qByteLen){\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred)=>{\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while(!(res = pred(gen())))reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val)=>typeof val === \"bigint\",\n    function: (val)=>typeof val === \"function\",\n    boolean: (val)=>typeof val === \"boolean\",\n    string: (val)=>typeof val === \"string\",\n    stringOrUint8Array: (val)=>typeof val === \"string\" || isBytes(val),\n    isSafeInteger: (val)=>Number.isSafeInteger(val),\n    array: (val)=>Array.isArray(val),\n    field: (val, object)=>object.Fp.isValid(val),\n    hash: (val)=>typeof val === \"function\" && Number.isSafeInteger(val.outputLen)\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional)=>{\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== \"function\") throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined) return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))checkField(fieldName, type, true);\n    return object;\n} // validate type tests\n // const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n // const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n // // Should fail type-check\n // const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n // const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n // const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n // const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsb0VBQW9FLEdBQ3BFLDBFQUEwRTtBQUMxRSw4REFBOEQ7QUFDOUQsK0VBQStFO0FBQy9FLHVDQUF1QztBQUN2QyxNQUFNQSxNQUFNQyxPQUFPO0FBQ25CLE1BQU1DLE1BQU1ELE9BQU87QUFDbkIsTUFBTUUsTUFBTUYsT0FBTztBQUNaLFNBQVNHLFFBQVFDLENBQUM7SUFDckIsT0FBUUEsYUFBYUMsY0FDaEJELEtBQUssUUFBUSxPQUFPQSxNQUFNLFlBQVlBLEVBQUVFLFdBQVcsQ0FBQ0MsSUFBSSxLQUFLO0FBQ3RFO0FBQ08sU0FBU0MsT0FBT0MsSUFBSTtJQUN2QixJQUFJLENBQUNOLFFBQVFNLE9BQ1QsTUFBTSxJQUFJQyxNQUFNO0FBQ3hCO0FBQ0Esd0RBQXdEO0FBQ3hELE1BQU1DLFFBQVEsYUFBYSxHQUFHQyxNQUFNQyxJQUFJLENBQUM7SUFBRUMsUUFBUTtBQUFJLEdBQUcsQ0FBQ0MsR0FBR0MsSUFBTUEsRUFBRUMsUUFBUSxDQUFDLElBQUlDLFFBQVEsQ0FBQyxHQUFHO0FBQy9GOztDQUVDLEdBQ00sU0FBU0MsV0FBV0MsS0FBSztJQUM1QlosT0FBT1k7SUFDUCxvQ0FBb0M7SUFDcEMsSUFBSUMsTUFBTTtJQUNWLElBQUssSUFBSUwsSUFBSSxHQUFHQSxJQUFJSSxNQUFNTixNQUFNLEVBQUVFLElBQUs7UUFDbkNLLE9BQU9WLEtBQUssQ0FBQ1MsS0FBSyxDQUFDSixFQUFFLENBQUM7SUFDMUI7SUFDQSxPQUFPSztBQUNYO0FBQ08sU0FBU0Msb0JBQW9CQyxHQUFHO0lBQ25DLE1BQU1GLE1BQU1FLElBQUlOLFFBQVEsQ0FBQztJQUN6QixPQUFPSSxJQUFJUCxNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUMsRUFBRU8sSUFBSSxDQUFDLEdBQUdBO0FBQ3hDO0FBQ08sU0FBU0csWUFB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QUFTO1lBQ3hCLE1BQU0sSUFBSWxHLE1BQU0sQ0FBQyxjQUFjLEVBQUUrRyxPQUFPSixXQUFXLENBQUMsRUFBRWxCLElBQUksRUFBRSxFQUFFLE9BQU9BLElBQUksWUFBWSxFQUFFbUIsS0FBSyxDQUFDO1FBQ2pHO0lBQ0o7SUFDQSxLQUFLLE1BQU0sQ0FBQ0QsV0FBV0MsS0FBSyxJQUFJSSxPQUFPQyxPQUFPLENBQUNULFlBQzNDRSxXQUFXQyxXQUFXQyxNQUFNO0lBQ2hDLEtBQUssTUFBTSxDQUFDRCxXQUFXQyxLQUFLLElBQUlJLE9BQU9DLE9BQU8sQ0FBQ1IsZUFDM0NDLFdBQVdDLFdBQVdDLE1BQU07SUFDaEMsT0FBT1Y7QUFDWCxFQUNBLHNCQUFzQjtDQUN0Qix1RUFBdUU7Q0FDdkUsZ0ZBQWdGO0NBQ2hGLDRCQUE0QjtDQUM1QiwyREFBMkQ7Q0FDM0QscUVBQXFFO0NBQ3JFLCtEQUErRDtDQUMvRCw0REFBNEQ7Q0FDNUQsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2ZhcHAvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdXRpbHMuanM/Yjc4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyAxMDAgbGluZXMgb2YgY29kZSBpbiB0aGUgZmlsZSBhcmUgZHVwbGljYXRlZCBmcm9tIG5vYmxlLWhhc2hlcyAodXRpbHMpLlxuLy8gVGhpcyBpcyBPSzogYGFic3RyYWN0YCBkaXJlY3RvcnkgZG9lcyBub3QgdXNlIG5vYmxlLWhhc2hlcy5cbi8vIFVzZXIgbWF5IG9wdC1pbiBpbnRvIHVzaW5nIGRpZmZlcmVudCBoYXNoaW5nIGxpYnJhcnkuIFRoaXMgd2F5LCBub2JsZS1oYXNoZXNcbi8vIHdvbid0IGJlIGluY2x1ZGVkIGludG8gdGhlaXIgYnVuZGxlLlxuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gQmlnSW50KDIpO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhYnl0ZXMoaXRlbSkge1xuICAgIGlmICghaXNCeXRlcyhpdGVtKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG59XG4vLyBBcnJheSB3aGVyZSBpbmRleCAweGYwICgyNDApIGlzIG1hcHBlZCB0byBzdHJpbmcgJ2YwJ1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGFieXRlcyhieXRlcyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0hleFVucGFkZGVkKG51bSkge1xuICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleFRvTnVtYmVyKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIC8vIEJpZyBFbmRpYW5cbiAgICByZXR1cm4gQmlnSW50KGhleCA9PT0gJycgPyAnMCcgOiBgMHgke2hleH1gKTtcbn1cbi8vIFdlIHVzZSBvcHRpbWl6ZWQgdGVjaG5pcXVlIHRvIGNvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG5jb25zdCBhc2NpaXMgPSB7IF8wOiA0OCwgXzk6IDU3LCBfQTogNjUsIF9GOiA3MCwgX2E6IDk3LCBfZjogMTAyIH07XG5mdW5jdGlvbiBhc2NpaVRvQmFzZTE2KGNoYXIpIHtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuXzAgJiYgY2hhciA8PSBhc2NpaXMuXzkpXG4gICAgICAgIHJldHVybiBjaGFyIC0gYXNjaWlzLl8wO1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fQSAmJiBjaGFyIDw9IGFzY2lpcy5fRilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoYXNjaWlzLl9BIC0gMTApO1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fYSAmJiBjaGFyIDw9IGFzY2lpcy5fZilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoYXNjaWlzLl9hIC0gMTApO1xuICAgIHJldHVybjtcbn1cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBobCA9IGhleC5sZW5ndGg7XG4gICAgY29uc3QgYWwgPSBobCAvIDI7XG4gICAgaWYgKGhsICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGhsKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFsKTtcbiAgICBmb3IgKGxldCBhaSA9IDAsIGhpID0gMDsgYWkgPCBhbDsgYWkrKywgaGkgKz0gMikge1xuICAgICAgICBjb25zdCBuMSA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkpKTtcbiAgICAgICAgY29uc3QgbjIgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpICsgMSkpO1xuICAgICAgICBpZiAobjEgPT09IHVuZGVmaW5lZCB8fCBuMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gaGV4W2hpXSArIGhleFtoaSArIDFdO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3Qgbm9uLWhleCBjaGFyYWN0ZXIgXCInICsgY2hhciArICdcIiBhdCBpbmRleCAnICsgaGkpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2FpXSA9IG4xICogMTYgKyBuMjtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLy8gQkU6IEJpZyBFbmRpYW4sIExFOiBMaXR0bGUgRW5kaWFuXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb051bWJlckJFKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoYnl0ZXMpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIHtcbiAgICBhYnl0ZXMoYnl0ZXMpO1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShieXRlcykucmV2ZXJzZSgpKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG4udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KGxlbiAqIDIsICcwJykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvQnl0ZXNMRShuLCBsZW4pIHtcbiAgICByZXR1cm4gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikucmV2ZXJzZSgpO1xufVxuLy8gVW5wYWRkZWQsIHJhcmVseSB1c2VkXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9WYXJCeXRlc0JFKG4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhudW1iZXJUb0hleFVucGFkZGVkKG4pKTtcbn1cbi8qKlxuICogVGFrZXMgaGV4IHN0cmluZyBvciBVaW50OEFycmF5LCBjb252ZXJ0cyB0byBVaW50OEFycmF5LlxuICogVmFsaWRhdGVzIG91dHB1dCBsZW5ndGguXG4gKiBXaWxsIHRocm93IGVycm9yIGZvciBvdGhlciB0eXBlcy5cbiAqIEBwYXJhbSB0aXRsZSBkZXNjcmlwdGl2ZSB0aXRsZSBmb3IgYW4gZXJyb3IgZS5nLiAncHJpdmF0ZSBrZXknXG4gKiBAcGFyYW0gaGV4IGhleCBzdHJpbmcgb3IgVWludDhBcnJheVxuICogQHBhcmFtIGV4cGVjdGVkTGVuZ3RoIG9wdGlvbmFsLCB3aWxsIGNvbXBhcmUgdG8gcmVzdWx0IGFycmF5J3MgbGVuZ3RoXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlQnl0ZXModGl0bGUsIGhleCwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICBsZXQgcmVzO1xuICAgIGlmICh0eXBlb2YgaGV4ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzID0gaGV4VG9CeXRlcyhoZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgdmFsaWQgaGV4IHN0cmluZywgZ290IFwiJHtoZXh9XCIuIENhdXNlOiAke2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNCeXRlcyhoZXgpKSB7XG4gICAgICAgIC8vIFVpbnQ4QXJyYXkuZnJvbSgpIGluc3RlYWQgb2YgaGFzaC5zbGljZSgpIGJlY2F1c2Ugbm9kZS5qcyBCdWZmZXJcbiAgICAgICAgLy8gaXMgaW5zdGFuY2Ugb2YgVWludDhBcnJheSwgYW5kIGl0cyBzbGljZSgpIGNyZWF0ZXMgKiptdXRhYmxlKiogY29weVxuICAgICAgICByZXMgPSBVaW50OEFycmF5LmZyb20oaGV4KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXlgKTtcbiAgICB9XG4gICAgY29uc3QgbGVuID0gcmVzLmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGV4cGVjdGVkTGVuZ3RoID09PSAnbnVtYmVyJyAmJiBsZW4gIT09IGV4cGVjdGVkTGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IGV4cGVjdGVkICR7ZXhwZWN0ZWRMZW5ndGh9IGJ5dGVzLCBnb3QgJHtsZW59YCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICBhYnl0ZXMoYSk7XG4gICAgICAgIHN1bSArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoc3VtKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICByZXMuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIENvbXBhcmVzIDIgdThhLXMgaW4ga2luZGEgY29uc3RhbnQgdGltZVxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsQnl0ZXMoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZGlmZiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBkaWZmIHw9IGFbaV0gXiBiW2ldO1xuICAgIHJldHVybiBkaWZmID09PSAwO1xufVxuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vLyBCaXQgb3BlcmF0aW9uc1xuLyoqXG4gKiBDYWxjdWxhdGVzIGFtb3VudCBvZiBiaXRzIGluIGEgYmlnaW50LlxuICogU2FtZSBhcyBgbi50b1N0cmluZygyKS5sZW5ndGhgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRMZW4obikge1xuICAgIGxldCBsZW47XG4gICAgZm9yIChsZW4gPSAwOyBuID4gXzBuOyBuID4+PSBfMW4sIGxlbiArPSAxKVxuICAgICAgICA7XG4gICAgcmV0dXJuIGxlbjtcbn1cbi8qKlxuICogR2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICogTk9URTogZmlyc3QgYml0IHBvc2l0aW9uIGlzIDAgKHNhbWUgYXMgYXJyYXlzKVxuICogU2FtZSBhcyBgISErQXJyYXkuZnJvbShuLnRvU3RyaW5nKDIpKS5yZXZlcnNlKClbcG9zXWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdEdldChuLCBwb3MpIHtcbiAgICByZXR1cm4gKG4gPj4gQmlnSW50KHBvcykpICYgXzFuO1xufVxuLyoqXG4gKiBTZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRTZXQobiwgcG9zLCB2YWx1ZSkge1xuICAgIHJldHVybiBuIHwgKCh2YWx1ZSA/IF8xbiA6IF8wbikgPDwgQmlnSW50KHBvcykpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgbWFzayBmb3IgTiBiaXRzLiBOb3QgdXNpbmcgKiogb3BlcmF0b3Igd2l0aCBiaWdpbnRzIGJlY2F1c2Ugb2Ygb2xkIGVuZ2luZXMuXG4gKiBTYW1lIGFzIEJpZ0ludChgMGIke0FycmF5KGkpLmZpbGwoJzEnKS5qb2luKCcnKX1gKVxuICovXG5leHBvcnQgY29uc3QgYml0TWFzayA9IChuKSA9PiAoXzJuIDw8IEJpZ0ludChuIC0gMSkpIC0gXzFuO1xuLy8gRFJCR1xuY29uc3QgdThuID0gKGRhdGEpID0+IG5ldyBVaW50OEFycmF5KGRhdGEpOyAvLyBjcmVhdGVzIFVpbnQ4QXJyYXlcbmNvbnN0IHU4ZnIgPSAoYXJyKSA9PiBVaW50OEFycmF5LmZyb20oYXJyKTsgLy8gYW5vdGhlciBzaG9ydGN1dFxuLyoqXG4gKiBNaW5pbWFsIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHdpbGwgY2FsbCBEUkJHIHVudGlsIDJuZCBhcmcgcmV0dXJucyBzb21ldGhpbmcgbWVhbmluZ2Z1bFxuICogQGV4YW1wbGVcbiAqICAgY29uc3QgZHJiZyA9IGNyZWF0ZUhtYWNEUkJHPEtleT4oMzIsIDMyLCBobWFjKTtcbiAqICAgZHJiZyhzZWVkLCBieXRlc1RvS2V5KTsgLy8gYnl0ZXNUb0tleSBtdXN0IHJldHVybiBLZXkgb3IgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIbWFjRHJiZyhoYXNoTGVuLCBxQnl0ZUxlbiwgaG1hY0ZuKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIHFCeXRlTGVuICE9PSAnbnVtYmVyJyB8fCBxQnl0ZUxlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgaG1hY0ZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2htYWNGbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAvLyBTdGVwIEIsIFN0ZXAgQzogc2V0IGhhc2hMZW4gdG8gOCpjZWlsKGhsZW4vOClcbiAgICBsZXQgdiA9IHU4bihoYXNoTGVuKTsgLy8gTWluaW1hbCBub24tZnVsbC1zcGVjIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gICAgbGV0IGsgPSB1OG4oaGFzaExlbik7IC8vIFN0ZXBzIEIgYW5kIEMgb2YgUkZDNjk3OSAzLjI6IHNldCBoYXNoTGVuLCBpbiBvdXIgY2FzZSBhbHdheXMgc2FtZVxuICAgIGxldCBpID0gMDsgLy8gSXRlcmF0aW9ucyBjb3VudGVyLCB3aWxsIHRocm93IHdoZW4gb3ZlciAxMDAwXG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHYuZmlsbCgxKTtcbiAgICAgICAgay5maWxsKDApO1xuICAgICAgICBpID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGggPSAoLi4uYikgPT4gaG1hY0ZuKGssIHYsIC4uLmIpOyAvLyBobWFjKGspKHYsIC4uLnZhbHVlcylcbiAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IHU4bigpKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyByZXNlZWQoKSBmdW5jdGlvbi4gU3RlcHMgRC1HXG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDBdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAwIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBrID0gaCh1OGZyKFsweDAxXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMSB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgfTtcbiAgICBjb25zdCBnZW4gPSAoKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyBnZW5lcmF0ZSgpIGZ1bmN0aW9uXG4gICAgICAgIGlmIChpKysgPj0gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZHJiZzogdHJpZWQgMTAwMCB2YWx1ZXMnKTtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICB3aGlsZSAobGVuIDwgcUJ5dGVMZW4pIHtcbiAgICAgICAgICAgIHYgPSBoKCk7XG4gICAgICAgICAgICBjb25zdCBzbCA9IHYuc2xpY2UoKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgICAgICAgIGxlbiArPSB2Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoLi4ub3V0KTtcbiAgICB9O1xuICAgIGNvbnN0IGdlblVudGlsID0gKHNlZWQsIHByZWQpID0+IHtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmVzZWVkKHNlZWQpOyAvLyBTdGVwcyBELUdcbiAgICAgICAgbGV0IHJlcyA9IHVuZGVmaW5lZDsgLy8gU3RlcCBIOiBncmluZCB1bnRpbCBrIGlzIGluIFsxLi5uLTFdXG4gICAgICAgIHdoaWxlICghKHJlcyA9IHByZWQoZ2VuKCkpKSlcbiAgICAgICAgICAgIHJlc2VlZCgpO1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIGdlblVudGlsO1xufVxuLy8gVmFsaWRhdGluZyBjdXJ2ZXMgYW5kIGZpZWxkc1xuY29uc3QgdmFsaWRhdG9yRm5zID0ge1xuICAgIGJpZ2ludDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcsXG4gICAgZnVuY3Rpb246ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicsXG4gICAgYm9vbGVhbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nLFxuICAgIHN0cmluZzogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycsXG4gICAgc3RyaW5nT3JVaW50OEFycmF5OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCBpc0J5dGVzKHZhbCksXG4gICAgaXNTYWZlSW50ZWdlcjogKHZhbCkgPT4gTnVtYmVyLmlzU2FmZUludGVnZXIodmFsKSxcbiAgICBhcnJheTogKHZhbCkgPT4gQXJyYXkuaXNBcnJheSh2YWwpLFxuICAgIGZpZWxkOiAodmFsLCBvYmplY3QpID0+IG9iamVjdC5GcC5pc1ZhbGlkKHZhbCksXG4gICAgaGFzaDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwub3V0cHV0TGVuKSxcbn07XG4vLyB0eXBlIFJlY29yZDxLIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sLCBUPiA9IHsgW1AgaW4gS106IFQ7IH1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU9iamVjdChvYmplY3QsIHZhbGlkYXRvcnMsIG9wdFZhbGlkYXRvcnMgPSB7fSkge1xuICAgIGNvbnN0IGNoZWNrRmllbGQgPSAoZmllbGROYW1lLCB0eXBlLCBpc09wdGlvbmFsKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoZWNrVmFsID0gdmFsaWRhdG9yRm5zW3R5cGVdO1xuICAgICAgICBpZiAodHlwZW9mIGNoZWNrVmFsICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbGlkYXRvciBcIiR7dHlwZX1cIiwgZXhwZWN0ZWQgZnVuY3Rpb25gKTtcbiAgICAgICAgY29uc3QgdmFsID0gb2JqZWN0W2ZpZWxkTmFtZV07XG4gICAgICAgIGlmIChpc09wdGlvbmFsICYmIHZhbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWNoZWNrVmFsKHZhbCwgb2JqZWN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhcmFtICR7U3RyaW5nKGZpZWxkTmFtZSl9PSR7dmFsfSAoJHt0eXBlb2YgdmFsfSksIGV4cGVjdGVkICR7dHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyh2YWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIGZhbHNlKTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdFZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbi8vIHZhbGlkYXRlIHR5cGUgdGVzdHNcbi8vIGNvbnN0IG86IHsgYTogbnVtYmVyOyBiOiBudW1iZXI7IGM6IG51bWJlciB9ID0geyBhOiAxLCBiOiA1LCBjOiA2IH07XG4vLyBjb25zdCB6MCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ2JpZ2ludCcgfSk7IC8vIE9rIVxuLy8gLy8gU2hvdWxkIGZhaWwgdHlwZS1jaGVja1xuLy8gY29uc3QgejEgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICd0bXAnIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHoyID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejMgPSB2YWxpZGF0ZU9iamVjdChvLCB7IHRlc3Q6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyBjb25zdCB6NCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJpc0J5dGVzIiwiYSIsIlVpbnQ4QXJyYXkiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJhYnl0ZXMiLCJpdGVtIiwiRXJyb3IiLCJoZXhlcyIsIkFycmF5IiwiZnJvbSIsImxlbmd0aCIsIl8iLCJpIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImJ5dGVzVG9IZXgiLCJieXRlcyIsImhleCIsIm51bWJlclRvSGV4VW5wYWRkZWQiLCJudW0iLCJoZXhUb051bWJlciIsImFzY2lpcyIsIl8wIiwiXzkiLCJfQSIsIl9GIiwiX2EiLCJfZiIsImFzY2lpVG9CYXNlMTYiLCJjaGFyIiwiaGV4VG9CeXRlcyIsImhsIiwiYWwiLCJhcnJheSIsImFpIiwiaGkiLCJuMSIsImNoYXJDb2RlQXQiLCJuMiIsInVuZGVmaW5lZCIsImJ5dGVzVG9OdW1iZXJCRSIsImJ5dGVzVG9OdW1iZXJMRSIsInJldmVyc2UiLCJudW1iZXJUb0J5dGVzQkUiLCJuIiwibGVuIiwibnVtYmVyVG9CeXRlc0xFIiwibnVtYmVyVG9WYXJCeXRlc0JFIiwiZW5zdXJlQnl0ZXMiLCJ0aXRsZSIsImV4cGVjdGVkTGVuZ3RoIiwicmVzIiwiZSIsImNvbmNhdEJ5dGVzIiwiYXJyYXlzIiwic3VtIiwicGFkIiwic2V0IiwiZXF1YWxCeXRlcyIsImIiLCJkaWZmIiwidXRmOFRvQnl0ZXMiLCJzdHIiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImJpdExlbiIsImJpdEdldCIsInBvcyIsImJpdFNldCIsInZhbHVlIiwiYml0TWFzayIsInU4biIsImRhdGEiLCJ1OGZyIiwiYXJyIiwiY3JlYXRlSG1hY0RyYmciLCJoYXNoTGVuIiwicUJ5dGVMZW4iLCJobWFjRm4iLCJ2IiwiayIsInJlc2V0IiwiZmlsbCIsImgiLCJyZXNlZWQiLCJzZWVkIiwiZ2VuIiwib3V0Iiwic2wiLCJzbGljZSIsInB1c2giLCJnZW5VbnRpbCIsInByZWQiLCJ2YWxpZGF0b3JGbnMiLCJiaWdpbnQiLCJ2YWwiLCJmdW5jdGlvbiIsImJvb2xlYW4iLCJzdHJpbmciLCJzdHJpbmdPclVpbnQ4QXJyYXkiLCJpc1NhZmVJbnRlZ2VyIiwiTnVtYmVyIiwiaXNBcnJheSIsImZpZWxkIiwib2JqZWN0IiwiRnAiLCJpc1ZhbGlkIiwiaGFzaCIsIm91dHB1dExlbiIsInZhbGlkYXRlT2JqZWN0IiwidmFsaWRhdG9ycyIsIm9wdFZhbGlkYXRvcnMiLCJjaGVja0ZpZWxkIiwiZmllbGROYW1lIiwidHlwZSIsImlzT3B0aW9uYWwiLCJjaGVja1ZhbCIsIlN0cmluZyIsIk9iamVjdCIsImVudHJpZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: () => (/* binding */ DER),\n/* harmony export */   SWUFpSqrtRatio: () => (/* binding */ SWUFpSqrtRatio),\n/* harmony export */   mapToCurveSimpleSWU: () => (/* binding */ mapToCurveSimpleSWU),\n/* harmony export */   weierstrass: () => (/* binding */ weierstrass),\n/* harmony export */   weierstrassPoints: () => (/* binding */ weierstrassPoints)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Short Weierstrass curve. The formula is: y² = x³ + ax + b\n\n\n\n\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        a: \"field\",\n        b: \"field\"\n    }, {\n        allowedPrivateKeyLengths: \"array\",\n        wrapPrivateKey: \"boolean\",\n        isTorsionFree: \"function\",\n        clearCofactor: \"function\",\n        allowInfinityPoint: \"boolean\",\n        fromBytes: \"function\",\n        toBytes: \"function\"\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error(\"Endomorphism can only be defined for Koblitz curves that have a=0\");\n        }\n        if (typeof endo !== \"object\" || typeof endo.beta !== \"bigint\" || typeof endo.splitScalar !== \"function\") {\n            throw new Error(\"Expected endomorphism with beta: bigint and splitScalar: function\");\n        }\n    }\n    return Object.freeze({\n        ...opts\n    });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_1__;\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = \"\"){\n            super(m);\n        }\n    },\n    _parseInt (data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02) throw new E(\"Invalid signature integer tag\");\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len) throw new E(\"Invalid signature integer: wrong length\");\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 128) throw new E(\"Invalid signature integer: negative\");\n        if (res[0] === 0x00 && !(res[1] & 128)) throw new E(\"Invalid signature integer: unnecessary leading zero\");\n        return {\n            d: b2n(res),\n            l: data.subarray(len + 2)\n        }; // d is data, l is left\n    },\n    toSig (hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === \"string\" ? h2b(hex) : hex;\n        _utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes(data);\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30) throw new E(\"Invalid signature tag\");\n        if (data[1] !== l - 2) throw new E(\"Invalid signature: incorrect length\");\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length) throw new E(\"Invalid signature: left bytes after parsing\");\n        return {\n            r,\n            s\n        };\n    },\n    hexFromSig (sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s)=>Number.parseInt(s[0], 16) & 8 ? \"00\" + s : s;\n        const h = (num)=>{\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    }\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes || ((_c, point, _isCompressed)=>{\n        const a = point.toAffine();\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(Uint8Array.from([\n            0x04\n        ]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n    });\n    const fromBytes = CURVE.fromBytes || ((bytes)=>{\n        // const head = bytes[0];\n        const tail = bytes.subarray(1);\n        // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return {\n            x,\n            y\n        };\n    });\n    /**\n     * y² = x³ + ax + b: Short weierstrass curve formula\n     * @returns y²\n     */ function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx))) throw new Error(\"bad generator point: equation left != right\");\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === \"bigint\" && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num)) throw new Error(\"Expected valid bigint: 0 < bigint < curve.n\");\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== \"bigint\") {\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(key)) key = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== \"string\" || !lengths.includes(key.length)) throw new Error(\"Invalid key\");\n            key = key.padStart(nByteLength * 2, \"0\");\n        }\n        let num;\n        try {\n            num = typeof key === \"bigint\" ? key : _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"private key\", key, nByteLength));\n        } catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey) num = _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point)) throw new Error(\"ProjectivePoint expected\");\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */ class Point {\n        constructor(px, py, pz){\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px)) throw new Error(\"x required\");\n            if (py == null || !Fp.isValid(py)) throw new Error(\"y required\");\n            if (pz == null || !Fp.isValid(pz)) throw new Error(\"z required\");\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"invalid affine point\");\n            if (p instanceof Point) throw new Error(\"projective point not allowed\");\n            const is0 = (i)=>Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y)) return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */ static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p)=>p.pz));\n            return points.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */ static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"pointHex\", hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py)) return;\n                throw new Error(\"bad point: ZERO\");\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"bad point: x or y not FE\");\n            const left = Fp.sqr(y); // y²\n            const right = weierstrassEquation(x); // x³ + ax + b\n            if (!Fp.eql(left, right)) throw new Error(\"bad point: equation left != right\");\n            if (!this.isTorsionFree()) throw new Error(\"bad point: not in prime-order subgroup\");\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd) return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */ equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */ negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp)=>{\n                const toInv = Fp.invertBatch(comp.map((p)=>p.pz));\n                return comp.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */ multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n) return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n) return this;\n            const { endo } = CURVE;\n            if (!endo) return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while(k1 > _0n || k2 > _0n){\n                if (k1 & _1n) k1p = k1p.add(d);\n                if (k2 & _1n) k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg) k1p = k1p.negate();\n            if (k2neg) k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */ multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            } else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([\n                point,\n                fake\n            ])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */ multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            )=>a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ∋ (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0) return {\n                x: Fp.ZERO,\n                y: Fp.ZERO\n            };\n            if (!Fp.eql(zz, Fp.ONE)) throw new Error(\"invZ was invalid\");\n            return {\n                x: ax,\n                y: ay\n            };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n) return true; // No subgroups, always torsion-free\n            if (isTorsionFree) return isTorsionFree(Point, this);\n            throw new Error(\"isTorsionFree() has not been declared for the elliptic curve\");\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n) return this; // Fast-path\n            if (clearCofactor) return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        hash: \"hash\",\n        hmac: \"function\",\n        randomBytes: \"function\"\n    }, {\n        bits2int: \"function\",\n        bits2int_modN: \"function\",\n        lowS: \"boolean\"\n    });\n    return Object.freeze({\n        lowS: true,\n        ...opts\n    });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({\n        ...CURVE,\n        toBytes (_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([\n                    point.hasEvenY() ? 0x02 : 0x03\n                ]), x);\n            } else {\n                return cat(Uint8Array.from([\n                    0x04\n                ]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes (bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x)) throw new Error(\"Point is not on curve\");\n                const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n                } catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? \": \" + sqrtError.message : \"\";\n                    throw new Error(\"Point is not on curve\" + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n                return {\n                    x,\n                    y\n                };\n            } else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return {\n                    x,\n                    y\n                };\n            } else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        }\n    });\n    const numToNByteStr = (num)=>_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to)=>_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */ class Signature {\n        constructor(r, s, recovery){\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"compactSignature\", hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"DER\", hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r)) throw new Error(\"r must be 0 < r < CURVE.n\");\n            if (!isWithinCurveOrder(this.s)) throw new Error(\"s must be 0 < s < CURVE.n\");\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"msgHash\", msgHash)); // Truncate hash\n            if (rec == null || ![\n                0,\n                1,\n                2,\n                3\n            ].includes(rec)) throw new Error(\"recovery id invalid\");\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER) throw new Error(\"recovery id 2 or 3 invalid\");\n            const prefix = (rec & 1) === 0 ? \"02\" : \"03\";\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q) throw new Error(\"point at infinify\"); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({\n                r: this.r,\n                s: this.s\n            });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey (privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            } catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */ randomPrivateKey: ()=>{\n            const length = _modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength(CURVE.n);\n            return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */ precompute (windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        }\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */ function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */ function isProbPub(item) {\n        const arr = _utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(item);\n        const str = typeof item === \"string\";\n        const len = (arr || str) && item.length;\n        if (arr) return len === compressedLen || len === uncompressedLen;\n        if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point) return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */ function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA)) throw new Error(\"first arg must be private key\");\n        if (!isProbPub(publicB)) throw new Error(\"second arg must be public key\");\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int || function(bytes) {\n        // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n        // for some cases, since bytes.length * 8 is not actual bitLength.\n        const num = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(bytes); // check for == u8 done here\n        const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n        return delta > 0 ? num >> BigInt(delta) : num;\n    };\n    const bits2int_modN = CURVE.bits2int_modN || function(bytes) {\n        return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */ function int2octets(num) {\n        if (typeof num !== \"bigint\") throw new Error(\"bigint expected\");\n        if (!(_0n <= num && num < ORDER_MASK)) throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if ([\n            \"recovered\",\n            \"canonical\"\n        ].some((k)=>k in opts)) throw new Error(\"sign() legacy options not supported\");\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"msgHash\", msgHash);\n        if (prehash) msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"prehashed msgHash\", hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [\n            int2octets(d),\n            int2octets(h1int)\n        ];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"extraEntropy\", e)); // check for being bytes\n        }\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n) return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n) return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return {\n            seed,\n            k2sig\n        };\n    }\n    const defaultSigOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    const defaultVerOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G × k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */ function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1⋅G - U2⋅P\n     *   mod(R.x, n) == r\n     * ```\n     */ function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"msgHash\", msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"publicKey\", publicKey);\n        if (\"strict\" in opts) throw new Error(\"options.strict was renamed to lowS\");\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === \"string\" || _utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(sg)) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                } catch (derError) {\n                    if (!(derError instanceof DER.Err)) throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            } else if (typeof sg === \"object\" && typeof sg.r === \"bigint\" && typeof sg.s === \"bigint\") {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            } else {\n                throw new Error(\"PARSE\");\n            }\n            P = Point.fromHex(publicKey);\n        } catch (error) {\n            if (error.message === \"PARSE\") throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS()) return false;\n        if (prehash) msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n        if (!R) return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */ function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for(let o = q - _1n; o % _2n === _0n; o /= _2n)l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v)=>{\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for(let i = c1; i > _1n; i--){\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << tv5 - _1n; // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return {\n            isValid: isQR,\n            value: tv3\n        };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v)=>{\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return {\n                isValid: isQR,\n                value: y\n            }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */ function mapToCurveSimpleSWU(Fp, opts) {\n    _modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z)) throw new Error(\"mapToCurveSimpleSWU: invalid opts\");\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd) throw new Error(\"Fp.isOdd is not implemented!\");\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u)=>{\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return {\n            x,\n            y\n        };\n    };\n} //# sourceMappingURL=weierstrass.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSxvRUFBb0UsR0FDcEUsNERBQTREO0FBQ3hCO0FBQ0g7QUFDUTtBQUNRO0FBQ2pELFNBQVNLLGtCQUFrQkMsS0FBSztJQUM1QixNQUFNQyxPQUFPSCx3REFBYUEsQ0FBQ0U7SUFDM0JMLHFEQUFpQixDQUFDTSxNQUFNO1FBQ3BCRSxHQUFHO1FBQ0hDLEdBQUc7SUFDUCxHQUFHO1FBQ0NDLDBCQUEwQjtRQUMxQkMsZ0JBQWdCO1FBQ2hCQyxlQUFlO1FBQ2ZDLGVBQWU7UUFDZkMsb0JBQW9CO1FBQ3BCQyxXQUFXO1FBQ1hDLFNBQVM7SUFDYjtJQUNBLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxFQUFFLEVBQUVWLENBQUMsRUFBRSxHQUFHRjtJQUN4QixJQUFJVyxNQUFNO1FBQ04sSUFBSSxDQUFDQyxHQUFHQyxHQUFHLENBQUNYLEdBQUdVLEdBQUdFLElBQUksR0FBRztZQUNyQixNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSxJQUFJLE9BQU9KLFNBQVMsWUFDaEIsT0FBT0EsS0FBS0ssSUFBSSxLQUFLLFlBQ3JCLE9BQU9MLEtBQUtNLFdBQVcsS0FBSyxZQUFZO1lBQ3hDLE1BQU0sSUFBSUYsTUFBTTtRQUNwQjtJQUNKO0lBQ0EsT0FBT0csT0FBT0MsTUFBTSxDQUFDO1FBQUUsR0FBR25CLElBQUk7SUFBQztBQUNuQztBQUNBLCtCQUErQjtBQUMvQixNQUFNLEVBQUVvQixpQkFBaUJDLEdBQUcsRUFBRUMsWUFBWUMsR0FBRyxFQUFFLEdBQUc3QixzQ0FBRUE7QUFDN0MsTUFBTThCLE1BQU07SUFDZiwyQkFBMkI7SUFDM0JDLEtBQUssTUFBTUMsZUFBZVg7UUFDdEJZLFlBQVlDLElBQUksRUFBRSxDQUFFO1lBQ2hCLEtBQUssQ0FBQ0E7UUFDVjtJQUNKO0lBQ0FDLFdBQVVDLElBQUk7UUFDVixNQUFNLEVB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QUVoTixPQUFPLEVBQUV1TixLQUFLLEVBQUUsR0FBR1gsVUFBVUcsS0FBS2MsTUFBTSxpREFBaUQ7UUFDakc3UCxJQUFJN0QsR0FBR3FFLEdBQUcsQ0FBQ3NPLEtBQUtELElBQUkscUNBQXFDO1FBQ3pEN08sSUFBSTdELEdBQUdxRSxHQUFHLENBQUNSLEdBQUd1UCxRQUFRLG1CQUFtQjtRQUN6Q3hQLElBQUk1RCxHQUFHaVQsSUFBSSxDQUFDclAsR0FBR2lQLEtBQUtoTixVQUFVLHdDQUF3QztRQUN0RWhDLElBQUk3RCxHQUFHaVQsSUFBSSxDQUFDcFAsR0FBR3VQLE9BQU92TixVQUFVLHVDQUF1QztRQUN2RSxNQUFNc04sS0FBS25ULEdBQUdzSCxLQUFLLENBQUNvTCxPQUFPMVMsR0FBR3NILEtBQUssQ0FBQ3pELElBQUksK0JBQStCO1FBQ3ZFQSxJQUFJN0QsR0FBR2lULElBQUksQ0FBQ2pULEdBQUdpSSxHQUFHLENBQUNwRSxJQUFJQSxHQUFHc1AsS0FBSyw0QkFBNEI7UUFDM0R2UCxJQUFJNUQsR0FBRzJULEdBQUcsQ0FBQy9QLEdBQUdtUCxNQUFNLG9CQUFvQjtRQUN4QyxPQUFPO1lBQUVuUDtZQUFHQztRQUFFO0lBQ2xCO0FBQ0osRUFDQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jZmFwcC8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcz9iNThiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFNob3J0IFdlaWVyc3RyYXNzIGN1cnZlLiBUaGUgZm9ybXVsYSBpczogecKyID0geMKzICsgYXggKyBiXG5pbXBvcnQgKiBhcyBtb2QgZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCAqIGFzIHV0IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgZW5zdXJlQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IHdOQUYsIHZhbGlkYXRlQmFzaWMgfSBmcm9tICcuL2N1cnZlLmpzJztcbmZ1bmN0aW9uIHZhbGlkYXRlUG9pbnRPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHZhbGlkYXRlQmFzaWMoY3VydmUpO1xuICAgIHV0LnZhbGlkYXRlT2JqZWN0KG9wdHMsIHtcbiAgICAgICAgYTogJ2ZpZWxkJyxcbiAgICAgICAgYjogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogJ2FycmF5JyxcbiAgICAgICAgd3JhcFByaXZhdGVLZXk6ICdib29sZWFuJyxcbiAgICAgICAgaXNUb3JzaW9uRnJlZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgY2xlYXJDb2ZhY3RvcjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYWxsb3dJbmZpbml0eVBvaW50OiAnYm9vbGVhbicsXG4gICAgICAgIGZyb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgdG9CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IGVuZG8sIEZwLCBhIH0gPSBvcHRzO1xuICAgIGlmIChlbmRvKSB7XG4gICAgICAgIGlmICghRnAuZXFsKGEsIEZwLlpFUk8pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuZG9tb3JwaGlzbSBjYW4gb25seSBiZSBkZWZpbmVkIGZvciBLb2JsaXR6IGN1cnZlcyB0aGF0IGhhdmUgYT0wJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbmRvICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uYmV0YSAhPT0gJ2JpZ2ludCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlbmRvLnNwbGl0U2NhbGFyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGVuZG9tb3JwaGlzbSB3aXRoIGJldGE6IGJpZ2ludCBhbmQgc3BsaXRTY2FsYXI6IGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5vcHRzIH0pO1xufVxuLy8gQVNOLjEgREVSIGVuY29kaW5nIHV0aWxpdGllc1xuY29uc3QgeyBieXRlc1RvTnVtYmVyQkU6IGIybiwgaGV4VG9CeXRlczogaDJiIH0gPSB1dDtcbmV4cG9ydCBjb25zdCBERVIgPSB7XG4gICAgLy8gYXNuLjEgREVSIGVuY29kaW5nIHV0aWxzXG4gICAgRXJyOiBjbGFzcyBERVJFcnIgZXh0ZW5kcyBFcnJvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG0gPSAnJykge1xuICAgICAgICAgICAgc3VwZXIobSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9wYXJzZUludChkYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDIgfHwgZGF0YVswXSAhPT0gMHgwMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyIHRhZycpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhWzFdO1xuICAgICAgICBjb25zdCByZXMgPSBkYXRhLnN1YmFycmF5KDIsIGxlbiArIDIpO1xuICAgICAgICBpZiAoIWxlbiB8fCByZXMubGVuZ3RoICE9PSBsZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogd3JvbmcgbGVuZ3RoJyk7XG4gICAgICAgIC8vIGh0dHBzOi8vY3J5cHRvLnN0YWNrZXhjaGFuZ2UuY29tL2EvNTc3MzQgTGVmdG1vc3QgYml0IG9mIGZpcnN0IGJ5dGUgaXMgJ25lZ2F0aXZlJyBmbGFnLFxuICAgICAgICAvLyBzaW5jZSB3ZSBhbHdheXMgdXNlIHBvc2l0aXZlIGludGVnZXJzIGhlcmUuIEl0IG11c3QgYWx3YXlzIGJlIGVtcHR5OlxuICAgICAgICAvLyAtIGFkZCB6ZXJvIGJ5dGUgaWYgZXhpc3RzXG4gICAgICAgIC8vIC0gaWYgbmV4dCBieXRlIGRvZXNuJ3QgaGF2ZSBhIGZsYWcsIGxlYWRpbmcgemVybyBpcyBub3QgYWxsb3dlZCAobWluaW1hbCBlbmNvZGluZylcbiAgICAgICAgaWYgKHJlc1swXSAmIDBiMTAwMDAwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogbmVnYXRpdmUnKTtcbiAgICAgICAgaWYgKHJlc1swXSA9PT0gMHgwMCAmJiAhKHJlc1sxXSAmIDBiMTAwMDAwMDApKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHVubmVjZXNzYXJ5IGxlYWRpbmcgemVybycpO1xuICAgICAgICByZXR1cm4geyBkOiBiMm4ocmVzKSwgbDogZGF0YS5zdWJhcnJheShsZW4gKyAyKSB9OyAvLyBkIGlzIGRhdGEsIGwgaXMgbGVmdFxuICAgIH0sXG4gICAgdG9TaWcoaGV4KSB7XG4gICAgICAgIC8vIHBhcnNlIERFUiBzaWduYXR1cmVcbiAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgY29uc3QgZGF0YSA9IHR5cGVvZiBoZXggPT09ICdzdHJpbmcnID8gaDJiKGhleCkgOiBoZXg7XG4gICAgICAgIHV0LmFieXRlcyhkYXRhKTtcbiAgICAgICAgbGV0IGwgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKGwgPCAyIHx8IGRhdGFbMF0gIT0gMHgzMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSB0YWcnKTtcbiAgICAgICAgaWYgKGRhdGFbMV0gIT09IGwgLSAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlOiBpbmNvcnJlY3QgbGVuZ3RoJyk7XG4gICAgICAgIGNvbnN0IHsgZDogciwgbDogc0J5dGVzIH0gPSBERVIuX3BhcnNlSW50KGRhdGEuc3ViYXJyYXkoMikpO1xuICAgICAgICBjb25zdCB7IGQ6IHMsIGw6IHJCeXRlc0xlZnQgfSA9IERFUi5fcGFyc2VJbnQoc0J5dGVzKTtcbiAgICAgICAgaWYgKHJCeXRlc0xlZnQubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlOiBsZWZ0IGJ5dGVzIGFmdGVyIHBhcnNpbmcnKTtcbiAgICAgICAgcmV0dXJuIHsgciwgcyB9O1xuICAgIH0sXG4gICAgaGV4RnJvbVNpZyhzaWcpIHtcbiAgICAgICAgLy8gQWRkIGxlYWRpbmcgemVybyBpZiBmaXJzdCBieXRlIGhhcyBuZWdhdGl2ZSBiaXQgZW5hYmxlZC4gTW9yZSBkZXRhaWxzIGluICdfcGFyc2VJbnQnXG4gICAgICAgIGNvbnN0IHNsaWNlID0gKHMpID0+IChOdW1iZXIucGFyc2VJbnQoc1swXSwgMTYpICYgMGIxMDAwID8gJzAwJyArIHMgOiBzKTtcbiAgICAgICAgY29uc3QgaCA9IChudW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgICAgICAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyBgMCR7aGV4fWAgOiBoZXg7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHMgPSBzbGljZShoKHNpZy5zKSk7XG4gICAgICAgIGNvbnN0IHIgPSBzbGljZShoKHNpZy5yKSk7XG4gICAgICAgIGNvbnN0IHNobCA9IHMubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3QgcmhsID0gci5sZW5ndGggLyAyO1xuICAgICAgICBjb25zdCBzbCA9IGgoc2hsKTtcbiAgICAgICAgY29uc3QgcmwgPSBoKHJobCk7XG4gICAgICAgIHJldHVybiBgMzAke2gocmhsICsgc2hsICsgNCl9MDIke3JsfSR7cn0wMiR7c2x9JHtzfWA7XG4gICAgfSxcbn07XG4vLyBCZSBmcmllbmRseSB0byBiYWQgRUNNQVNjcmlwdCBwYXJzZXJzIGJ5IG5vdCB1c2luZyBiaWdpbnQgbGl0ZXJhbHNcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpLCBfNG4gPSBCaWdJbnQoNCk7XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3NQb2ludHMob3B0cykge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVQb2ludE9wdHMob3B0cyk7XG4gICAgY29uc3QgeyBGcCB9ID0gQ1VSVkU7IC8vIEFsbCBjdXJ2ZXMgaGFzIHNhbWUgZmllbGQgLyBncm91cCBsZW5ndGggYXMgZm9yIG5vdywgYnV0IHRoZXkgY2FuIGRpZmZlclxuICAgIGNvbnN0IHRvQnl0ZXMgPSBDVVJWRS50b0J5dGVzIHx8XG4gICAgICAgICgoX2MsIHBvaW50LCBfaXNDb21wcmVzc2VkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIHJldHVybiB1dC5jb25jYXRCeXRlcyhVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgRnAudG9CeXRlcyhhLngpLCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICB9KTtcbiAgICBjb25zdCBmcm9tQnl0ZXMgPSBDVVJWRS5mcm9tQnl0ZXMgfHxcbiAgICAgICAgKChieXRlcykgPT4ge1xuICAgICAgICAgICAgLy8gY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gaWYgKGhlYWQgIT09IDB4MDQpIHRocm93IG5ldyBFcnJvcignT25seSBub24tY29tcHJlc3NlZCBlbmNvZGluZyBpcyBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgfSk7XG4gICAgLyoqXG4gICAgICogecKyID0geMKzICsgYXggKyBiOiBTaG9ydCB3ZWllcnN0cmFzcyBjdXJ2ZSBmb3JtdWxhXG4gICAgICogQHJldHVybnMgecKyXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2VpZXJzdHJhc3NFcXVhdGlvbih4KSB7XG4gICAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IHgyID0gRnAuc3FyKHgpOyAvLyB4ICogeFxuICAgICAgICBjb25zdCB4MyA9IEZwLm11bCh4MiwgeCk7IC8vIHgyICogeFxuICAgICAgICByZXR1cm4gRnAuYWRkKEZwLmFkZCh4MywgRnAubXVsKHgsIGEpKSwgYik7IC8vIHgzICsgYSAqIHggKyBiXG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIHdoZXRoZXIgdGhlIHBhc3NlZCBjdXJ2ZSBwYXJhbXMgYXJlIHZhbGlkLlxuICAgIC8vIFdlIGNoZWNrIGlmIGN1cnZlIGVxdWF0aW9uIHdvcmtzIGZvciBnZW5lcmF0b3IgcG9pbnQuXG4gICAgLy8gYGFzc2VydFZhbGlkaXR5KClgIHdvbid0IHdvcms6IGBpc1RvcnNpb25GcmVlKClgIGlzIG5vdCBhdmFpbGFibGUgYXQgdGhpcyBwb2ludCBpbiBibHMxMi0zODEuXG4gICAgLy8gUHJvamVjdGl2ZVBvaW50IGNsYXNzIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXQuXG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKENVUlZFLkd5KSwgd2VpZXJzdHJhc3NFcXVhdGlvbihDVVJWRS5HeCkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBnZW5lcmF0b3IgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQnKTtcbiAgICAvLyBWYWxpZCBncm91cCBlbGVtZW50cyByZXNpZGUgaW4gcmFuZ2UgMS4ubi0xXG4gICAgZnVuY3Rpb24gaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG51bSA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgbnVtICYmIG51bSA8IENVUlZFLm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydEdFKG51bSkge1xuICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihudW0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB2YWxpZCBiaWdpbnQ6IDAgPCBiaWdpbnQgPCBjdXJ2ZS5uJyk7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlcyBpZiBwcml2IGtleSBpcyB2YWxpZCBhbmQgY29udmVydHMgaXQgdG8gYmlnaW50LlxuICAgIC8vIFN1cHBvcnRzIG9wdGlvbnMgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzIGFuZCB3cmFwUHJpdmF0ZUtleS5cbiAgICBmdW5jdGlvbiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKGtleSkge1xuICAgICAgICBjb25zdCB7IGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogbGVuZ3RocywgbkJ5dGVMZW5ndGgsIHdyYXBQcml2YXRlS2V5LCBuIH0gPSBDVVJWRTtcbiAgICAgICAgaWYgKGxlbmd0aHMgJiYgdHlwZW9mIGtleSAhPT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIGlmICh1dC5pc0J5dGVzKGtleSkpXG4gICAgICAgICAgICAgICAga2V5ID0gdXQuYnl0ZXNUb0hleChrZXkpO1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHRvIGhleCBzdHJpbmcsIHBhZC4gRS5nLiBQNTIxIHdvdWxkIG5vcm0gMTMwLTEzMiBjaGFyIGhleCB0byAxMzItY2hhciBieXRlc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8ICFsZW5ndGhzLmluY2x1ZGVzKGtleS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXknKTtcbiAgICAgICAgICAgIGtleSA9IGtleS5wYWRTdGFydChuQnl0ZUxlbmd0aCAqIDIsICcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG51bTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG51bSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIGtleSA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgICAgICAgICAgPyBrZXlcbiAgICAgICAgICAgICAgICAgICAgOiB1dC5ieXRlc1RvTnVtYmVyQkUoZW5zdXJlQnl0ZXMoJ3ByaXZhdGUga2V5Jywga2V5LCBuQnl0ZUxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcml2YXRlIGtleSBtdXN0IGJlICR7bkJ5dGVMZW5ndGh9IGJ5dGVzLCBoZXggb3IgYmlnaW50LCBub3QgJHt0eXBlb2Yga2V5fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3cmFwUHJpdmF0ZUtleSlcbiAgICAgICAgICAgIG51bSA9IG1vZC5tb2QobnVtLCBuKTsgLy8gZGlzYWJsZWQgYnkgZGVmYXVsdCwgZW5hYmxlZCBmb3IgQkxTXG4gICAgICAgIGFzc2VydEdFKG51bSk7IC8vIG51bSBpbiByYW5nZSBbMS4uTi0xXVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIH1cbiAgICBjb25zdCBwb2ludFByZWNvbXB1dGVzID0gbmV3IE1hcCgpO1xuICAgIGZ1bmN0aW9uIGFzc2VydFByalBvaW50KG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUG9pbnQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9qZWN0aXZlUG9pbnQgZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvamVjdGl2ZSBQb2ludCB3b3JrcyBpbiAzZCAvIHByb2plY3RpdmUgKGhvbW9nZW5lb3VzKSBjb29yZGluYXRlczogKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxuICAgICAqIERlZmF1bHQgUG9pbnQgd29ya3MgaW4gMmQgLyBhZmZpbmUgY29vcmRpbmF0ZXM6ICh4LCB5KVxuICAgICAqIFdlJ3JlIGRvaW5nIGNhbGN1bGF0aW9ucyBpbiBwcm9qZWN0aXZlLCBiZWNhdXNlIGl0cyBvcGVyYXRpb25zIGRvbid0IHJlcXVpcmUgY29zdGx5IGludmVyc2lvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBQb2ludCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHB4LCBweSwgcHopIHtcbiAgICAgICAgICAgIHRoaXMucHggPSBweDtcbiAgICAgICAgICAgIHRoaXMucHkgPSBweTtcbiAgICAgICAgICAgIHRoaXMucHogPSBwejtcbiAgICAgICAgICAgIGlmIChweCA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB4KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ggcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmIChweSA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3kgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmIChweiA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB6KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ogcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEb2VzIG5vdCB2YWxpZGF0ZSBpZiB0aGUgcG9pbnQgaXMgb24tY3VydmUuXG4gICAgICAgIC8vIFVzZSBmcm9tSGV4IGluc3RlYWQsIG9yIGNhbGwgYXNzZXJ0VmFsaWRpdHkoKSBsYXRlci5cbiAgICAgICAgc3RhdGljIGZyb21BZmZpbmUocCkge1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwIHx8IHt9O1xuICAgICAgICAgICAgaWYgKCFwIHx8ICFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhZmZpbmUgcG9pbnQnKTtcbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9qZWN0aXZlIHBvaW50IG5vdCBhbGxvd2VkJyk7XG4gICAgICAgICAgICBjb25zdCBpczAgPSAoaSkgPT4gRnAuZXFsKGksIEZwLlpFUk8pO1xuICAgICAgICAgICAgLy8gZnJvbUFmZmluZSh4OjAsIHk6MCkgd291bGQgcHJvZHVjZSAoeDowLCB5OjAsIHo6MSksIGJ1dCB3ZSBuZWVkICh4OjAsIHk6MSwgejowKVxuICAgICAgICAgICAgaWYgKGlzMCh4KSAmJiBpczAoeSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50LlpFUk87XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHksIEZwLk9ORSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLng7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLnk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRha2VzIGEgYnVuY2ggb2YgUHJvamVjdGl2ZSBQb2ludHMgYnV0IGV4ZWN1dGVzIG9ubHkgb25lXG4gICAgICAgICAqIGludmVyc2lvbiBvbiBhbGwgb2YgdGhlbS4gSW52ZXJzaW9uIGlzIHZlcnkgc2xvdyBvcGVyYXRpb24sXG4gICAgICAgICAqIHNvIHRoaXMgaW1wcm92ZXMgcGVyZm9ybWFuY2UgbWFzc2l2ZWx5LlxuICAgICAgICAgKiBPcHRpbWl6YXRpb246IGNvbnZlcnRzIGEgbGlzdCBvZiBwcm9qZWN0aXZlIHBvaW50cyB0byBhIGxpc3Qgb2YgaWRlbnRpY2FsIHBvaW50cyB3aXRoIFo9MS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBub3JtYWxpemVaKHBvaW50cykge1xuICAgICAgICAgICAgY29uc3QgdG9JbnYgPSBGcC5pbnZlcnRCYXRjaChwb2ludHMubWFwKChwKSA9PiBwLnB6KSk7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzLm1hcCgocCwgaSkgPT4gcC50b0FmZmluZSh0b0ludltpXSkpLm1hcChQb2ludC5mcm9tQWZmaW5lKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgaGFzaCBzdHJpbmcgb3IgVWludDhBcnJheSB0byBQb2ludC5cbiAgICAgICAgICogQHBhcmFtIGhleCBzaG9ydC9sb25nIEVDRFNBIGhleFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShmcm9tQnl0ZXMoZW5zdXJlQnl0ZXMoJ3BvaW50SGV4JywgaGV4KSkpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlwbGllcyBnZW5lcmF0b3IgcG9pbnQgYnkgcHJpdmF0ZUtleS5cbiAgICAgICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5CQVNFLm11bHRpcGx5KG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiUHJpdmF0ZSBtZXRob2RcIiwgZG9uJ3QgdXNlIGl0IGRpcmVjdGx5XG4gICAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX1dJTkRPV19TSVpFID0gd2luZG93U2l6ZTtcbiAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuZGVsZXRlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEEgcG9pbnQgb24gY3VydmUgaXMgdmFsaWQgaWYgaXQgY29uZm9ybXMgdG8gZXF1YXRpb24uXG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXMwKCkpIHtcbiAgICAgICAgICAgICAgICAvLyAoMCwgMSwgMCkgYWthIFpFUk8gaXMgaW52YWxpZCBpbiBtb3N0IGNvbnRleHRzLlxuICAgICAgICAgICAgICAgIC8vIEluIEJMUywgWkVSTyBjYW4gYmUgc2VyaWFsaXplZCwgc28gd2UgYWxsb3cgaXQuXG4gICAgICAgICAgICAgICAgLy8gKDAsIDAsIDApIGlzIHdyb25nIHJlcHJlc2VudGF0aW9uIG9mIFpFUk8gYW5kIGlzIGFsd2F5cyBpbnZhbGlkLlxuICAgICAgICAgICAgICAgIGlmIChDVVJWRS5hbGxvd0luZmluaXR5UG9pbnQgJiYgIUZwLmlzMCh0aGlzLnB5KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBaRVJPJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb21lIDNyZC1wYXJ0eSB0ZXN0IHZlY3RvcnMgcmVxdWlyZSBkaWZmZXJlbnQgd29yZGluZyBiZXR3ZWVuIGhlcmUgJiBgZnJvbUNvbXByZXNzZWRIZXhgXG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHgsIHkgYXJlIHZhbGlkIGZpZWxkIGVsZW1lbnRzXG4gICAgICAgICAgICBpZiAoIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IHggb3IgeSBub3QgRkUnKTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBGcC5zcXIoeSk7IC8vIHnCslxuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB4wrMgKyBheCArIGJcbiAgICAgICAgICAgIGlmICghRnAuZXFsKGxlZnQsIHJpZ2h0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVG9yc2lvbkZyZWUoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogbm90IGluIHByaW1lLW9yZGVyIHN1Ymdyb3VwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaGFzRXZlblkoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGlmIChGcC5pc09kZClcbiAgICAgICAgICAgICAgICByZXR1cm4gIUZwLmlzT2RkKHkpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBzdXBwb3J0IGlzT2RkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgY29uc3QgVTEgPSBGcC5lcWwoRnAubXVsKFgxLCBaMiksIEZwLm11bChYMiwgWjEpKTtcbiAgICAgICAgICAgIGNvbnN0IFUyID0gRnAuZXFsKEZwLm11bChZMSwgWjIpLCBGcC5tdWwoWTIsIFoxKSk7XG4gICAgICAgICAgICByZXR1cm4gVTEgJiYgVTI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsaXBzIHBvaW50IHRvIG9uZSBjb3JyZXNwb25kaW5nIHRvICh4LCAteSkgaW4gQWZmaW5lIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgbmVnYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnB4LCBGcC5uZWcodGhpcy5weSksIHRoaXMucHopO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBkb3VibGluZyBmb3JtdWxhLlxuICAgICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDNcbiAgICAgICAgLy8gQ29zdDogOE0gKyAzUyArIDMqYSArIDIqYjMgKyAxNWFkZC5cbiAgICAgICAgZG91YmxlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKGIsIF8zbik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgxKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkxKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAubXVsKFgxLCBZMSk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgdDMpOyAvLyBzdGVwIDVcbiAgICAgICAgICAgIFozID0gRnAubXVsKFgxLCBaMSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoYjMsIHQyKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFgzLCBZMyk7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZCh0MSwgWTMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFkzKTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChiMywgWjMpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MCwgdDIpO1xuICAgICAgICAgICAgdDMgPSBGcC5tdWwoYSwgdDMpO1xuICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjBcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKFozLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDAsIHQzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChZMSwgWjEpOyAvLyBzdGVwIDI1XG4gICAgICAgICAgICB0MiA9IEZwLmFkZCh0MiwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDIsIHQzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bCh0MiwgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGFkZGl0aW9uIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gMVxuICAgICAgICAvLyBDb3N0OiAxMk0gKyAwUyArIDMqYSArIDMqYjMgKyAyM2FkZC5cbiAgICAgICAgYWRkKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgYSA9IENVUlZFLmE7XG4gICAgICAgICAgICBjb25zdCBiMyA9IEZwLm11bChDVVJWRS5iLCBfM24pO1xuICAgICAgICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMik7IC8vIHN0ZXAgMVxuICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMik7XG4gICAgICAgICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoyKTtcbiAgICAgICAgICAgIGxldCB0MyA9IEZwLmFkZChYMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQ0ID0gRnAuYWRkKFgyLCBZMik7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgdDMgPSBGcC5tdWwodDMsIHQ0KTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQwLCB0MSk7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQoWDEsIFoxKTtcbiAgICAgICAgICAgIGxldCB0NSA9IEZwLmFkZChYMiwgWjIpOyAvLyBzdGVwIDEwXG4gICAgICAgICAgICB0NCA9IEZwLm11bCh0NCwgdDUpO1xuICAgICAgICAgICAgdDUgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuc3ViKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZChZMSwgWjEpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQoWTIsIFoyKTsgLy8gc3RlcCAxNVxuICAgICAgICAgICAgdDUgPSBGcC5tdWwodDUsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICAgICAgICB0NSA9IEZwLnN1Yih0NSwgWDMpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwoYSwgdDQpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYjMsIHQyKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWDMsIFozKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZCh0MSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFozKTtcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQxLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLm11bChiMywgdDQpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQyID0gRnAuc3ViKHQwLCB0Mik7IC8vIHN0ZXAgMzBcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQ0LCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MSwgdDQpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQ1LCB0NCk7IC8vIHN0ZXAgMzVcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDMsIHQxKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQ1LCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgdDApOyAvLyBzdGVwIDQwXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlzMCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhQb2ludC5aRVJPKTtcbiAgICAgICAgfVxuICAgICAgICB3TkFGKG4pIHtcbiAgICAgICAgICAgIHJldHVybiB3bmFmLndOQUZDYWNoZWQodGhpcywgcG9pbnRQcmVjb21wdXRlcywgbiwgKGNvbXApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKGNvbXAubWFwKChwKSA9PiBwLnB6KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXAubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vbi1jb25zdGFudC10aW1lIG11bHRpcGxpY2F0aW9uLiBVc2VzIGRvdWJsZS1hbmQtYWRkIGFsZ29yaXRobS5cbiAgICAgICAgICogSXQncyBmYXN0ZXIsIGJ1dCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4geW91IGRvbid0IGNhcmUgYWJvdXRcbiAgICAgICAgICogYW4gZXhwb3NlZCBwcml2YXRlIGtleSBlLmcuIHNpZyB2ZXJpZmljYXRpb24sIHdoaWNoIHdvcmtzIG92ZXIgKnB1YmxpYyoga2V5cy5cbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5VW5zYWZlKG4pIHtcbiAgICAgICAgICAgIGNvbnN0IEkgPSBQb2ludC5aRVJPO1xuICAgICAgICAgICAgaWYgKG4gPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm4gSTtcbiAgICAgICAgICAgIGFzc2VydEdFKG4pOyAvLyBXaWxsIHRocm93IG9uIDBcbiAgICAgICAgICAgIGlmIChuID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IGVuZG8gfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKCFlbmRvKVxuICAgICAgICAgICAgICAgIHJldHVybiB3bmFmLnVuc2FmZUxhZGRlcih0aGlzLCBuKTtcbiAgICAgICAgICAgIC8vIEFwcGx5IGVuZG9tb3JwaGlzbVxuICAgICAgICAgICAgbGV0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgICAgICBsZXQgazFwID0gSTtcbiAgICAgICAgICAgIGxldCBrMnAgPSBJO1xuICAgICAgICAgICAgbGV0IGQgPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKGsxID4gXzBuIHx8IGsyID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGsxICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMXAgPSBrMXAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGlmIChrMiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgazJwID0gazJwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBrMSA+Pj0gXzFuO1xuICAgICAgICAgICAgICAgIGsyID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazFwID0gazFwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsycCA9IGsycC5uZWdhdGUoKTtcbiAgICAgICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLnB4LCBlbmRvLmJldGEpLCBrMnAucHksIGsycC5weik7XG4gICAgICAgICAgICByZXR1cm4gazFwLmFkZChrMnApO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdGFudCB0aW1lIG11bHRpcGxpY2F0aW9uLlxuICAgICAgICAgKiBVc2VzIHdOQUYgbWV0aG9kLiBXaW5kb3dlZCBtZXRob2QgbWF5IGJlIDEwJSBmYXN0ZXIsXG4gICAgICAgICAqIGJ1dCB0YWtlcyAyeCBsb25nZXIgdG8gZ2VuZXJhdGUgYW5kIGNvbnN1bWVzIDJ4IG1lbW9yeS5cbiAgICAgICAgICogVXNlcyBwcmVjb21wdXRlcyB3aGVuIGF2YWlsYWJsZS5cbiAgICAgICAgICogVXNlcyBlbmRvbW9ycGhpc20gZm9yIEtvYmxpdHogY3VydmVzLlxuICAgICAgICAgKiBAcGFyYW0gc2NhbGFyIGJ5IHdoaWNoIHRoZSBwb2ludCB3b3VsZCBiZSBtdWx0aXBsaWVkXG4gICAgICAgICAqIEByZXR1cm5zIE5ldyBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHkoc2NhbGFyKSB7XG4gICAgICAgICAgICBhc3NlcnRHRShzY2FsYXIpO1xuICAgICAgICAgICAgbGV0IG4gPSBzY2FsYXI7XG4gICAgICAgICAgICBsZXQgcG9pbnQsIGZha2U7IC8vIEZha2UgcG9pbnQgaXMgdXNlZCB0byBjb25zdC10aW1lIG11bHRcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoZW5kbykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazFwLCBmOiBmMXAgfSA9IHRoaXMud05BRihrMSk7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazJwLCBmOiBmMnAgfSA9IHRoaXMud05BRihrMik7XG4gICAgICAgICAgICAgICAgazFwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazFuZWcsIGsxcCk7XG4gICAgICAgICAgICAgICAgazJwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazJuZWcsIGsycCk7XG4gICAgICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IGsxcC5hZGQoazJwKTtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjFwLmFkZChmMnApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSB0aGlzLndOQUYobik7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBwO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIGB6YCBmb3IgYm90aCBwb2ludHMsIGJ1dCByZXR1cm4gb25seSByZWFsIG9uZVxuICAgICAgICAgICAgcmV0dXJuIFBvaW50Lm5vcm1hbGl6ZVooW3BvaW50LCBmYWtlXSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVmZmljaWVudGx5IGNhbGN1bGF0ZSBgYVAgKyBiUWAuIFVuc2FmZSwgY2FuIGV4cG9zZSBwcml2YXRlIGtleSwgaWYgdXNlZCBpbmNvcnJlY3RseS5cbiAgICAgICAgICogTm90IHVzaW5nIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiBwcmVjb21wdXRhdGlvbiB0YWJsZXMgYXJlIGZhc3Rlci5cbiAgICAgICAgICogVGhlIHRyaWNrIGNvdWxkIGJlIHVzZWZ1bCBpZiBib3RoIFAgYW5kIFEgYXJlIG5vdCBHIChub3QgaW4gb3VyIGNhc2UpLlxuICAgICAgICAgKiBAcmV0dXJucyBub24temVybyBhZmZpbmUgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpIHtcbiAgICAgICAgICAgIGNvbnN0IEcgPSBQb2ludC5CQVNFOyAvLyBObyBTdHJhdXNzLVNoYW1pciB0cmljazogd2UgaGF2ZSAxMCUgZmFzdGVyIEcgcHJlY29tcHV0ZXNcbiAgICAgICAgICAgIGNvbnN0IG11bCA9IChQLCBhIC8vIFNlbGVjdCBmYXN0ZXIgbXVsdGlwbHkoKSBtZXRob2RcbiAgICAgICAgICAgICkgPT4gKGEgPT09IF8wbiB8fCBhID09PSBfMW4gfHwgIVAuZXF1YWxzKEcpID8gUC5tdWx0aXBseVVuc2FmZShhKSA6IFAubXVsdGlwbHkoYSkpO1xuICAgICAgICAgICAgY29uc3Qgc3VtID0gbXVsKHRoaXMsIGEpLmFkZChtdWwoUSwgYikpO1xuICAgICAgICAgICAgcmV0dXJuIHN1bS5pczAoKSA/IHVuZGVmaW5lZCA6IHN1bTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0cyBQcm9qZWN0aXZlIHBvaW50IHRvIGFmZmluZSAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgICAgIC8vIENhbiBhY2NlcHQgcHJlY29tcHV0ZWQgWl4tMSAtIGZvciBleGFtcGxlLCBmcm9tIGludmVydEJhdGNoLlxuICAgICAgICAvLyAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG4gICAgICAgIHRvQWZmaW5lKGl6KSB7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiB4LCBweTogeSwgcHo6IHogfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBpczAgPSB0aGlzLmlzMCgpO1xuICAgICAgICAgICAgLy8gSWYgaW52WiB3YXMgMCwgd2UgcmV0dXJuIHplcm8gcG9pbnQuIEhvd2V2ZXIgd2Ugc3RpbGwgd2FudCB0byBleGVjdXRlXG4gICAgICAgICAgICAvLyBhbGwgb3BlcmF0aW9ucywgc28gd2UgcmVwbGFjZSBpbnZaIHdpdGggYSByYW5kb20gbnVtYmVyLCAxLlxuICAgICAgICAgICAgaWYgKGl6ID09IG51bGwpXG4gICAgICAgICAgICAgICAgaXogPSBpczAgPyBGcC5PTkUgOiBGcC5pbnYoeik7XG4gICAgICAgICAgICBjb25zdCBheCA9IEZwLm11bCh4LCBpeik7XG4gICAgICAgICAgICBjb25zdCBheSA9IEZwLm11bCh5LCBpeik7XG4gICAgICAgICAgICBjb25zdCB6eiA9IEZwLm11bCh6LCBpeik7XG4gICAgICAgICAgICBpZiAoaXMwKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IEZwLlpFUk8sIHk6IEZwLlpFUk8gfTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKHp6LCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogYXgsIHk6IGF5IH07XG4gICAgICAgIH1cbiAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGlzVG9yc2lvbkZyZWUgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIE5vIHN1Ymdyb3VwcywgYWx3YXlzIHRvcnNpb24tZnJlZVxuICAgICAgICAgICAgaWYgKGlzVG9yc2lvbkZyZWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVG9yc2lvbkZyZWUoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpc1RvcnNpb25GcmVlKCkgaGFzIG5vdCBiZWVuIGRlY2xhcmVkIGZvciB0aGUgZWxsaXB0aWMgY3VydmUnKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckNvZmFjdG9yKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgY2xlYXJDb2ZhY3RvciB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gRmFzdC1wYXRoXG4gICAgICAgICAgICBpZiAoY2xlYXJDb2ZhY3RvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xlYXJDb2ZhY3RvcihQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShDVVJWRS5oKTtcbiAgICAgICAgfVxuICAgICAgICB0b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiB0b0J5dGVzKFBvaW50LCB0aGlzLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRvSGV4KGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5ieXRlc1RvSGV4KHRoaXMudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQb2ludC5CQVNFID0gbmV3IFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgRnAuT05FKTtcbiAgICBQb2ludC5aRVJPID0gbmV3IFBvaW50KEZwLlpFUk8sIEZwLk9ORSwgRnAuWkVSTyk7XG4gICAgY29uc3QgX2JpdHMgPSBDVVJWRS5uQml0TGVuZ3RoO1xuICAgIGNvbnN0IHduYWYgPSB3TkFGKFBvaW50LCBDVVJWRS5lbmRvID8gTWF0aC5jZWlsKF9iaXRzIC8gMikgOiBfYml0cyk7XG4gICAgLy8gVmFsaWRhdGUgaWYgZ2VuZXJhdG9yIHBvaW50IGlzIG9uIGN1cnZlXG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXG4gICAgICAgIHdlaWVyc3RyYXNzRXF1YXRpb24sXG4gICAgICAgIGlzV2l0aGluQ3VydmVPcmRlcixcbiAgICB9O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHZhbGlkYXRlQmFzaWMoY3VydmUpO1xuICAgIHV0LnZhbGlkYXRlT2JqZWN0KG9wdHMsIHtcbiAgICAgICAgaGFzaDogJ2hhc2gnLFxuICAgICAgICBobWFjOiAnZnVuY3Rpb24nLFxuICAgICAgICByYW5kb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9LCB7XG4gICAgICAgIGJpdHMyaW50OiAnZnVuY3Rpb24nLFxuICAgICAgICBiaXRzMmludF9tb2ROOiAnZnVuY3Rpb24nLFxuICAgICAgICBsb3dTOiAnYm9vbGVhbicsXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBsb3dTOiB0cnVlLCAuLi5vcHRzIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzKGN1cnZlRGVmKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZU9wdHMoY3VydmVEZWYpO1xuICAgIGNvbnN0IHsgRnAsIG46IENVUlZFX09SREVSIH0gPSBDVVJWRTtcbiAgICBjb25zdCBjb21wcmVzc2VkTGVuID0gRnAuQllURVMgKyAxOyAvLyBlLmcuIDMzIGZvciAzMlxuICAgIGNvbnN0IHVuY29tcHJlc3NlZExlbiA9IDIgKiBGcC5CWVRFUyArIDE7IC8vIGUuZy4gNjUgZm9yIDMyXG4gICAgZnVuY3Rpb24gaXNWYWxpZEZpZWxkRWxlbWVudChudW0pIHtcbiAgICAgICAgcmV0dXJuIF8wbiA8IG51bSAmJiBudW0gPCBGcC5PUkRFUjsgLy8gMCBpcyBiYW5uZWQgc2luY2UgaXQncyBub3QgaW52ZXJ0aWJsZSBGRVxuICAgIH1cbiAgICBmdW5jdGlvbiBtb2ROKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5tb2QoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZOKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5pbnZlcnQoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBjb25zdCB7IFByb2plY3RpdmVQb2ludDogUG9pbnQsIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsIHdlaWVyc3RyYXNzRXF1YXRpb24sIGlzV2l0aGluQ3VydmVPcmRlciwgfSA9IHdlaWVyc3RyYXNzUG9pbnRzKHtcbiAgICAgICAgLi4uQ1VSVkUsXG4gICAgICAgIHRvQnl0ZXMoX2MsIHBvaW50LCBpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLnRvQnl0ZXMoYS54KTtcbiAgICAgICAgICAgIGNvbnN0IGNhdCA9IHV0LmNvbmNhdEJ5dGVzO1xuICAgICAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFtwb2ludC5oYXNFdmVuWSgpID8gMHgwMiA6IDB4MDNdKSwgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCB4LCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKSBpcyBkb25lIGluc2lkZSBvZiBmcm9tSGV4XG4gICAgICAgICAgICBpZiAobGVuID09PSBjb21wcmVzc2VkTGVuICYmIChoZWFkID09PSAweDAyIHx8IGhlYWQgPT09IDB4MDMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHV0LmJ5dGVzVG9OdW1iZXJCRSh0YWlsKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRGaWVsZEVsZW1lbnQoeCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQgaXMgbm90IG9uIGN1cnZlJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeTIgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB5wrIgPSB4wrMgKyBheCArIGJcbiAgICAgICAgICAgICAgICBsZXQgeTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB5ID0gRnAuc3FydCh5Mik7IC8vIHkgPSB5wrIgXiAocCsxKS80XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChzcXJ0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VmZml4ID0gc3FydEVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyAnOiAnICsgc3FydEVycm9yLm1lc3NhZ2UgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3Qgb24gY3VydmUnICsgc3VmZml4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXNZT2RkID0gKHkgJiBfMW4pID09PSBfMW47XG4gICAgICAgICAgICAgICAgLy8gRUNEU0FcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hlYWRPZGQgPSAoaGVhZCAmIDEpID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChpc0hlYWRPZGQgIT09IGlzWU9kZClcbiAgICAgICAgICAgICAgICAgICAgeSA9IEZwLm5lZyh5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gPT09IHVuY29tcHJlc3NlZExlbiAmJiBoZWFkID09PSAweDA0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvaW50IG9mIGxlbmd0aCAke2xlbn0gd2FzIGludmFsaWQuIEV4cGVjdGVkICR7Y29tcHJlc3NlZExlbn0gY29tcHJlc3NlZCBieXRlcyBvciAke3VuY29tcHJlc3NlZExlbn0gdW5jb21wcmVzc2VkIGJ5dGVzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgbnVtVG9OQnl0ZVN0ciA9IChudW0pID0+IHV0LmJ5dGVzVG9IZXgodXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpKTtcbiAgICBmdW5jdGlvbiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIobnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IEhBTEYgPSBDVVJWRV9PUkRFUiA+PiBfMW47XG4gICAgICAgIHJldHVybiBudW1iZXIgPiBIQUxGO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVTKHMpIHtcbiAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSA/IG1vZE4oLXMpIDogcztcbiAgICB9XG4gICAgLy8gc2xpY2UgYnl0ZXMgbnVtXG4gICAgY29uc3Qgc2xjTnVtID0gKGIsIGZyb20sIHRvKSA9PiB1dC5ieXRlc1RvTnVtYmVyQkUoYi5zbGljZShmcm9tLCB0bykpO1xuICAgIC8qKlxuICAgICAqIEVDRFNBIHNpZ25hdHVyZSB3aXRoIGl0cyAociwgcykgcHJvcGVydGllcy4gU3VwcG9ydHMgREVSICYgY29tcGFjdCByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG4gICAgY2xhc3MgU2lnbmF0dXJlIHtcbiAgICAgICAgY29uc3RydWN0b3IociwgcywgcmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgICAgICB0aGlzLnMgPSBzO1xuICAgICAgICAgICAgdGhpcy5yZWNvdmVyeSA9IHJlY292ZXJ5O1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhaXIgKGJ5dGVzIG9mIHIsIGJ5dGVzIG9mIHMpXG4gICAgICAgIHN0YXRpYyBmcm9tQ29tcGFjdChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBDVVJWRS5uQnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGhleCA9IGVuc3VyZUJ5dGVzKCdjb21wYWN0U2lnbmF0dXJlJywgaGV4LCBsICogMik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShzbGNOdW0oaGV4LCAwLCBsKSwgc2xjTnVtKGhleCwgbCwgMiAqIGwpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBERVIgZW5jb2RlZCBFQ0RTQSBzaWduYXR1cmVcbiAgICAgICAgLy8gaHR0cHM6Ly9iaXRjb2luLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy81NzY0NC93aGF0LWFyZS10aGUtcGFydHMtb2YtYS1iaXRjb2luLXRyYW5zYWN0aW9uLWlucHV0LXNjcmlwdFxuICAgICAgICBzdGF0aWMgZnJvbURFUihoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gREVSLnRvU2lnKGVuc3VyZUJ5dGVzKCdERVInLCBoZXgpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgLy8gY2FuIHVzZSBhc3NlcnRHRSBoZXJlXG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcih0aGlzLnIpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignciBtdXN0IGJlIDAgPCByIDwgQ1VSVkUubicpO1xuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIodGhpcy5zKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3MgbXVzdCBiZSAwIDwgcyA8IENVUlZFLm4nKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRSZWNvdmVyeUJpdChyZWNvdmVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUodGhpcy5yLCB0aGlzLnMsIHJlY292ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcywgcmVjb3Zlcnk6IHJlYyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCkpOyAvLyBUcnVuY2F0ZSBoYXNoXG4gICAgICAgICAgICBpZiAocmVjID09IG51bGwgfHwgIVswLCAxLCAyLCAzXS5pbmNsdWRlcyhyZWMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcmFkaiA9IHJlYyA9PT0gMiB8fCByZWMgPT09IDMgPyByICsgQ1VSVkUubiA6IHI7XG4gICAgICAgICAgICBpZiAocmFkaiA+PSBGcC5PUkRFUilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIDIgb3IgMyBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXggPSAocmVjICYgMSkgPT09IDAgPyAnMDInIDogJzAzJztcbiAgICAgICAgICAgIGNvbnN0IFIgPSBQb2ludC5mcm9tSGV4KHByZWZpeCArIG51bVRvTkJ5dGVTdHIocmFkaikpO1xuICAgICAgICAgICAgY29uc3QgaXIgPSBpbnZOKHJhZGopOyAvLyByXi0xXG4gICAgICAgICAgICBjb25zdCB1MSA9IG1vZE4oLWggKiBpcik7IC8vIC1ocl4tMVxuICAgICAgICAgICAgY29uc3QgdTIgPSBtb2ROKHMgKiBpcik7IC8vIHNyXi0xXG4gICAgICAgICAgICBjb25zdCBRID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShSLCB1MSwgdTIpOyAvLyAoc3JeLTEpUi0oaHJeLTEpRyA9IC0oaHJeLTEpRyArIChzcl4tMSlcbiAgICAgICAgICAgIGlmICghUSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvaW50IGF0IGluZmluaWZ5Jyk7IC8vIHVuc2FmZSBpcyBmaW5lOiBubyBwcml2IGRhdGEgbGVha2VkXG4gICAgICAgICAgICBRLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaWduYXR1cmVzIHNob3VsZCBiZSBsb3ctcywgdG8gcHJldmVudCBtYWxsZWFiaWxpdHkuXG4gICAgICAgIGhhc0hpZ2hTKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgICAgIG5vcm1hbGl6ZVMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNIaWdoUygpID8gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIG1vZE4oLXRoaXMucyksIHRoaXMucmVjb3ZlcnkpIDogdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBERVItZW5jb2RlZFxuICAgICAgICB0b0RFUlJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0RFUkhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0RFUkhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBERVIuaGV4RnJvbVNpZyh7IHI6IHRoaXMuciwgczogdGhpcy5zIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhZGRlZCBieXRlcyBvZiByLCB0aGVuIHBhZGRlZCBieXRlcyBvZiBzXG4gICAgICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0NvbXBhY3RIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9Db21wYWN0SGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bVRvTkJ5dGVTdHIodGhpcy5yKSArIG51bVRvTkJ5dGVTdHIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1dGlscyA9IHtcbiAgICAgICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZXMgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHByaXZhdGUga2V5IGZyb20gcmFuZG9tIG9mIHNpemVcbiAgICAgICAgICogKGdyb3VwTGVuICsgY2VpbChncm91cExlbiAvIDIpKSB3aXRoIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gICAgICAgICAqL1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBtb2QuZ2V0TWluSGFzaExlbmd0aChDVVJWRS5uKTtcbiAgICAgICAgICAgIHJldHVybiBtb2QubWFwSGFzaFRvRmllbGQoQ1VSVkUucmFuZG9tQnl0ZXMobGVuZ3RoKSwgQ1VSVkUubik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIHByZWNvbXB1dGUgdGFibGUgZm9yIGFuIGFyYml0cmFyeSBFQyBwb2ludC4gTWFrZXMgcG9pbnQgXCJjYWNoZWRcIi5cbiAgICAgICAgICogQWxsb3dzIHRvIG1hc3NpdmVseSBzcGVlZC11cCBgcG9pbnQubXVsdGlwbHkoc2NhbGFyKWAuXG4gICAgICAgICAqIEByZXR1cm5zIGNhY2hlZCBwb2ludFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCBmYXN0ID0gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuZnJvbUhleChzb21lb25lc1B1YktleSkpO1xuICAgICAgICAgKiBmYXN0Lm11bHRpcGx5KHByaXZLZXkpOyAvLyBtdWNoIGZhc3RlciBFQ0RIIG5vd1xuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQgPSBQb2ludC5CQVNFKSB7XG4gICAgICAgICAgICBwb2ludC5fc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIHBvaW50Lm11bHRpcGx5KEJpZ0ludCgzKSk7IC8vIDMgaXMgYXJiaXRyYXJ5LCBqdXN0IG5lZWQgYW55IG51bWJlciBoZXJlXG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5LiBDaGVja3MgZm9yIHZhbGlkaXR5IG9mIHRoZSBwcml2YXRlIGtleS5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgUHVibGljIGtleSwgZnVsbCB3aGVuIGlzQ29tcHJlc3NlZD1mYWxzZTsgc2hvcnQgd2hlbiBpc0NvbXByZXNzZWQ9dHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2YXRlS2V5LCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1aWNrIGFuZCBkaXJ0eSBjaGVjayBmb3IgaXRlbSBiZWluZyBwdWJsaWMga2V5LiBEb2VzIG5vdCB2YWxpZGF0ZSBoZXgsIG9yIGJlaW5nIG9uLWN1cnZlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvYlB1YihpdGVtKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IHV0LmlzQnl0ZXMoaXRlbSk7XG4gICAgICAgIGNvbnN0IHN0ciA9IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJztcbiAgICAgICAgY29uc3QgbGVuID0gKGFyciB8fCBzdHIpICYmIGl0ZW0ubGVuZ3RoO1xuICAgICAgICBpZiAoYXJyKVxuICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IDIgKiBjb21wcmVzc2VkTGVuIHx8IGxlbiA9PT0gMiAqIHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVDREggKEVsbGlwdGljIEN1cnZlIERpZmZpZSBIZWxsbWFuKS5cbiAgICAgKiBDb21wdXRlcyBzaGFyZWQgcHVibGljIGtleSBmcm9tIHByaXZhdGUga2V5IGFuZCBwdWJsaWMga2V5LlxuICAgICAqIENoZWNrczogMSkgcHJpdmF0ZSBrZXkgdmFsaWRpdHkgMikgc2hhcmVkIGtleSBpcyBvbi1jdXJ2ZS5cbiAgICAgKiBEb2VzIE5PVCBoYXNoIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHByaXZhdGVBIHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIHB1YmxpY0IgZGlmZmVyZW50IHB1YmxpYyBrZXlcbiAgICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxuICAgICAqIEByZXR1cm5zIHNoYXJlZCBwdWJsaWMga2V5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2hhcmVkU2VjcmV0KHByaXZhdGVBLCBwdWJsaWNCLCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIGlmIChpc1Byb2JQdWIocHJpdmF0ZUEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmcgbXVzdCBiZSBwcml2YXRlIGtleScpO1xuICAgICAgICBpZiAoIWlzUHJvYlB1YihwdWJsaWNCKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZyBtdXN0IGJlIHB1YmxpYyBrZXknKTtcbiAgICAgICAgY29uc3QgYiA9IFBvaW50LmZyb21IZXgocHVibGljQik7IC8vIGNoZWNrIGZvciBiZWluZyBvbi1jdXJ2ZVxuICAgICAgICByZXR1cm4gYi5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVBKSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICAvLyBSRkM2OTc5OiBlbnN1cmUgRUNEU0EgbXNnIGlzIFggYnl0ZXMgYW5kIDwgTi4gUkZDIHN1Z2dlc3RzIG9wdGlvbmFsIHRydW5jYXRpbmcgdmlhIGJpdHMyb2N0ZXRzLlxuICAgIC8vIEZJUFMgMTg2LTQgNC42IHN1Z2dlc3RzIHRoZSBsZWZ0bW9zdCBtaW4obkJpdExlbiwgb3V0TGVuKSBiaXRzLCB3aGljaCBtYXRjaGVzIGJpdHMyaW50LlxuICAgIC8vIGJpdHMyaW50IGNhbiBwcm9kdWNlIHJlcz5OLCB3ZSBjYW4gZG8gbW9kKHJlcywgTikgc2luY2UgdGhlIGJpdExlbiBpcyB0aGUgc2FtZS5cbiAgICAvLyBpbnQyb2N0ZXRzIGNhbid0IGJlIHVzZWQ7IHBhZHMgc21hbGwgbXNncyB3aXRoIDA6IHVuYWNjZXB0YXRibGUgZm9yIHRydW5jIGFzIHBlciBSRkMgdmVjdG9yc1xuICAgIGNvbnN0IGJpdHMyaW50ID0gQ1VSVkUuYml0czJpbnQgfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICAvLyBGb3IgY3VydmVzIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDA6IGJpdHMyb2N0ZXRzKGJpdHMyb2N0ZXRzKG0pKSAhPT0gYml0czJvY3RldHMobSlcbiAgICAgICAgICAgIC8vIGZvciBzb21lIGNhc2VzLCBzaW5jZSBieXRlcy5sZW5ndGggKiA4IGlzIG5vdCBhY3R1YWwgYml0TGVuZ3RoLlxuICAgICAgICAgICAgY29uc3QgbnVtID0gdXQuYnl0ZXNUb051bWJlckJFKGJ5dGVzKTsgLy8gY2hlY2sgZm9yID09IHU4IGRvbmUgaGVyZVxuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBieXRlcy5sZW5ndGggKiA4IC0gQ1VSVkUubkJpdExlbmd0aDsgLy8gdHJ1bmNhdGUgdG8gbkJpdExlbmd0aCBsZWZ0bW9zdCBiaXRzXG4gICAgICAgICAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IEJpZ0ludChkZWx0YSkgOiBudW07XG4gICAgICAgIH07XG4gICAgY29uc3QgYml0czJpbnRfbW9kTiA9IENVUlZFLmJpdHMyaW50X21vZE4gfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kTihiaXRzMmludChieXRlcykpOyAvLyBjYW4ndCB1c2UgYnl0ZXNUb051bWJlckJFIGhlcmVcbiAgICAgICAgfTtcbiAgICAvLyBOT1RFOiBwYWRzIG91dHB1dCB3aXRoIHplcm8gYXMgcGVyIHNwZWNcbiAgICBjb25zdCBPUkRFUl9NQVNLID0gdXQuYml0TWFzayhDVVJWRS5uQml0TGVuZ3RoKTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0byBieXRlcy4gQ2hlY2tzIGlmIG51bSBpbiBgWzAuLk9SREVSX01BU0stMV1gIGUuZy46IGBbMC4uMl4yNTYtMV1gLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludDJvY3RldHMobnVtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmlnaW50IGV4cGVjdGVkJyk7XG4gICAgICAgIGlmICghKF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVJfTUFTSykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJpZ2ludCBleHBlY3RlZCA8IDJeJHtDVVJWRS5uQml0TGVuZ3RofWApO1xuICAgICAgICAvLyB3b3JrcyB3aXRoIG9yZGVyLCBjYW4gaGF2ZSBkaWZmZXJlbnQgc2l6ZSB0aGFuIG51bVRvRmllbGQhXG4gICAgICAgIHJldHVybiB1dC5udW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjJcbiAgICAvLyBDcmVhdGVzIFJGQzY5Nzkgc2VlZDsgY29udmVydHMgbXNnL3ByaXZLZXkgdG8gbnVtYmVycy5cbiAgICAvLyBVc2VkIG9ubHkgaW4gc2lnbiwgbm90IGluIHZlcmlmeS5cbiAgICAvLyBOT1RFOiB3ZSBjYW5ub3QgYXNzdW1lIGhlcmUgdGhhdCBtc2dIYXNoIGhhcyBzYW1lIGFtb3VudCBvZiBieXRlcyBhcyBjdXJ2ZSBvcmRlciwgdGhpcyB3aWxsIGJlIHdyb25nIGF0IGxlYXN0IGZvciBQNTIxLlxuICAgIC8vIEFsc28gaXQgY2FuIGJlIGJpZ2dlciBmb3IgUDIyNCArIFNIQTI1NlxuICAgIGZ1bmN0aW9uIHByZXBTaWcobXNnSGFzaCwgcHJpdmF0ZUtleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XG4gICAgICAgIGlmIChbJ3JlY292ZXJlZCcsICdjYW5vbmljYWwnXS5zb21lKChrKSA9PiBrIGluIG9wdHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduKCkgbGVnYWN5IG9wdGlvbnMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICBjb25zdCB7IGhhc2gsIHJhbmRvbUJ5dGVzIH0gPSBDVVJWRTtcbiAgICAgICAgbGV0IHsgbG93UywgcHJlaGFzaCwgZXh0cmFFbnRyb3B5OiBlbnQgfSA9IG9wdHM7IC8vIGdlbmVyYXRlcyBsb3ctcyBzaWdzIGJ5IGRlZmF1bHRcbiAgICAgICAgaWYgKGxvd1MgPT0gbnVsbClcbiAgICAgICAgICAgIGxvd1MgPSB0cnVlOyAvLyBSRkM2OTc5IDMuMjogd2Ugc2tpcCBzdGVwIEEsIGJlY2F1c2Ugd2UgYWxyZWFkeSBwcm92aWRlIGhhc2hcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCk7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdwcmVoYXNoZWQgbXNnSGFzaCcsIGhhc2gobXNnSGFzaCkpO1xuICAgICAgICAvLyBXZSBjYW4ndCBsYXRlciBjYWxsIGJpdHMyb2N0ZXRzLCBzaW5jZSBuZXN0ZWQgYml0czJpbnQgaXMgYnJva2VuIGZvciBjdXJ2ZXNcbiAgICAgICAgLy8gd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMC4gQmVjYXVzZSBvZiB0aGF0LCB3ZSB1bndyYXAgaXQgaGVyZSBhcyBpbnQyb2N0ZXRzIGNhbGwuXG4gICAgICAgIC8vIGNvbnN0IGJpdHMyb2N0ZXRzID0gKGJpdHMpID0+IGludDJvY3RldHMoYml0czJpbnRfbW9kTihiaXRzKSlcbiAgICAgICAgY29uc3QgaDFpbnQgPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCBkID0gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTsgLy8gdmFsaWRhdGUgcHJpdmF0ZSBrZXksIGNvbnZlcnQgdG8gYmlnaW50XG4gICAgICAgIGNvbnN0IHNlZWRBcmdzID0gW2ludDJvY3RldHMoZCksIGludDJvY3RldHMoaDFpbnQpXTtcbiAgICAgICAgLy8gZXh0cmFFbnRyb3B5LiBSRkM2OTc5IDMuNjogYWRkaXRpb25hbCBrJyAob3B0aW9uYWwpLlxuICAgICAgICBpZiAoZW50ICE9IG51bGwgJiYgZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gSyA9IEhNQUNfSyhWIHx8IDB4MDAgfHwgaW50Mm9jdGV0cyh4KSB8fCBiaXRzMm9jdGV0cyhoMSkgfHwgaycpXG4gICAgICAgICAgICBjb25zdCBlID0gZW50ID09PSB0cnVlID8gcmFuZG9tQnl0ZXMoRnAuQllURVMpIDogZW50OyAvLyBnZW5lcmF0ZSByYW5kb20gYnl0ZXMgT1IgcGFzcyBhcy1pc1xuICAgICAgICAgICAgc2VlZEFyZ3MucHVzaChlbnN1cmVCeXRlcygnZXh0cmFFbnRyb3B5JywgZSkpOyAvLyBjaGVjayBmb3IgYmVpbmcgYnl0ZXNcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWVkID0gdXQuY29uY2F0Qnl0ZXMoLi4uc2VlZEFyZ3MpOyAvLyBTdGVwIEQgb2YgUkZDNjk3OSAzLjJcbiAgICAgICAgY29uc3QgbSA9IGgxaW50OyAvLyBOT1RFOiBubyBuZWVkIHRvIGNhbGwgYml0czJpbnQgc2Vjb25kIHRpbWUgaGVyZSwgaXQgaXMgaW5zaWRlIHRydW5jYXRlSGFzaCFcbiAgICAgICAgLy8gQ29udmVydHMgc2lnbmF0dXJlIHBhcmFtcyBpbnRvIHBvaW50IHcgci9zLCBjaGVja3MgcmVzdWx0IGZvciB2YWxpZGl0eS5cbiAgICAgICAgZnVuY3Rpb24gazJzaWcoa0J5dGVzKSB7XG4gICAgICAgICAgICAvLyBSRkMgNjk3OSBTZWN0aW9uIDMuMiwgc3RlcCAzOiBrID0gYml0czJpbnQoVClcbiAgICAgICAgICAgIGNvbnN0IGsgPSBiaXRzMmludChrQnl0ZXMpOyAvLyBDYW5ub3QgdXNlIGZpZWxkcyBtZXRob2RzLCBzaW5jZSBpdCBpcyBncm91cCBlbGVtZW50XG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihrKSlcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIEltcG9ydGFudDogYWxsIG1vZCgpIGNhbGxzIGhlcmUgbXVzdCBiZSBkb25lIG92ZXIgTlxuICAgICAgICAgICAgY29uc3QgaWsgPSBpbnZOKGspOyAvLyBrXi0xIG1vZCBuXG4gICAgICAgICAgICBjb25zdCBxID0gUG9pbnQuQkFTRS5tdWx0aXBseShrKS50b0FmZmluZSgpOyAvLyBxID0gR2tcbiAgICAgICAgICAgIGNvbnN0IHIgPSBtb2ROKHEueCk7IC8vIHIgPSBxLnggbW9kIG5cbiAgICAgICAgICAgIGlmIChyID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gQ2FuIHVzZSBzY2FsYXIgYmxpbmRpbmcgYl4tMShibSArIGJkcikgd2hlcmUgYiDiiIggWzEsceKIkjFdIGFjY29yZGluZyB0b1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly90Y2hlcy5pYWNyLm9yZy9pbmRleC5waHAvVENIRVMvYXJ0aWNsZS92aWV3LzczMzcvNjUwOS4gV2UndmUgZGVjaWRlZCBhZ2FpbnN0IGl0OlxuICAgICAgICAgICAgLy8gYSkgZGVwZW5kZW5jeSBvbiBDU1BSTkcgYikgMTUlIHNsb3dkb3duIGMpIGRvZXNuJ3QgcmVhbGx5IGhlbHAgc2luY2UgYmlnaW50cyBhcmUgbm90IENUXG4gICAgICAgICAgICBjb25zdCBzID0gbW9kTihpayAqIG1vZE4obSArIHIgKiBkKSk7IC8vIE5vdCB1c2luZyBibGluZGluZyBoZXJlXG4gICAgICAgICAgICBpZiAocyA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCByZWNvdmVyeSA9IChxLnggPT09IHIgPyAwIDogMikgfCBOdW1iZXIocS55ICYgXzFuKTsgLy8gcmVjb3ZlcnkgYml0ICgyIG9yIDMsIHdoZW4gcS54ID4gbilcbiAgICAgICAgICAgIGxldCBub3JtUyA9IHM7XG4gICAgICAgICAgICBpZiAobG93UyAmJiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIocykpIHtcbiAgICAgICAgICAgICAgICBub3JtUyA9IG5vcm1hbGl6ZVMocyk7IC8vIGlmIGxvd1Mgd2FzIHBhc3NlZCwgZW5zdXJlIHMgaXMgYWx3YXlzXG4gICAgICAgICAgICAgICAgcmVjb3ZlcnkgXj0gMTsgLy8gLy8gaW4gdGhlIGJvdHRvbSBoYWxmIG9mIE5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIG5vcm1TLCByZWNvdmVyeSk7IC8vIHVzZSBub3JtUywgbm90IHNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzZWVkLCBrMnNpZyB9O1xuICAgIH1cbiAgICBjb25zdCBkZWZhdWx0U2lnT3B0cyA9IHsgbG93UzogQ1VSVkUubG93UywgcHJlaGFzaDogZmFsc2UgfTtcbiAgICBjb25zdCBkZWZhdWx0VmVyT3B0cyA9IHsgbG93UzogQ1VSVkUubG93UywgcHJlaGFzaDogZmFsc2UgfTtcbiAgICAvKipcbiAgICAgKiBTaWducyBtZXNzYWdlIGhhc2ggd2l0aCBhIHByaXZhdGUga2V5LlxuICAgICAqIGBgYFxuICAgICAqIHNpZ24obSwgZCwgaykgd2hlcmVcbiAgICAgKiAgICh4LCB5KSA9IEcgw5cga1xuICAgICAqICAgciA9IHggbW9kIG5cbiAgICAgKiAgIHMgPSAobSArIGRyKS9rIG1vZCBuXG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIG1zZ0hhc2ggTk9UIG1lc3NhZ2UuIG1zZyBuZWVkcyB0byBiZSBoYXNoZWQgdG8gYG1zZ0hhc2hgLCBvciB1c2UgYHByZWhhc2hgLlxuICAgICAqIEBwYXJhbSBwcml2S2V5IHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIG9wdHMgbG93UyBmb3Igbm9uLW1hbGxlYWJsZSBzaWdzLiBleHRyYUVudHJvcHkgZm9yIG1peGluZyByYW5kb21uZXNzIGludG8gay4gcHJlaGFzaCB3aWxsIGhhc2ggZmlyc3QgYXJnLlxuICAgICAqIEByZXR1cm5zIHNpZ25hdHVyZSB3aXRoIHJlY292ZXJ5IHBhcmFtXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2lnbihtc2dIYXNoLCBwcml2S2V5LCBvcHRzID0gZGVmYXVsdFNpZ09wdHMpIHtcbiAgICAgICAgY29uc3QgeyBzZWVkLCBrMnNpZyB9ID0gcHJlcFNpZyhtc2dIYXNoLCBwcml2S2V5LCBvcHRzKTsgLy8gU3RlcHMgQSwgRCBvZiBSRkM2OTc5IDMuMi5cbiAgICAgICAgY29uc3QgQyA9IENVUlZFO1xuICAgICAgICBjb25zdCBkcmJnID0gdXQuY3JlYXRlSG1hY0RyYmcoQy5oYXNoLm91dHB1dExlbiwgQy5uQnl0ZUxlbmd0aCwgQy5obWFjKTtcbiAgICAgICAgcmV0dXJuIGRyYmcoc2VlZCwgazJzaWcpOyAvLyBTdGVwcyBCLCBDLCBELCBFLCBGLCBHXG4gICAgfVxuICAgIC8vIEVuYWJsZSBwcmVjb21wdXRlcy4gU2xvd3MgZG93biBmaXJzdCBwdWJsaWNLZXkgY29tcHV0YXRpb24gYnkgMjBtcy5cbiAgICBQb2ludC5CQVNFLl9zZXRXaW5kb3dTaXplKDgpO1xuICAgIC8vIHV0aWxzLnByZWNvbXB1dGUoOCwgUHJvamVjdGl2ZVBvaW50LkJBU0UpXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYSBzaWduYXR1cmUgYWdhaW5zdCBtZXNzYWdlIGhhc2ggYW5kIHB1YmxpYyBrZXkuXG4gICAgICogUmVqZWN0cyBsb3dTIHNpZ25hdHVyZXMgYnkgZGVmYXVsdDogdG8gb3ZlcnJpZGUsXG4gICAgICogc3BlY2lmeSBvcHRpb24gYHtsb3dTOiBmYWxzZX1gLiBJbXBsZW1lbnRzIHNlY3Rpb24gNC4xLjQgZnJvbSBodHRwczovL3d3dy5zZWNnLm9yZy9zZWMxLXYyLnBkZjpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHZlcmlmeShyLCBzLCBoLCBQKSB3aGVyZVxuICAgICAqICAgVTEgPSBoc14tMSBtb2QgblxuICAgICAqICAgVTIgPSByc14tMSBtb2QgblxuICAgICAqICAgUiA9IFUx4ouFRyAtIFUy4ouFUFxuICAgICAqICAgbW9kKFIueCwgbikgPT0gclxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZlcmlmeShzaWduYXR1cmUsIG1zZ0hhc2gsIHB1YmxpY0tleSwgb3B0cyA9IGRlZmF1bHRWZXJPcHRzKSB7XG4gICAgICAgIGNvbnN0IHNnID0gc2lnbmF0dXJlO1xuICAgICAgICBtc2dIYXNoID0gZW5zdXJlQnl0ZXMoJ21zZ0hhc2gnLCBtc2dIYXNoKTtcbiAgICAgICAgcHVibGljS2V5ID0gZW5zdXJlQnl0ZXMoJ3B1YmxpY0tleScsIHB1YmxpY0tleSk7XG4gICAgICAgIGlmICgnc3RyaWN0JyBpbiBvcHRzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zLnN0cmljdCB3YXMgcmVuYW1lZCB0byBsb3dTJyk7XG4gICAgICAgIGNvbnN0IHsgbG93UywgcHJlaGFzaCB9ID0gb3B0cztcbiAgICAgICAgbGV0IF9zaWcgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBQO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZyA9PT0gJ3N0cmluZycgfHwgdXQuaXNCeXRlcyhzZykpIHtcbiAgICAgICAgICAgICAgICAvLyBTaWduYXR1cmUgY2FuIGJlIHJlcHJlc2VudGVkIGluIDIgd2F5czogY29tcGFjdCAoMipuQnl0ZUxlbmd0aCkgJiBERVIgKHZhcmlhYmxlLWxlbmd0aCkuXG4gICAgICAgICAgICAgICAgLy8gU2luY2UgREVSIGNhbiBhbHNvIGJlIDIqbkJ5dGVMZW5ndGggYnl0ZXMsIHdlIGNoZWNrIGZvciBpdCBmaXJzdC5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21ERVIoc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGVyRXJyb3IgaW5zdGFuY2VvZiBERVIuRXJyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRlckVycm9yO1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KHNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2cgPT09ICdvYmplY3QnICYmIHR5cGVvZiBzZy5yID09PSAnYmlnaW50JyAmJiB0eXBlb2Ygc2cucyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHNnO1xuICAgICAgICAgICAgICAgIF9zaWcgPSBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQQVJTRScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUCA9IFBvaW50LmZyb21IZXgocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlID09PSAnUEFSU0UnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2lnbmF0dXJlIG11c3QgYmUgU2lnbmF0dXJlIGluc3RhbmNlLCBVaW50OEFycmF5IG9yIGhleCBzdHJpbmdgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG93UyAmJiBfc2lnLmhhc0hpZ2hTKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IENVUlZFLmhhc2gobXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gX3NpZztcbiAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgY29uc3QgaXMgPSBpbnZOKHMpOyAvLyBzXi0xXG4gICAgICAgIGNvbnN0IHUxID0gbW9kTihoICogaXMpOyAvLyB1MSA9IGhzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IHUyID0gbW9kTihyICogaXMpOyAvLyB1MiA9IHJzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IFIgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFAsIHUxLCB1Mik/LnRvQWZmaW5lKCk7IC8vIFIgPSB1MeKLhUcgKyB1MuKLhVBcbiAgICAgICAgaWYgKCFSKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCB2ID0gbW9kTihSLngpO1xuICAgICAgICByZXR1cm4gdiA9PT0gcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIGdldFB1YmxpY0tleSxcbiAgICAgICAgZ2V0U2hhcmVkU2VjcmV0LFxuICAgICAgICBzaWduLFxuICAgICAgICB2ZXJpZnksXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIFNpZ25hdHVyZSxcbiAgICAgICAgdXRpbHMsXG4gICAgfTtcbn1cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFNoYWxsdWUgYW5kIHZhbiBkZSBXb2VzdGlqbmUgbWV0aG9kIGZvciBhbnkgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBUT0RPOiBjaGVjayBpZiB0aGVyZSBpcyBhIHdheSB0byBtZXJnZSB0aGlzIHdpdGggdXZSYXRpbyBpbiBFZHdhcmRzOyBtb3ZlIHRvIG1vZHVsYXIuXG4gKiBiID0gVHJ1ZSBhbmQgeSA9IHNxcnQodSAvIHYpIGlmICh1IC8gdikgaXMgc3F1YXJlIGluIEYsIGFuZFxuICogYiA9IEZhbHNlIGFuZCB5ID0gc3FydChaICogKHUgLyB2KSkgb3RoZXJ3aXNlLlxuICogQHBhcmFtIEZwXG4gKiBAcGFyYW0gWlxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XG4gICAgLy8gR2VuZXJpYyBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgICBsZXQgbCA9IF8wbjtcbiAgICBmb3IgKGxldCBvID0gcSAtIF8xbjsgbyAlIF8ybiA9PT0gXzBuOyBvIC89IF8ybilcbiAgICAgICAgbCArPSBfMW47XG4gICAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxuICAgIC8vIFdlIG5lZWQgMm4gKiogYzEgYW5kIDJuICoqIChjMS0xKS4gV2UgY2FuJ3QgdXNlICoqOyBidXQgd2UgY2FuIHVzZSA8PC5cbiAgICAvLyAybiAqKiBjMSA9PSAybiA8PCAoYzEtMSlcbiAgICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcbiAgICBjb25zdCBfMm5fcG93X2MxID0gXzJuX3Bvd19jMV8xICogXzJuO1xuICAgIGNvbnN0IGMyID0gKHEgLSBfMW4pIC8gXzJuX3Bvd19jMTsgLy8gMi4gYzIgPSAocSAtIDEpIC8gKDJeYzEpICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM0ID0gXzJuX3Bvd19jMSAtIF8xbjsgLy8gNC4gYzQgPSAyXmMxIC0gMSAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM1ID0gXzJuX3Bvd19jMV8xOyAvLyA1LiBjNSA9IDJeKGMxIC0gMSkgICAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXG4gICAgY29uc3QgYzcgPSBGcC5wb3coWiwgKGMyICsgXzFuKSAvIF8ybik7IC8vIDcuIGM3ID0gWl4oKGMyICsgMSkgLyAyKVxuICAgIGxldCBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XG4gICAgICAgIGxldCB0djIgPSBGcC5wb3codiwgYzQpOyAvLyAyLiB0djIgPSB2XmM0XG4gICAgICAgIGxldCB0djMgPSBGcC5zcXIodHYyKTsgLy8gMy4gdHYzID0gdHYyXjJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgbGV0IHR2NSA9IEZwLm11bCh1LCB0djMpOyAvLyA1LiB0djUgPSB1ICogdHYzXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djUsIGMzKTsgLy8gNi4gdHY1ID0gdHY1XmMzXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxuICAgICAgICB0djIgPSBGcC5tdWwodHY1LCB2KTsgLy8gOC4gdHYyID0gdHY1ICogdlxuICAgICAgICB0djMgPSBGcC5tdWwodHY1LCB1KTsgLy8gOS4gdHYzID0gdHY1ICogdVxuICAgICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxuICAgICAgICB0djUgPSBGcC5wb3codHY0LCBjNSk7IC8vIDExLiB0djUgPSB0djReYzVcbiAgICAgICAgbGV0IGlzUVIgPSBGcC5lcWwodHY1LCBGcC5PTkUpOyAvLyAxMi4gaXNRUiA9IHR2NSA9PSAxXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDE0LiB0djUgPSB0djQgKiB0djFcbiAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgaXNRUik7IC8vIDE1LiB0djMgPSBDTU9WKHR2MiwgdHYzLCBpc1FSKVxuICAgICAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXG4gICAgICAgIC8vIDE3LiBmb3IgaSBpbiAoYzEsIGMxIC0gMSwgLi4uLCAyKTpcbiAgICAgICAgZm9yIChsZXQgaSA9IGMxOyBpID4gXzFuOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB0djUgPSBpIC0gXzJuOyAvLyAxOC4gICAgdHY1ID0gaSAtIDJcbiAgICAgICAgICAgIHR2NSA9IF8ybiA8PCAodHY1IC0gXzFuKTsgLy8gMTkuICAgIHR2NSA9IDJedHY1XG4gICAgICAgICAgICBsZXQgdHZ2NSA9IEZwLnBvdyh0djQsIHR2NSk7IC8vIDIwLiAgICB0djUgPSB0djRedHY1XG4gICAgICAgICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpOyAvLyAyMS4gICAgZTEgPSB0djUgPT0gMVxuICAgICAgICAgICAgdHYyID0gRnAubXVsKHR2MywgdHYxKTsgLy8gMjIuICAgIHR2MiA9IHR2MyAqIHR2MVxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYxKTsgLy8gMjMuICAgIHR2MSA9IHR2MSAqIHR2MVxuICAgICAgICAgICAgdHZ2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDI0LiAgICB0djUgPSB0djQgKiB0djFcbiAgICAgICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGUxKTsgLy8gMjUuICAgIHR2MyA9IENNT1YodHYyLCB0djMsIGUxKVxuICAgICAgICAgICAgdHY0ID0gRnAuY21vdih0dnY1LCB0djQsIGUxKTsgLy8gMjYuICAgIHR2NCA9IENNT1YodHY1LCB0djQsIGUxKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB0djMgfTtcbiAgICB9O1xuICAgIGlmIChGcC5PUkRFUiAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIHNxcnRfcmF0aW9fM21vZDQodSwgdilcbiAgICAgICAgY29uc3QgYzEgPSAoRnAuT1JERVIgLSBfM24pIC8gXzRuOyAvLyAxLiBjMSA9IChxIC0gMykgLyA0ICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxuICAgICAgICBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpOyAvLyAzLiB0djEgPSB0djEgKiB0djJcbiAgICAgICAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcbiAgICAgICAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXG4gICAgICAgICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpOyAvLyA2LiB5MiA9IHkxICogYzJcbiAgICAgICAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcbiAgICAgICAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpOyAvLyAxMC4geSA9IENNT1YoeTIsIHkxLCBpc1FSKVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE5vIGN1cnZlcyB1c2VzIHRoYXRcbiAgICAvLyBpZiAoRnAuT1JERVIgJSBfOG4gPT09IF81bikgLy8gc3FydF9yYXRpb181bW9kOFxuICAgIHJldHVybiBzcXJ0UmF0aW87XG59XG4vKipcbiAqIFNpbXBsaWZpZWQgU2hhbGx1ZS12YW4gZGUgV29lc3Rpam5lLVVsYXMgTWV0aG9kXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTYuNi4yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCBvcHRzKSB7XG4gICAgbW9kLnZhbGlkYXRlRmllbGQoRnApO1xuICAgIGlmICghRnAuaXNWYWxpZChvcHRzLkEpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuQikgfHwgIUZwLmlzVmFsaWQob3B0cy5aKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlU2ltcGxlU1dVOiBpbnZhbGlkIG9wdHMnKTtcbiAgICBjb25zdCBzcXJ0UmF0aW8gPSBTV1VGcFNxcnRSYXRpbyhGcCwgb3B0cy5aKTtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZwLmlzT2RkIGlzIG5vdCBpbXBsZW1lbnRlZCEnKTtcbiAgICAvLyBJbnB1dDogdSwgYW4gZWxlbWVudCBvZiBGLlxuICAgIC8vIE91dHB1dDogKHgsIHkpLCBhIHBvaW50IG9uIEUuXG4gICAgcmV0dXJuICh1KSA9PiB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgdHYxLCB0djIsIHR2MywgdHY0LCB0djUsIHR2NiwgeCwgeTtcbiAgICAgICAgdHYxID0gRnAuc3FyKHUpOyAvLyAxLiAgdHYxID0gdV4yXG4gICAgICAgIHR2MSA9IEZwLm11bCh0djEsIG9wdHMuWik7IC8vIDIuICB0djEgPSBaICogdHYxXG4gICAgICAgIHR2MiA9IEZwLnNxcih0djEpOyAvLyAzLiAgdHYyID0gdHYxXjJcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHYxKTsgLy8gNC4gIHR2MiA9IHR2MiArIHR2MVxuICAgICAgICB0djMgPSBGcC5hZGQodHYyLCBGcC5PTkUpOyAvLyA1LiAgdHYzID0gdHYyICsgMVxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCBvcHRzLkIpOyAvLyA2LiAgdHYzID0gQiAqIHR2M1xuICAgICAgICB0djQgPSBGcC5jbW92KG9wdHMuWiwgRnAubmVnKHR2MiksICFGcC5lcWwodHYyLCBGcC5aRVJPKSk7IC8vIDcuICB0djQgPSBDTU9WKFosIC10djIsIHR2MiAhPSAwKVxuICAgICAgICB0djQgPSBGcC5tdWwodHY0LCBvcHRzLkEpOyAvLyA4LiAgdHY0ID0gQSAqIHR2NFxuICAgICAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gOS4gIHR2MiA9IHR2M14yXG4gICAgICAgIHR2NiA9IEZwLnNxcih0djQpOyAvLyAxMC4gdHY2ID0gdHY0XjJcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5BKTsgLy8gMTEuIHR2NSA9IEEgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTIuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB0djIgPSBGcC5tdWwodHYyLCB0djMpOyAvLyAxMy4gdHYyID0gdHYyICogdHYzXG4gICAgICAgIHR2NiA9IEZwLm11bCh0djYsIHR2NCk7IC8vIDE0LiB0djYgPSB0djYgKiB0djRcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5CKTsgLy8gMTUuIHR2NSA9IEIgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTYuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB4ID0gRnAubXVsKHR2MSwgdHYzKTsgLy8gMTcuICAgeCA9IHR2MSAqIHR2M1xuICAgICAgICBjb25zdCB7IGlzVmFsaWQsIHZhbHVlIH0gPSBzcXJ0UmF0aW8odHYyLCB0djYpOyAvLyAxOC4gKGlzX2d4MV9zcXVhcmUsIHkxKSA9IHNxcnRfcmF0aW8odHYyLCB0djYpXG4gICAgICAgIHkgPSBGcC5tdWwodHYxLCB1KTsgLy8gMTkuICAgeSA9IHR2MSAqIHUgIC0+IFogKiB1XjMgKiB5MVxuICAgICAgICB5ID0gRnAubXVsKHksIHZhbHVlKTsgLy8gMjAuICAgeSA9IHkgKiB5MVxuICAgICAgICB4ID0gRnAuY21vdih4LCB0djMsIGlzVmFsaWQpOyAvLyAyMS4gICB4ID0gQ01PVih4LCB0djMsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIHkgPSBGcC5jbW92KHksIHZhbHVlLCBpc1ZhbGlkKTsgLy8gMjIuICAgeSA9IENNT1YoeSwgeTEsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIGNvbnN0IGUxID0gRnAuaXNPZGQodSkgPT09IEZwLmlzT2RkKHkpOyAvLyAyMy4gIGUxID0gc2duMCh1KSA9PSBzZ24wKHkpXG4gICAgICAgIHkgPSBGcC5jbW92KEZwLm5lZyh5KSwgeSwgZTEpOyAvLyAyNC4gICB5ID0gQ01PVigteSwgeSwgZTEpXG4gICAgICAgIHggPSBGcC5kaXYoeCwgdHY0KTsgLy8gMjUuICAgeCA9IHggLyB0djRcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWllcnN0cmFzcy5qcy5tYXAiXSwibmFtZXMiOlsibW9kIiwidXQiLCJlbnN1cmVCeXRlcyIsIndOQUYiLCJ2YWxpZGF0ZUJhc2ljIiwidmFsaWRhdGVQb2ludE9wdHMiLCJjdXJ2ZSIsIm9wdHMiLCJ2YWxpZGF0ZU9iamVjdCIsImEiLCJiIiwiYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzIiwid3JhcFByaXZhdGVLZXkiLCJpc1RvcnNpb25GcmVlIiwiY2xlYXJDb2ZhY3RvciIsImFsbG93SW5maW5pdHlQb2ludCIsImZyb21CeXRlcyIsInRvQnl0ZXMiLCJlbmRvIiwiRnAiLCJlcWwiLCJaRVJPIiwiRXJyb3IiLCJiZXRhIiwic3BsaXRTY2FsYXIiLCJPYmplY3QiLCJmcmVlemUiLCJieXRlc1RvTnVtYmVyQkUiLCJiMm4iLCJoZXhUb0J5dGVzIiwiaDJiIiwiREVSIiwiRXJyIiwiREVSRXJyIiwiY29uc3RydWN0b3IiLCJtIiwiX3BhcnNlSW50IiwiZGF0YSIsIkUiLCJsZW5ndGgiLCJsZW4iLCJyZXMiLCJzdWJhcnJheSIsImQiLCJsIiwidG9TaWciLCJoZXgiLCJhYnl0ZXMiLCJyIiwic0J5dGVzIiwicyIsInJCeXRlc0xlZnQiLCJoZXhGcm9tU2lnIiwic2lnIiwic2xpY2UiLCJOdW1iZXIiLCJwYXJzZUludCIsImgiLCJudW0iLCJ0b1N0cmluZyIsInNobCIsInJobCIsInNsIiwicmwiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJfM24iLCJfNG4iLCJ3ZWllcnN0cmFzc1BvaW50cyIsIkNVUlZFIiwiX2MiLCJwb2ludCIsIl9pc0NvbXByZXNzZWQiLCJ0b0FmZmluZSIsImNvbmNhdEJ5dGVzIiwiVWludDhBcnJheSIsImZyb20iLCJ4IiwieSIsImJ5dGVzIiwidGFpbCIsIkJZVEVTIiwid2VpZXJzdHJhc3NFcXVhdGlvbiIsIngyIiwic3FyIiwieDMiLCJtdWwiLCJhZGQiLCJHeSIsIkd4IiwiaXNXaXRoaW5DdXJ2ZU9yZGVyIiwibiIsImFzc2VydEdFIiwibm9ybVByaXZhdGVLZXlUb1NjYWxhciIsImtleSIsImxlbmd0aHMiLCJuQnl0ZUxlbmd0aCIsImlzQnl0ZXMiLCJieXRlc1RvSGV4IiwiaW5jbHVkZXMiLCJwYWRTdGFydCIsImVycm9yIiwicG9pbnRQcmVjb21wdXRlcyIsIk1hcCIsImFzc2VydFByalBvaW50Iiwib3RoZXIiLCJQb2ludCIsInB4IiwicHkiLCJweiIsImlzVmFsaWQiLCJmcm9tQWZmaW5lIiwicCIsImlzMCIsImkiLCJPTkUiLCJub3JtYWxpemVaIiwicG9pbnRzIiwidG9JbnYiLCJpbnZlcnRCYXRjaCIsIm1hcCIsImZyb21IZXgiLCJQIiwiYXNzZXJ0VmFsaWRpdHkiLCJmcm9tUHJpdmF0ZUtleSIsInByaXZhdGVLZXkiLCJCQVNFIiwibXVsdGlwbHkiLCJfc2V0V2luZG93U2l6ZSIsIndpbmRvd1NpemUiLCJfV0lORE9XX1NJWkUiLCJkZWxldGUiLCJsZWZ0IiwicmlnaHQiLCJoYXNFdmVuWSIsImlzT2RkIiwiZXF1YWxzIiwiWDEiLCJZMSIsIloxIiwiWDIiLCJZMiIsIloyIiwiVTEiLCJVMiIsIm5lZ2F0ZSIsIm5lZyIsImRvdWJsZSIsImIzIiwiWDMiLCJZMyIsIlozIiwidDAiLCJ0MSIsInQyIiwidDMiLCJzdWIiLCJ0NCIsInQ1Iiwic3VidHJhY3QiLCJ3bmFmIiwid05BRkNhY2hlZCIsImNvbXAiLCJtdWx0aXBseVVuc2FmZSIsIkkiLCJ1bnNhZmVMYWRkZXIiLCJrMW5lZyIsImsxIiwiazJuZWciLCJrMiIsImsxcCIsImsycCIsInNjYWxhciIsImZha2UiLCJmIiwiZjFwIiwiZjJwIiwiY29uc3RUaW1lTmVnYXRlIiwibXVsdGlwbHlBbmRBZGRVbnNhZmUiLCJRIiwiRyIsInN1bSIsInVuZGVmaW5lZCIsIml6IiwieiIsImludiIsImF4IiwiYXkiLCJ6eiIsImNvZmFjdG9yIiwidG9SYXdCeXRlcyIsImlzQ29tcHJlc3NlZCIsInRvSGV4IiwiX2JpdHMiLCJuQml0TGVuZ3RoIiwiTWF0aCIsImNlaWwiLCJQcm9qZWN0aXZlUG9pbnQiLCJ2YWxpZGF0ZU9wdHMiLCJoYXNoIiwiaG1hYyIsInJhbmRvbUJ5dGVzIiwiYml0czJpbnQiLCJiaXRzMmludF9tb2ROIiwibG93UyIsIndlaWVyc3RyYXNzIiwiY3VydmVEZWYiLCJDVVJWRV9PUkRFUiIsImNvbXByZXNzZWRMZW4iLCJ1bmNvbXByZXNzZWRMZW4iLCJpc1ZhbGlkRmllbGRFbGVtZW50IiwiT1JERVIiLCJtb2ROIiwiaW52TiIsImludmVydCIsImNhdCIsImhlYWQiLCJ5MiIsInNxcnQiLCJzcXJ0RXJyb3IiLCJzdWZmaXgiLCJtZXNzYWdlIiwiaXNZT2RkIiwiaXNIZWFkT2RkIiwibnVtVG9OQnl0ZVN0ciIsIm51bWJlclRvQnl0ZXNCRSIsImlzQmlnZ2VyVGhhbkhhbGZPcmRlciIsIm51bWJlciIsIkhBTEYiLCJub3JtYWxpemVTIiwic2xjTnVtIiwidG8iLCJTaWduYXR1cmUiLCJyZWNvdmVyeSIsImZyb21Db21wYWN0IiwiZnJvbURFUiIsImFkZFJlY292ZXJ5Qml0IiwicmVjb3ZlclB1YmxpY0tleSIsIm1zZ0hhc2giLCJyZWMiLCJyYWRqIiwicHJlZml4IiwiUiIsImlyIiwidTEiLCJ1MiIsImhhc0hpZ2hTIiwidG9ERVJSYXdCeXRlcyIsInRvREVSSGV4IiwidG9Db21wYWN0UmF3Qnl0ZXMiLCJ0b0NvbXBhY3RIZXgiLCJ1dGlscyIsImlzVmFsaWRQcml2YXRlS2V5IiwicmFuZG9tUHJpdmF0ZUtleSIsImdldE1pbkhhc2hMZW5ndGgiLCJtYXBIYXNoVG9GaWVsZCIsInByZWNvbXB1dGUiLCJnZXRQdWJsaWNLZXkiLCJpc1Byb2JQdWIiLCJpdGVtIiwiYXJyIiwic3RyIiwiZ2V0U2hhcmVkU2VjcmV0IiwicHJpdmF0ZUEiLCJwdWJsaWNCIiwiZGVsdGEiLCJPUkRFUl9NQVNLIiwiYml0TWFzayIsImludDJvY3RldHMiLCJwcmVwU2lnIiwiZGVmYXVsdFNpZ09wdHMiLCJzb21lIiwiayIsInByZWhhc2giLCJleHRyYUVudHJvcHkiLCJlbnQiLCJoMWludCIsInNlZWRBcmdzIiwiZSIsInB1c2giLCJzZWVkIiwiazJzaWciLCJrQnl0ZXMiLCJpayIsInEiLCJub3JtUyIsImRlZmF1bHRWZXJPcHRzIiwic2lnbiIsInByaXZLZXkiLCJDIiwiZHJiZyIsImNyZWF0ZUhtYWNEcmJnIiwib3V0cHV0TGVuIiwidmVyaWZ5Iiwic2lnbmF0dXJlIiwicHVibGljS2V5Iiwic2ciLCJfc2lnIiwiZGVyRXJyb3IiLCJpcyIsInYiLCJTV1VGcFNxcnRSYXRpbyIsIloiLCJvIiwiYzEiLCJfMm5fcG93X2MxXzEiLCJfMm5fcG93X2MxIiwiYzIiLCJjMyIsImM0IiwiYzUiLCJjNiIsInBvdyIsImM3Iiwic3FydFJhdGlvIiwidSIsInR2MSIsInR2MiIsInR2MyIsInR2NSIsInR2NCIsImlzUVIiLCJjbW92IiwidHZ2NSIsImUxIiwidmFsdWUiLCJ5MSIsIm1hcFRvQ3VydmVTaW1wbGVTV1UiLCJ2YWxpZGF0ZUZpZWxkIiwiQSIsIkIiLCJ0djYiLCJkaXYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/esm/secp256k1.js":
/*!*****************************************************!*\
  !*** ./node_modules/@noble/curves/esm/secp256k1.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   schnorr: () => (/* binding */ schnorr),\n/* harmony export */   secp256k1: () => (/* binding */ secp256k1)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/utils.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(ssr)/./node_modules/@noble/curves/esm/_shortw_utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n\n\n\n\nconst secp256k1P = BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\");\nconst secp256k1N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b)=>(a + b / _2n) / b;\n/**\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */ function sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = y * y * y % P; // x^3, 11\n    const b3 = b2 * b2 * y % P; // x^7\n    const b6 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b3, _3n, P) * b3 % P;\n    const b9 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b6, _3n, P) * b3 % P;\n    const b11 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b9, _2n, P) * b2 % P;\n    const b22 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b11, _11n, P) * b11 % P;\n    const b44 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b22, _22n, P) * b22 % P;\n    const b88 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b44, _44n, P) * b44 % P;\n    const b176 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b88, _88n, P) * b88 % P;\n    const b220 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b176, _44n, P) * b44 % P;\n    const b223 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b220, _3n, P) * b3 % P;\n    const t1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b223, _23n, P) * b22 % P;\n    const t2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t1, _6n, P) * b2 % P;\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y)) throw new Error(\"Cannot find square root\");\n    return root;\n}\nconst Fp = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(secp256k1P, undefined, undefined, {\n    sqrt: sqrtMod\n});\nconst secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: BigInt(0),\n    b: BigInt(7),\n    Fp,\n    n: secp256k1N,\n    // Base point (x, y) aka generator point\n    Gx: BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),\n    Gy: BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),\n    h: BigInt(1),\n    lowS: true,\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */ endo: {\n        beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n        splitScalar: (k)=>{\n            const n = secp256k1N;\n            const a1 = BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\");\n            const b1 = -_1n * BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\");\n            const a2 = BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\");\n            const b2 = a1;\n            const POW_2_128 = BigInt(\"0x100000000000000000000000000000000\"); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg) k1 = n - k1;\n            if (k2neg) k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error(\"splitScalar: Endomorphism failed, k=\" + k);\n            }\n            return {\n                k1neg,\n                k1,\n                k2neg,\n                k2\n            };\n        }\n    }\n}, _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x)=>typeof x === \"bigint\" && _0n < x && x < secp256k1P;\nconst ge = (x)=>typeof x === \"bigint\" && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */ const TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));\n        tagP = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point)=>point.toRawBytes(true).slice(1);\nconst numTo32b = (n)=>(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE)(n, 32);\nconst modP = (x)=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1P);\nconst modN = (x)=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b)=>Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return {\n        scalar: scalar,\n        bytes: pointToBytes(p)\n    };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */ function lift_x(x) {\n    if (!fe(x)) throw new Error(\"bad x: need 0 < x < p\"); // Fail if x ≥ p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */ function challenge(...args) {\n    return modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash(\"BIP0340/challenge\", ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */ function schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */ function schnorrSign(message, privateKey, auxRand = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.randomBytes)(32)) {\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"message\", message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"auxRand\", auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash(\"BIP0340/aux\", a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash(\"BIP0340/nonce\", t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n) throw new Error(\"sign failed: k is zero\"); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px)) throw new Error(\"sign: Invalid signature produced\");\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */ function schnorrVerify(signature, message, publicKey) {\n    const sig = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"signature\", signature, 64);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"message\", message);\n    const pub = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"publicKey\", publicKey, 32);\n    try {\n        const P = lift_x((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\n        if (!fe(r)) return false;\n        const s = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\n        if (!ge(s)) return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\n    } catch (error) {\n        return false;\n    }\n}\nconst schnorr = /* @__PURE__ */ (()=>({\n        getPublicKey: schnorrGetPublicKey,\n        sign: schnorrSign,\n        verify: schnorrVerify,\n        utils: {\n            randomPrivateKey: secp256k1.utils.randomPrivateKey,\n            lift_x,\n            pointToBytes,\n            numberToBytesBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE,\n            bytesToNumberBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE,\n            taggedHash,\n            mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod\n        }\n    }))();\nconst isoMap = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.isogenyMap)(Fp, [\n        // xNum\n        [\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7\",\n            \"0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581\",\n            \"0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262\",\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c\"\n        ],\n        // xDen\n        [\n            \"0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b\",\n            \"0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ],\n        // yNum\n        [\n            \"0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c\",\n            \"0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3\",\n            \"0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931\",\n            \"0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84\"\n        ],\n        // yDen\n        [\n            \"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b\",\n            \"0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573\",\n            \"0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ]\n    ].map((i)=>i.map((j)=>BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (()=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__.mapToCurveSimpleSWU)(Fp, {\n        A: BigInt(\"0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533\"),\n        B: BigInt(\"1771\"),\n        Z: Fp.create(BigInt(\"-11\"))\n    }))();\nconst htf = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(secp256k1.ProjectivePoint, (scalars)=>{\n        const { x, y } = mapSWU(Fp.create(scalars[0]));\n        return isoMap(x, y);\n    }, {\n        DST: \"secp256k1_XMD:SHA-256_SSWU_RO_\",\n        encodeDST: \"secp256k1_XMD:SHA-256_SSWU_NU_\",\n        p: Fp.ORDER,\n        m: 1,\n        k: 128,\n        expand: \"xmd\",\n        hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256\n    }))();\nconst hashToCurve = /* @__PURE__ */ (()=>htf.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (()=>htf.encodeToCurve)(); //# sourceMappingURL=secp256k1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vc2VjcDI1NmsxLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUEsb0VBQW9FLEdBQ3RCO0FBQ0k7QUFDTztBQUNPO0FBQ2lDO0FBQzFCO0FBQ3RCO0FBQ2pELE1BQU1hLGFBQWFDLE9BQU87QUFDMUIsTUFBTUMsYUFBYUQsT0FBTztBQUMxQixNQUFNRSxNQUFNRixPQUFPO0FBQ25CLE1BQU1HLE1BQU1ILE9BQU87QUFDbkIsTUFBTUksYUFBYSxDQUFDQyxHQUFHQyxJQUFNLENBQUNELElBQUlDLElBQUlILEdBQUUsSUFBS0c7QUFDN0M7OztDQUdDLEdBQ0QsU0FBU0MsUUFBUUMsQ0FBQztJQUNkLE1BQU1DLElBQUlWO0lBQ1Ysa0JBQWtCO0lBQ2xCLE1BQU1XLE1BQU1WLE9BQU8sSUFBSVcsTUFBTVgsT0FBTyxJQUFJWSxPQUFPWixPQUFPLEtBQUthLE9BQU9iLE9BQU87SUFDekUsa0JBQWtCO0lBQ2xCLE1BQU1jLE9BQU9kLE9BQU8sS0FBS2UsT0FBT2YsT0FBTyxLQUFLZ0IsT0FBT2hCLE9BQU87SUFDMUQsTUFBTWlCLEtBQUssSUFBS1QsSUFBSUEsSUFBS0MsR0FBRyxVQUFVO0lBQ3RDLE1BQU1TLEtBQUssS0FBTUQsS0FBS1QsSUFBS0MsR0FBRyxNQUFNO0lBQ3BDLE1BQU1VLEtBQUssMkRBQU1ELElBQUlSLEtBQUtELEtBQUtTLEtBQU1UO0lBQ3JDLE1BQU1XLEtBQUssMkRBQU1ELElBQUlULEtBQUtELEtBQUtTLEtBQU1UO0lBQ3JDLE1BQU1ZLE1BQU0sMkRBQU1ELElBQUlqQixLQUFLTSxLQUFLUSxLQUFNUjtJQUN0QyxNQUFNYSxNQUFNLDJEQUFNRCxLQUFLVCxNQUFNSCxLQUFLWSxNQUFPWjtJQUN6QyxNQUFNYyxNQUFNLDJEQUFNRCxLQUFLVCxNQUFNSixLQUFLYSxNQUFPYjtJQUN6QyxNQUFNZSxNQUFNLDJEQUFNRCxLQUFLUixNQUFNTixLQUFLYyxNQUFPZDtJQUN6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O0lBQ3JCLEdBQUc7UUFDQ29JLEtBQUs7UUFDTEMsV0FBVztRQUNYcEQsR0FBRzFELEdBQUcrRyxLQUFLO1FBQ1h0QyxHQUFHO1FBQ0gxRCxHQUFHO1FBQ0hpRyxRQUFRO1FBQ1JDLE1BQU05Six3REFBTUE7SUFDaEIsRUFBQztBQUNNLE1BQU0rSixjQUE4QixhQUFILEdBQUksS0FBTVAsSUFBSU8sV0FBVyxJQUFJO0FBQzlELE1BQU1DLGdCQUFnQyxhQUFILEdBQUksS0FBTVIsSUFBSVEsYUFBYSxJQUFJLENBQ3pFLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NmYXBwLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL3NlY3AyNTZrMS5qcz9kMTIxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMjU2JztcbmltcG9ydCB7IHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyBGaWVsZCwgbW9kLCBwb3cyIH0gZnJvbSAnLi9hYnN0cmFjdC9tb2R1bGFyLmpzJztcbmltcG9ydCB7IG1hcFRvQ3VydmVTaW1wbGVTV1UgfSBmcm9tICcuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzJztcbmltcG9ydCB7IGJ5dGVzVG9OdW1iZXJCRSwgY29uY2F0Qnl0ZXMsIGVuc3VyZUJ5dGVzLCBudW1iZXJUb0J5dGVzQkUgfSBmcm9tICcuL2Fic3RyYWN0L3V0aWxzLmpzJztcbmltcG9ydCB7IGNyZWF0ZUhhc2hlciwgaXNvZ2VueU1hcCB9IGZyb20gJy4vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVDdXJ2ZSB9IGZyb20gJy4vX3Nob3J0d191dGlscy5qcyc7XG5jb25zdCBzZWNwMjU2azFQID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZjMmYnKTtcbmNvbnN0IHNlY3AyNTZrMU4gPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MScpO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gQmlnSW50KDIpO1xuY29uc3QgZGl2TmVhcmVzdCA9IChhLCBiKSA9PiAoYSArIGIgLyBfMm4pIC8gYjtcbi8qKlxuICog4oiabiA9IG5eKChwKzEpLzQpIGZvciBmaWVsZHMgcCA9IDMgbW9kIDQuIFdlIHVud3JhcCB0aGUgbG9vcCBhbmQgbXVsdGlwbHkgYml0LWJ5LWJpdC5cbiAqIChQKzFuLzRuKS50b1N0cmluZygyKSB3b3VsZCBwcm9kdWNlIGJpdHMgWzIyM3ggMSwgMCwgMjJ4IDEsIDR4IDAsIDExLCAwMF1cbiAqL1xuZnVuY3Rpb24gc3FydE1vZCh5KSB7XG4gICAgY29uc3QgUCA9IHNlY3AyNTZrMVA7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzNuID0gQmlnSW50KDMpLCBfNm4gPSBCaWdJbnQoNiksIF8xMW4gPSBCaWdJbnQoMTEpLCBfMjJuID0gQmlnSW50KDIyKTtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfMjNuID0gQmlnSW50KDIzKSwgXzQ0biA9IEJpZ0ludCg0NCksIF84OG4gPSBCaWdJbnQoODgpO1xuICAgIGNvbnN0IGIyID0gKHkgKiB5ICogeSkgJSBQOyAvLyB4XjMsIDExXG4gICAgY29uc3QgYjMgPSAoYjIgKiBiMiAqIHkpICUgUDsgLy8geF43XG4gICAgY29uc3QgYjYgPSAocG93MihiMywgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgYjkgPSAocG93MihiNiwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgYjExID0gKHBvdzIoYjksIF8ybiwgUCkgKiBiMikgJSBQO1xuICAgIGNvbnN0IGIyMiA9IChwb3cyKGIxMSwgXzExbiwgUCkgKiBiMTEpICUgUDtcbiAgICBjb25zdCBiNDQgPSAocG93MihiMjIsIF8yMm4sIFApICogYjIyKSAlIFA7XG4gICAgY29uc3QgYjg4ID0gKHBvdzIoYjQ0LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIxNzYgPSAocG93MihiODgsIF84OG4sIFApICogYjg4KSAlIFA7XG4gICAgY29uc3QgYjIyMCA9IChwb3cyKGIxNzYsIF80NG4sIFApICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjIyMyA9IChwb3cyKGIyMjAsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IHQxID0gKHBvdzIoYjIyMywgXzIzbiwgUCkgKiBiMjIpICUgUDtcbiAgICBjb25zdCB0MiA9IChwb3cyKHQxLCBfNm4sIFApICogYjIpICUgUDtcbiAgICBjb25zdCByb290ID0gcG93Mih0MiwgXzJuLCBQKTtcbiAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIHkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgcmV0dXJuIHJvb3Q7XG59XG5jb25zdCBGcCA9IEZpZWxkKHNlY3AyNTZrMVAsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7IHNxcnQ6IHNxcnRNb2QgfSk7XG5leHBvcnQgY29uc3Qgc2VjcDI1NmsxID0gY3JlYXRlQ3VydmUoe1xuICAgIGE6IEJpZ0ludCgwKSwgLy8gZXF1YXRpb24gcGFyYW1zOiBhLCBiXG4gICAgYjogQmlnSW50KDcpLCAvLyBTZWVtIHRvIGJlIHJpZ2lkOiBiaXRjb2ludGFsay5vcmcvaW5kZXgucGhwP3RvcGljPTI4OTc5NS5tc2czMTgzOTc1I21zZzMxODM5NzVcbiAgICBGcCwgLy8gRmllbGQncyBwcmltZTogMm4qKjI1Nm4gLSAybioqMzJuIC0gMm4qKjluIC0gMm4qKjhuIC0gMm4qKjduIC0gMm4qKjZuIC0gMm4qKjRuIC0gMW5cbiAgICBuOiBzZWNwMjU2azFOLCAvLyBDdXJ2ZSBvcmRlciwgdG90YWwgY291bnQgb2YgdmFsaWQgcG9pbnRzIGluIHRoZSBmaWVsZFxuICAgIC8vIEJhc2UgcG9pbnQgKHgsIHkpIGFrYSBnZW5lcmF0b3IgcG9pbnRcbiAgICBHeDogQmlnSW50KCc1NTA2NjI2MzAyMjI3NzM0MzY2OTU3ODcxODg5NTE2ODUzNDMyNjI1MDYwMzQ1Mzc3NzU5NDE3NTUwMDE4NzM2MDM4OTExNjcyOTI0MCcpLFxuICAgIEd5OiBCaWdJbnQoJzMyNjcwNTEwMDIwNzU4ODE2OTc4MDgzMDg1MTMwNTA3MDQzMTg0NDcxMjczMzgwNjU5MjQzMjc1OTM4OTA0MzM1NzU3MzM3NDgyNDI0JyksXG4gICAgaDogQmlnSW50KDEpLCAvLyBDb2ZhY3RvclxuICAgIGxvd1M6IHRydWUsIC8vIEFsbG93IG9ubHkgbG93LVMgc2lnbmF0dXJlcyBieSBkZWZhdWx0IGluIHNpZ24oKSBhbmQgdmVyaWZ5KClcbiAgICAvKipcbiAgICAgKiBzZWNwMjU2azEgYmVsb25ncyB0byBLb2JsaXR6IGN1cnZlczogaXQgaGFzIGVmZmljaWVudGx5IGNvbXB1dGFibGUgZW5kb21vcnBoaXNtLlxuICAgICAqIEVuZG9tb3JwaGlzbSB1c2VzIDJ4IGxlc3MgUkFNLCBzcGVlZHMgdXAgcHJlY29tcHV0YXRpb24gYnkgMnggYW5kIEVDREggLyBrZXkgcmVjb3ZlcnkgYnkgMjAlLlxuICAgICAqIEZvciBwcmVjb21wdXRlZCB3TkFGIGl0IHRyYWRlcyBvZmYgMS8yIGluaXQgdGltZSAmIDEvMyByYW0gZm9yIDIwJSBwZXJmIGhpdC5cbiAgICAgKiBFeHBsYW5hdGlvbjogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bG1pbGxyL2ViNjcwODA2NzkzZTg0ZGY2MjhhN2M0MzRhODczMDY2XG4gICAgICovXG4gICAgZW5kbzoge1xuICAgICAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxuICAgICAgICBzcGxpdFNjYWxhcjogKGspID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBzZWNwMjU2azFOO1xuICAgICAgICAgICAgY29uc3QgYTEgPSBCaWdJbnQoJzB4MzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnKTtcbiAgICAgICAgICAgIGNvbnN0IGIxID0gLV8xbiAqIEJpZ0ludCgnMHhlNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMycpO1xuICAgICAgICAgICAgY29uc3QgYTIgPSBCaWdJbnQoJzB4MTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4Jyk7XG4gICAgICAgICAgICBjb25zdCBiMiA9IGExO1xuICAgICAgICAgICAgY29uc3QgUE9XXzJfMTI4ID0gQmlnSW50KCcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpOyAvLyAoMm4qKjEyOG4pLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgY29uc3QgYzEgPSBkaXZOZWFyZXN0KGIyICogaywgbik7XG4gICAgICAgICAgICBjb25zdCBjMiA9IGRpdk5lYXJlc3QoLWIxICogaywgbik7XG4gICAgICAgICAgICBsZXQgazEgPSBtb2QoayAtIGMxICogYTEgLSBjMiAqIGEyLCBuKTtcbiAgICAgICAgICAgIGxldCBrMiA9IG1vZCgtYzEgKiBiMSAtIGMyICogYjIsIG4pO1xuICAgICAgICAgICAgY29uc3QgazFuZWcgPSBrMSA+IFBPV18yXzEyODtcbiAgICAgICAgICAgIGNvbnN0IGsybmVnID0gazIgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazEgPSBuIC0gazE7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazIgPSBuIC0gazI7XG4gICAgICAgICAgICBpZiAoazEgPiBQT1dfMl8xMjggfHwgazIgPiBQT1dfMl8xMjgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwbGl0U2NhbGFyOiBFbmRvbW9ycGhpc20gZmFpbGVkLCBrPScgKyBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH07XG4gICAgICAgIH0sXG4gICAgfSxcbn0sIHNoYTI1Nik7XG4vLyBTY2hub3JyIHNpZ25hdHVyZXMgYXJlIHN1cGVyaW9yIHRvIEVDRFNBIGZyb20gYWJvdmUuIEJlbG93IGlzIFNjaG5vcnItc3BlY2lmaWMgQklQMDM0MCBjb2RlLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IGZlID0gKHgpID0+IHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiBfMG4gPCB4ICYmIHggPCBzZWNwMjU2azFQO1xuY29uc3QgZ2UgPSAoeCkgPT4gdHlwZW9mIHggPT09ICdiaWdpbnQnICYmIF8wbiA8IHggJiYgeCA8IHNlY3AyNTZrMU47XG4vKiogQW4gb2JqZWN0IG1hcHBpbmcgdGFncyB0byB0aGVpciB0YWdnZWQgaGFzaCBwcmVmaXggb2YgW1NIQTI1Nih0YWcpIHwgU0hBMjU2KHRhZyldICovXG5jb25zdCBUQUdHRURfSEFTSF9QUkVGSVhFUyA9IHt9O1xuZnVuY3Rpb24gdGFnZ2VkSGFzaCh0YWcsIC4uLm1lc3NhZ2VzKSB7XG4gICAgbGV0IHRhZ1AgPSBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddO1xuICAgIGlmICh0YWdQID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdGFnSCA9IHNoYTI1NihVaW50OEFycmF5LmZyb20odGFnLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG4gICAgICAgIHRhZ1AgPSBjb25jYXRCeXRlcyh0YWdILCB0YWdIKTtcbiAgICAgICAgVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXSA9IHRhZ1A7XG4gICAgfVxuICAgIHJldHVybiBzaGEyNTYoY29uY2F0Qnl0ZXModGFnUCwgLi4ubWVzc2FnZXMpKTtcbn1cbi8vIEVDRFNBIGNvbXBhY3QgcG9pbnRzIGFyZSAzMy1ieXRlLiBTY2hub3JyIGlzIDMyOiB3ZSBzdHJpcCBmaXJzdCBieXRlIDB4MDIgb3IgMHgwM1xuY29uc3QgcG9pbnRUb0J5dGVzID0gKHBvaW50KSA9PiBwb2ludC50b1Jhd0J5dGVzKHRydWUpLnNsaWNlKDEpO1xuY29uc3QgbnVtVG8zMmIgPSAobikgPT4gbnVtYmVyVG9CeXRlc0JFKG4sIDMyKTtcbmNvbnN0IG1vZFAgPSAoeCkgPT4gbW9kKHgsIHNlY3AyNTZrMVApO1xuY29uc3QgbW9kTiA9ICh4KSA9PiBtb2QoeCwgc2VjcDI1NmsxTik7XG5jb25zdCBQb2ludCA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQ7XG5jb25zdCBHbXVsQWRkID0gKFEsIGEsIGIpID0+IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYik7XG4vLyBDYWxjdWxhdGUgcG9pbnQsIHNjYWxhciBhbmQgYnl0ZXNcbmZ1bmN0aW9uIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdikge1xuICAgIGxldCBkXyA9IHNlY3AyNTZrMS51dGlscy5ub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXYpOyAvLyBzYW1lIG1ldGhvZCBleGVjdXRlZCBpbiBmcm9tUHJpdmF0ZUtleVxuICAgIGxldCBwID0gUG9pbnQuZnJvbVByaXZhdGVLZXkoZF8pOyAvLyBQID0gZCfii4VHOyAwIDwgZCcgPCBuIGNoZWNrIGlzIGRvbmUgaW5zaWRlXG4gICAgY29uc3Qgc2NhbGFyID0gcC5oYXNFdmVuWSgpID8gZF8gOiBtb2ROKC1kXyk7XG4gICAgcmV0dXJuIHsgc2NhbGFyOiBzY2FsYXIsIGJ5dGVzOiBwb2ludFRvQnl0ZXMocCkgfTtcbn1cbi8qKlxuICogbGlmdF94IGZyb20gQklQMzQwLiBDb252ZXJ0IDMyLWJ5dGUgeCBjb29yZGluYXRlIHRvIGVsbGlwdGljIGN1cnZlIHBvaW50LlxuICogQHJldHVybnMgdmFsaWQgcG9pbnQgY2hlY2tlZCBmb3IgYmVpbmcgb24tY3VydmVcbiAqL1xuZnVuY3Rpb24gbGlmdF94KHgpIHtcbiAgICBpZiAoIWZlKHgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCB4OiBuZWVkIDAgPCB4IDwgcCcpOyAvLyBGYWlsIGlmIHgg4omlIHAuXG4gICAgY29uc3QgeHggPSBtb2RQKHggKiB4KTtcbiAgICBjb25zdCBjID0gbW9kUCh4eCAqIHggKyBCaWdJbnQoNykpOyAvLyBMZXQgYyA9IHjCsyArIDcgbW9kIHAuXG4gICAgbGV0IHkgPSBzcXJ0TW9kKGMpOyAvLyBMZXQgeSA9IGNeKHArMSkvNCBtb2QgcC5cbiAgICBpZiAoeSAlIF8ybiAhPT0gXzBuKVxuICAgICAgICB5ID0gbW9kUCgteSk7IC8vIFJldHVybiB0aGUgdW5pcXVlIHBvaW50IFAgc3VjaCB0aGF0IHgoUCkgPSB4IGFuZFxuICAgIGNvbnN0IHAgPSBuZXcgUG9pbnQoeCwgeSwgXzFuKTsgLy8geShQKSA9IHkgaWYgeSBtb2QgMiA9IDAgb3IgeShQKSA9IHAteSBvdGhlcndpc2UuXG4gICAgcC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIHJldHVybiBwO1xufVxuLyoqXG4gKiBDcmVhdGUgdGFnZ2VkIGhhc2gsIGNvbnZlcnQgaXQgdG8gYmlnaW50LCByZWR1Y2UgbW9kdWxvLW4uXG4gKi9cbmZ1bmN0aW9uIGNoYWxsZW5nZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG1vZE4oYnl0ZXNUb051bWJlckJFKHRhZ2dlZEhhc2goJ0JJUDAzNDAvY2hhbGxlbmdlJywgLi4uYXJncykpKTtcbn1cbi8qKlxuICogU2Nobm9yciBwdWJsaWMga2V5IGlzIGp1c3QgYHhgIGNvb3JkaW5hdGUgb2YgUG9pbnQgYXMgcGVyIEJJUDM0MC5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yckdldFB1YmxpY0tleShwcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdmF0ZUtleSkuYnl0ZXM7IC8vIGQnPWludChzaykuIEZhaWwgaWYgZCc9MCBvciBkJ+KJpW4uIFJldCBieXRlcyhkJ+KLhUcpXG59XG4vKipcbiAqIENyZWF0ZXMgU2Nobm9yciBzaWduYXR1cmUgYXMgcGVyIEJJUDM0MC4gVmVyaWZpZXMgaXRzZWxmIGJlZm9yZSByZXR1cm5pbmcgYW55dGhpbmcuXG4gKiBhdXhSYW5kIGlzIG9wdGlvbmFsIGFuZCBpcyBub3QgdGhlIHNvbGUgc291cmNlIG9mIGsgZ2VuZXJhdGlvbjogYmFkIENTUFJORyB3b24ndCBiZSBkYW5nZXJvdXMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJTaWduKG1lc3NhZ2UsIHByaXZhdGVLZXksIGF1eFJhbmQgPSByYW5kb21CeXRlcygzMikpIHtcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCB7IGJ5dGVzOiBweCwgc2NhbGFyOiBkIH0gPSBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpOyAvLyBjaGVja3MgZm9yIGlzV2l0aGluQ3VydmVPcmRlclxuICAgIGNvbnN0IGEgPSBlbnN1cmVCeXRlcygnYXV4UmFuZCcsIGF1eFJhbmQsIDMyKTsgLy8gQXV4aWxpYXJ5IHJhbmRvbSBkYXRhIGE6IGEgMzItYnl0ZSBhcnJheVxuICAgIGNvbnN0IHQgPSBudW1UbzMyYihkIF4gYnl0ZXNUb051bWJlckJFKHRhZ2dlZEhhc2goJ0JJUDAzNDAvYXV4JywgYSkpKTsgLy8gTGV0IHQgYmUgdGhlIGJ5dGUtd2lzZSB4b3Igb2YgYnl0ZXMoZCkgYW5kIGhhc2gvYXV4KGEpXG4gICAgY29uc3QgcmFuZCA9IHRhZ2dlZEhhc2goJ0JJUDAzNDAvbm9uY2UnLCB0LCBweCwgbSk7IC8vIExldCByYW5kID0gaGFzaC9ub25jZSh0IHx8IGJ5dGVzKFApIHx8IG0pXG4gICAgY29uc3Qga18gPSBtb2ROKGJ5dGVzVG9OdW1iZXJCRShyYW5kKSk7IC8vIExldCBrJyA9IGludChyYW5kKSBtb2QgblxuICAgIGlmIChrXyA9PT0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24gZmFpbGVkOiBrIGlzIHplcm8nKTsgLy8gRmFpbCBpZiBrJyA9IDAuXG4gICAgY29uc3QgeyBieXRlczogcngsIHNjYWxhcjogayB9ID0gc2Nobm9yckdldEV4dFB1YktleShrXyk7IC8vIExldCBSID0gayfii4VHLlxuICAgIGNvbnN0IGUgPSBjaGFsbGVuZ2UocngsIHB4LCBtKTsgLy8gTGV0IGUgPSBpbnQoaGFzaC9jaGFsbGVuZ2UoYnl0ZXMoUikgfHwgYnl0ZXMoUCkgfHwgbSkpIG1vZCBuLlxuICAgIGNvbnN0IHNpZyA9IG5ldyBVaW50OEFycmF5KDY0KTsgLy8gTGV0IHNpZyA9IGJ5dGVzKFIpIHx8IGJ5dGVzKChrICsgZWQpIG1vZCBuKS5cbiAgICBzaWcuc2V0KHJ4LCAwKTtcbiAgICBzaWcuc2V0KG51bVRvMzJiKG1vZE4oayArIGUgKiBkKSksIDMyKTtcbiAgICAvLyBJZiBWZXJpZnkoYnl0ZXMoUCksIG0sIHNpZykgKHNlZSBiZWxvdykgcmV0dXJucyBmYWlsdXJlLCBhYm9ydFxuICAgIGlmICghc2Nobm9yclZlcmlmeShzaWcsIG0sIHB4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduOiBJbnZhbGlkIHNpZ25hdHVyZSBwcm9kdWNlZCcpO1xuICAgIHJldHVybiBzaWc7XG59XG4vKipcbiAqIFZlcmlmaWVzIFNjaG5vcnIgc2lnbmF0dXJlLlxuICogV2lsbCBzd2FsbG93IGVycm9ycyAmIHJldHVybiBmYWxzZSBleGNlcHQgZm9yIGluaXRpYWwgdHlwZSB2YWxpZGF0aW9uIG9mIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yclZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSkge1xuICAgIGNvbnN0IHNpZyA9IGVuc3VyZUJ5dGVzKCdzaWduYXR1cmUnLCBzaWduYXR1cmUsIDY0KTtcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCBwdWIgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5LCAzMik7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgUCA9IGxpZnRfeChieXRlc1RvTnVtYmVyQkUocHViKSk7IC8vIFAgPSBsaWZ0X3goaW50KHBrKSk7IGZhaWwgaWYgdGhhdCBmYWlsc1xuICAgICAgICBjb25zdCByID0gYnl0ZXNUb051bWJlckJFKHNpZy5zdWJhcnJheSgwLCAzMikpOyAvLyBMZXQgciA9IGludChzaWdbMDozMl0pOyBmYWlsIGlmIHIg4omlIHAuXG4gICAgICAgIGlmICghZmUocikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHMgPSBieXRlc1RvTnVtYmVyQkUoc2lnLnN1YmFycmF5KDMyLCA2NCkpOyAvLyBMZXQgcyA9IGludChzaWdbMzI6NjRdKTsgZmFpbCBpZiBzIOKJpSBuLlxuICAgICAgICBpZiAoIWdlKHMpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBlID0gY2hhbGxlbmdlKG51bVRvMzJiKHIpLCBwb2ludFRvQnl0ZXMoUCksIG0pOyAvLyBpbnQoY2hhbGxlbmdlKGJ5dGVzKHIpfHxieXRlcyhQKXx8bSkpJW5cbiAgICAgICAgY29uc3QgUiA9IEdtdWxBZGQoUCwgcywgbW9kTigtZSkpOyAvLyBSID0gc+KLhUcgLSBl4ouFUFxuICAgICAgICBpZiAoIVIgfHwgIVIuaGFzRXZlblkoKSB8fCBSLnRvQWZmaW5lKCkueCAhPT0gcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gLWVQID09IChuLWUpUFxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gRmFpbCBpZiBpc19pbmZpbml0ZShSKSAvIG5vdCBoYXNfZXZlbl95KFIpIC8geChSKSDiiaAgci5cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnQgY29uc3Qgc2Nobm9yciA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gKHtcbiAgICBnZXRQdWJsaWNLZXk6IHNjaG5vcnJHZXRQdWJsaWNLZXksXG4gICAgc2lnbjogc2Nobm9yclNpZ24sXG4gICAgdmVyaWZ5OiBzY2hub3JyVmVyaWZ5LFxuICAgIHV0aWxzOiB7XG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6IHNlY3AyNTZrMS51dGlscy5yYW5kb21Qcml2YXRlS2V5LFxuICAgICAgICBsaWZ0X3gsXG4gICAgICAgIHBvaW50VG9CeXRlcyxcbiAgICAgICAgbnVtYmVyVG9CeXRlc0JFLFxuICAgICAgICBieXRlc1RvTnVtYmVyQkUsXG4gICAgICAgIHRhZ2dlZEhhc2gsXG4gICAgICAgIG1vZCxcbiAgICB9LFxufSkpKCk7XG5jb25zdCBpc29NYXAgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGlzb2dlbnlNYXAoRnAsIFtcbiAgICAvLyB4TnVtXG4gICAgW1xuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhOGM3JyxcbiAgICAgICAgJzB4N2QzZDRjODBiYzMyMWQ1YjlmMzE1Y2VhN2ZkNDRjNWQ1OTVkMmZjMGJmNjNiOTJkZmZmMTA0NGYxN2M2NTgxJyxcbiAgICAgICAgJzB4NTM0YzMyOGQyM2YyMzRlNmUyYTQxM2RlY2EyNWNhZWNlNDUwNjE0NDAzN2M0MDMxNGVjYmQwYjUzZDlkZDI2MicsXG4gICAgICAgICcweDhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhkYWFhYWE4OGMnLFxuICAgIF0sXG4gICAgLy8geERlblxuICAgIFtcbiAgICAgICAgJzB4ZDM1NzcxMTkzZDk0OTE4YTljYTM0Y2NiYjdiNjQwZGQ4NmNkNDA5NTQyZjg0ODdkOWZlNmI3NDU3ODFlYjQ5YicsXG4gICAgICAgICcweGVkYWRjNmY2NDM4M2RjMWRmN2M0YjJkNTFiNTQyMjU0MDZkMzZiNjQxZjVlNDFiYmM1MmE1NjYxMmE4YzZkMTQnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbiAgICAvLyB5TnVtXG4gICAgW1xuICAgICAgICAnMHg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YjhlMzhlMjNjJyxcbiAgICAgICAgJzB4Yzc1ZTBjMzJkNWNiN2MwZmE5ZDBhNTRiMTJhMGE2ZDU2NDdhYjA0NmQ2ODZkYTZmZGZmYzkwZmMyMDFkNzFhMycsXG4gICAgICAgICcweDI5YTYxOTQ2OTFmOTFhNzM3MTUyMDllZjY1MTJlNTc2NzIyODMwYTIwMWJlMjAxOGE3NjVlODVhOWVjZWU5MzEnLFxuICAgICAgICAnMHgyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjM4ZTM4ZDg0JyxcbiAgICBdLFxuICAgIC8vIHlEZW5cbiAgICBbXG4gICAgICAgICcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmY5M2InLFxuICAgICAgICAnMHg3YTA2NTM0YmI4YmRiNDlmZDVlOWU2NjMyNzIyYzI5ODk0NjdjMWJmYzhlOGQ5NzhkZmI0MjVkMjY4NWMyNTczJyxcbiAgICAgICAgJzB4NjQ4NGFhNzE2NTQ1Y2EyY2YzYTcwYzNmYThmZTMzN2UwYTNkMjExNjJmMGQ2Mjk5YTdiZjgxOTJiZmQyYTc2ZicsXG4gICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcbiAgICBdLFxuXS5tYXAoKGkpID0+IGkubWFwKChqKSA9PiBCaWdJbnQoaikpKSkpKCk7XG5jb25zdCBtYXBTV1UgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIHtcbiAgICBBOiBCaWdJbnQoJzB4M2Y4NzMxYWJkZDY2MWFkY2EwOGE1NTU4ZjBmNWQyNzJlOTUzZDM2M2NiNmYwZTVkNDA1NDQ3YzAxYTQ0NDUzMycpLFxuICAgIEI6IEJpZ0ludCgnMTc3MScpLFxuICAgIFo6IEZwLmNyZWF0ZShCaWdJbnQoJy0xMScpKSxcbn0pKSgpO1xuY29uc3QgaHRmID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBjcmVhdGVIYXNoZXIoc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludCwgKHNjYWxhcnMpID0+IHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IG1hcFNXVShGcC5jcmVhdGUoc2NhbGFyc1swXSkpO1xuICAgIHJldHVybiBpc29NYXAoeCwgeSk7XG59LCB7XG4gICAgRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfUk9fJyxcbiAgICBlbmNvZGVEU1Q6ICdzZWNwMjU2azFfWE1EOlNIQS0yNTZfU1NXVV9OVV8nLFxuICAgIHA6IEZwLk9SREVSLFxuICAgIG06IDEsXG4gICAgazogMTI4LFxuICAgIGV4cGFuZDogJ3htZCcsXG4gICAgaGFzaDogc2hhMjU2LFxufSkpKCk7XG5leHBvcnQgY29uc3QgaGFzaFRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGh0Zi5oYXNoVG9DdXJ2ZSkoKTtcbmV4cG9ydCBjb25zdCBlbmNvZGVUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBodGYuZW5jb2RlVG9DdXJ2ZSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlY3AyNTZrMS5qcy5tYXAiXSwibmFtZXMiOlsic2hhMjU2IiwicmFuZG9tQnl0ZXMiLCJGaWVsZCIsIm1vZCIsInBvdzIiLCJtYXBUb0N1cnZlU2ltcGxlU1dVIiwiYnl0ZXNUb051bWJlckJFIiwiY29uY2F0Qnl0ZXMiLCJlbnN1cmVCeXRlcyIsIm51bWJlclRvQnl0ZXNCRSIsImNyZWF0ZUhhc2hlciIsImlzb2dlbnlNYXAiLCJjcmVhdGVDdXJ2ZSIsInNlY3AyNTZrMVAiLCJCaWdJbnQiLCJzZWNwMjU2azFOIiwiXzFuIiwiXzJuIiwiZGl2TmVhcmVzdCIsImEiLCJiIiwic3FydE1vZCIsInkiLCJQIiwiXzNuIiwiXzZuIiwiXzExbiIsIl8yMm4iLCJfMjNuIiwiXzQ0biIsIl84OG4iLCJiMiIsImIzIiwiYjYiLCJiOSIsImIxMSIsImIyMiIsImI0NCIsImI4OCIsImIxNzYiLCJiMjIwIiwiYjIyMyIsInQxIiwidDIiLCJyb290IiwiRnAiLCJlcWwiLCJzcXIiLCJFcnJvciIsInVuZGVmaW5lZCIsInNxcnQiLCJzZWNwMjU2azEiLCJuIiwiR3giLCJHeSIsImgiLCJsb3dTIiwiZW5kbyIsImJldGEiLCJzcGxpdFNjYWxhciIsImsiLCJhMSIsImIxIiwiYTIiLCJQT1dfMl8xMjgiLCJjMSIsImMyIiwiazEiLCJrMiIsImsxbmVnIiwiazJuZWciLCJfMG4iLCJmZSIsIngiLCJnZSIsIlRBR0dFRF9IQVNIX1BSRUZJWEVTIiwidGFnZ2VkSGFzaCIsInRhZyIsIm1lc3NhZ2VzIiwidGFnUCIsInRhZ0giLCJVaW50OEFycmF5IiwiZnJvbSIsImMiLCJjaGFyQ29kZUF0IiwicG9pbnRUb0J5dGVzIiwicG9pbnQiLCJ0b1Jhd0J5dGVzIiwic2xpY2UiLCJudW1UbzMyYiIsIm1vZFAiLCJtb2ROIiwiUG9pbnQiLCJQcm9qZWN0aXZlUG9pbnQiLCJHbXVsQWRkIiwiUSIsIkJBU0UiLCJtdWx0aXBseUFuZEFkZFVuc2FmZSIsInNjaG5vcnJHZXRFeHRQdWJLZXkiLCJwcml2IiwiZF8iLCJ1dGlscyIsIm5vcm1Qcml2YXRlS2V5VG9TY2FsYXIiLCJwIiwiZnJvbVByaXZhdGVLZXkiLCJzY2FsYXIiLCJoYXNFdmVuWSIsImJ5dGVzIiwibGlmdF94IiwieHgiLCJhc3NlcnRWYWxpZGl0eSIsImNoYWxsZW5nZSIsImFyZ3MiLCJzY2hub3JyR2V0UHVibGljS2V5IiwicHJpdmF0ZUtleSIsInNjaG5vcnJTaWduIiwibWVzc2FnZSIsImF1eFJhbmQiLCJtIiwicHgiLCJkIiwidCIsInJhbmQiLCJrXyIsInJ4IiwiZSIsInNpZyIsInNldCIsInNjaG5vcnJWZXJpZnkiLCJzaWduYXR1cmUiLCJwdWJsaWNLZXkiLCJwdWIiLCJyIiwic3ViYXJyYXkiLCJzIiwiUiIsInRvQWZmaW5lIiwiZXJyb3IiLCJzY2hub3JyIiwiZ2V0UHVibGljS2V5Iiwic2lnbiIsInZlcmlmeSIsInJhbmRvbVByaXZhdGVLZXkiLCJpc29NYXAiLCJtYXAiLCJpIiwiaiIsIm1hcFNXVSIsIkEiLCJCIiwiWiIsImNyZWF0ZSIsImh0ZiIsInNjYWxhcnMiLCJEU1QiLCJlbmNvZGVEU1QiLCJPUkRFUiIsImV4cGFuZCIsImhhc2giLCJoYXNoVG9DdXJ2ZSIsImVuY29kZVRvQ3VydmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/esm/secp256k1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/_assert.js":
/*!***************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_assert.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0) throw new Error(`positive integer expected, not ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== \"boolean\") throw new Error(`boolean expected, not ${b}`);\n}\n// copied from utils\nfunction isBytes(a) {\n    return a instanceof Uint8Array || a != null && typeof a === \"object\" && a.constructor.name === \"Uint8Array\";\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b)) throw new Error(\"Uint8Array expected\");\n    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(h) {\n    if (typeof h !== \"function\" || typeof h.create !== \"function\") throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n    number(h.outputLen);\n    number(h.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed) throw new Error(\"Hash instance has been destroyed\");\n    if (checkFinished && instance.finished) throw new Error(\"Hash#digest() has already been called\");\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = {\n    number,\n    bool,\n    bytes,\n    hash,\n    exists,\n    output\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert); //# sourceMappingURL=_assert.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX2Fzc2VydC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLFNBQVNBLE9BQU9DLENBQUM7SUFDYixJQUFJLENBQUNDLE9BQU9DLGFBQWEsQ0FBQ0YsTUFBTUEsSUFBSSxHQUNoQyxNQUFNLElBQUlHLE1BQU0sQ0FBQywrQkFBK0IsRUFBRUgsRUFBRSxDQUFDO0FBQzdEO0FBQ0EsU0FBU0ksS0FBS0MsQ0FBQztJQUNYLElBQUksT0FBT0EsTUFBTSxXQUNiLE1BQU0sSUFBSUYsTUFBTSxDQUFDLHNCQUFzQixFQUFFRSxFQUFFLENBQUM7QUFDcEQ7QUFDQSxvQkFBb0I7QUFDYixTQUFTQyxRQUFRQyxDQUFDO0lBQ3JCLE9BQVFBLGFBQWFDLGNBQ2hCRCxLQUFLLFFBQVEsT0FBT0EsTUFBTSxZQUFZQSxFQUFFRSxXQUFXLENBQUNDLElBQUksS0FBSztBQUN0RTtBQUNBLFNBQVNDLE1BQU1OLENBQUMsRUFBRSxHQUFHTyxPQUFPO0lBQ3hCLElBQUksQ0FBQ04sUUFBUUQsSUFDVCxNQUFNLElBQUlGLE1BQU07SUFDcEIsSUFBSVMsUUFBUUMsTUFBTSxHQUFHLEtBQUssQ0FBQ0QsUUFBUUUsUUFBUSxDQUFDVCxFQUFFUSxNQUFNLEdBQ2hELE1BQU0sSUFBSVYsTUFBTSxDQUFDLDhCQUE4QixFQUFFUyxRQUFRLGdCQUFnQixFQUFFUCxFQUFFUSxNQUFNLENBQUMsQ0FBQztBQUM3RjtBQUNBLFNBQVNFLEtBQUtDLENBQUM7SUFDWCxJQUFJLE9BQU9BLE1BQU0sY0FBYyxPQUFPQSxFQUFFQyxNQUFNLEtBQUssWUFDL0MsTUFBTSxJQUFJZCxNQUFNO0lBQ3BCSixPQUFPaUIsRUFBRUUsU0FBUztJQUNsQm5CLE9BQU9pQixFQUFFRyxRQUFRO0FBQ3JCO0FBQ0EsU0FBU0MsT0FBT0MsUUFBUSxFQUFFQyxnQkFBZ0IsSUFBSTtJQUMxQyxJQUFJRCxTQUFTRSxTQUFTLEVBQ2xCLE1BQU0sSUFBSXBCLE1BQU07SUFDcEIsSUFBSW1CLGlCQUFpQkQsU0FBU0csUUFBUSxFQUNsQyxNQUFNLElBQUlyQixNQUFNO0FBQ3hCO0FBQ0EsU0FBU3NCLE9BQU9DLEdBQUcsRUFBRUwsUUFBUTtJQUN6QlYsTUFBTWU7SUFDTixNQUFNQyxNQUFNTixTQUFTSCxTQUFTO0lBQzlCLElBQUlRLElBQUliLE1BQU0sR0FBR2MsS0FBSztRQUNsQixNQUFNLElBQUl4QixNQUFNLENBQUMsc0RBQXNELEVBQUV3QixJQUFJLENBQUM7SUFDbEY7QUFDSjtBQUNxRDtBQUNyRCxNQUFNQyxTQUFTO0lBQUU3QjtJQUFRSztJQUFNTztJQUFPSTtJQUFNSztJQUFRSztBQUFPO0FBQzNELGlFQUFlRyxNQUFNQSxFQUFDLENBQ3RCLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NmYXBwLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanM/MjcwZSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcG9zaXRpdmUgaW50ZWdlciBleHBlY3RlZCwgbm90ICR7bn1gKTtcbn1cbmZ1bmN0aW9uIGJvb2woYikge1xuICAgIGlmICh0eXBlb2YgYiAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJvb2xlYW4gZXhwZWN0ZWQsIG5vdCAke2J9YCk7XG59XG4vLyBjb3BpZWQgZnJvbSB1dGlsc1xuZXhwb3J0IGZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIWlzQnl0ZXMoYikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVpbnQ4QXJyYXkgZXhwZWN0ZWQgb2YgbGVuZ3RoICR7bGVuZ3Roc30sIG5vdCBvZiBsZW5ndGg9JHtiLmxlbmd0aH1gKTtcbn1cbmZ1bmN0aW9uIGhhc2goaCkge1xuICAgIGlmICh0eXBlb2YgaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3InKTtcbiAgICBudW1iZXIoaC5vdXRwdXRMZW4pO1xuICAgIG51bWJlcihoLmJsb2NrTGVuKTtcbn1cbmZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZnVuY3Rpb24gb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7bWlufWApO1xuICAgIH1cbn1cbmV4cG9ydCB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5jb25zdCBhc3NlcnQgPSB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5leHBvcnQgZGVmYXVsdCBhc3NlcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXNzZXJ0LmpzLm1hcCJdLCJuYW1lcyI6WyJudW1iZXIiLCJuIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIkVycm9yIiwiYm9vbCIsImIiLCJpc0J5dGVzIiwiYSIsIlVpbnQ4QXJyYXkiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJieXRlcyIsImxlbmd0aHMiLCJsZW5ndGgiLCJpbmNsdWRlcyIsImhhc2giLCJoIiwiY3JlYXRlIiwib3V0cHV0TGVuIiwiYmxvY2tMZW4iLCJleGlzdHMiLCJpbnN0YW5jZSIsImNoZWNrRmluaXNoZWQiLCJkZXN0cm95ZWQiLCJmaW5pc2hlZCIsIm91dHB1dCIsIm91dCIsIm1pbiIsImFzc2VydCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/_assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/_md.js":
/*!***********************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_md.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chi: () => (/* binding */ Chi),\n/* harmony export */   HashMD: () => (/* binding */ HashMD),\n/* harmony export */   Maj: () => (/* binding */ Maj)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === \"function\") return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number(value >> _32n & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Choice: a ? b : c\nconst Chi = (a, b, c)=>a & b ^ ~a & c;\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c)=>a & b ^ a & c ^ b & c;\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */ class HashMD extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE){\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 128;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for(let i = pos; i < blockLen; i++)buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4) throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length) throw new Error(\"_sha2: outputLen bigger than state\");\n        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen) to.buffer.set(buffer);\n        return to;\n    }\n} //# sourceMappingURL=_md.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX21kLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQThDO0FBQ1M7QUFDdkQseUJBQXlCO0FBQ3pCLFNBQVNLLGFBQWFDLElBQUksRUFBRUMsVUFBVSxFQUFFQyxLQUFLLEVBQUVDLElBQUk7SUFDL0MsSUFBSSxPQUFPSCxLQUFLRCxZQUFZLEtBQUssWUFDN0IsT0FBT0MsS0FBS0QsWUFBWSxDQUFDRSxZQUFZQyxPQUFPQztJQUNoRCxNQUFNQyxPQUFPQyxPQUFPO0lBQ3BCLE1BQU1DLFdBQVdELE9BQU87SUFDeEIsTUFBTUUsS0FBS0MsT0FBTyxTQUFVSixPQUFRRTtJQUNwQyxNQUFNRyxLQUFLRCxPQUFPTixRQUFRSTtJQUMxQixNQUFNSSxJQUFJUCxPQUFPLElBQUk7SUFDckIsTUFBTVEsSUFBSVIsT0FBTyxJQUFJO0lBQ3JCSCxLQUFLWSxTQUFTLENBQUNYLGFBQWFTLEdBQUdILElBQUlKO0lBQ25DSCxLQUFLWSxTQUFTLENBQUNYLGFBQWFVLEdBQUdGLElBQUlOO0FBQ3ZDO0FBQ0Esb0JBQW9CO0FBQ2IsTUFBTVUsTUFBTSxDQUFDQyxHQUFHQyxHQUFHQyxJQUFNLElBQUtELElBQU0sQ0FBQ0QsSUFBSUUsRUFBRztBQUNuRCxvREFBb0Q7QUFDN0MsTUFBTUMsTUFBTSxDQUFDSCxHQUFHQyxHQUFHQyxJQUFNLElBQUtELElBQU1ELElBQUlFLElBQU1ELElBQUlDLEVBQUc7QUFDNUQ7OztDQUdDLEdBQ00sTUFBTUUsZUFBZXRCLDJDQUFJQTtJQUM1QnVCLFlBQVlDLFFBQVEsRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQUVuQixJQUFJLENBQUU7UUFDOUMsS0FBSztRQUNMLElBQUksQ0FBQ2lCLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDQyxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ0MsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNuQixJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFD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QixJQUFJRixTQUFTQyxNQUFNdkIsTUFBTSxFQUNyQixNQUFNLElBQUlxQixNQUFNO1FBQ3BCLElBQUssSUFBSUYsSUFBSSxHQUFHQSxJQUFJRyxRQUFRSCxJQUN4QkMsTUFBTWhDLFNBQVMsQ0FBQyxJQUFJK0IsR0FBR0ksS0FBSyxDQUFDSixFQUFFLEVBQUV4QztJQUN6QztJQUNBOEMsU0FBUztRQUNMLE1BQU0sRUFBRXRCLE1BQU0sRUFBRU4sU0FBUyxFQUFFLEdBQUcsSUFBSTtRQUNsQyxJQUFJLENBQUNtQixVQUFVLENBQUNiO1FBQ2hCLE1BQU11QixNQUFNdkIsT0FBT3dCLEtBQUssQ0FBQyxHQUFHOUI7UUFDNUIsSUFBSSxDQUFDK0IsT0FBTztRQUNaLE9BQU9GO0lBQ1g7SUFDQUcsV0FBV0MsRUFBRSxFQUFFO1FBQ1hBLE1BQU9BLENBQUFBLEtBQUssSUFBSSxJQUFJLENBQUNuQyxXQUFXLEVBQUM7UUFDakNtQyxHQUFHakIsR0FBRyxJQUFJLElBQUksQ0FBQ1csR0FBRztRQUNsQixNQUFNLEVBQUU1QixRQUFRLEVBQUVPLE1BQU0sRUFBRUgsTUFBTSxFQUFFRCxRQUFRLEVBQUVHLFNBQVMsRUFBRUQsR0FBRyxFQUFFLEdBQUcsSUFBSTtRQUNuRTZCLEdBQUc5QixNQUFNLEdBQUdBO1FBQ1o4QixHQUFHN0IsR0FBRyxHQUFHQTtRQUNUNkIsR0FBRy9CLFFBQVEsR0FBR0E7UUFDZCtCLEdBQUc1QixTQUFTLEdBQUdBO1FBQ2YsSUFBSUYsU0FBU0osVUFDVGtDLEdBQUczQixNQUFNLENBQUNVLEdBQUcsQ0FBQ1Y7UUFDbEIsT0FBTzJCO0lBQ1g7QUFDSixFQUNBLCtCQUErQiIsInNvdXJjZXMiOlsid2VicGFjazovL2NmYXBwLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19tZC5qcz9hMDg3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV4aXN0cywgb3V0cHV0IH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIGNyZWF0ZVZpZXcsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFBvbHlmaWxsIGZvciBTYWZhcmkgMTRcbmZ1bmN0aW9uIHNldEJpZ1VpbnQ2NCh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSkge1xuICAgIGlmICh0eXBlb2Ygdmlldy5zZXRCaWdVaW50NjQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB2aWV3LnNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSk7XG4gICAgY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4gICAgY29uc3QgX3UzMl9tYXggPSBCaWdJbnQoMHhmZmZmZmZmZik7XG4gICAgY29uc3Qgd2ggPSBOdW1iZXIoKHZhbHVlID4+IF8zMm4pICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IHdsID0gTnVtYmVyKHZhbHVlICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IGggPSBpc0xFID8gNCA6IDA7XG4gICAgY29uc3QgbCA9IGlzTEUgPyAwIDogNDtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgaCwgd2gsIGlzTEUpO1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBsLCB3bCwgaXNMRSk7XG59XG4vLyBDaG9pY2U6IGEgPyBiIDogY1xuZXhwb3J0IGNvbnN0IENoaSA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKH5hICYgYyk7XG4vLyBNYWpvcml0eSBmdW5jdGlvbiwgdHJ1ZSBpZiBhbnkgdHdvIGlucHVzdCBpcyB0cnVlXG5leHBvcnQgY29uc3QgTWFqID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbi8qKlxuICogTWVya2xlLURhbWdhcmQgaGFzaCBjb25zdHJ1Y3Rpb24gYmFzZSBjbGFzcy5cbiAqIENvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIE1ENSwgUklQRU1ELCBTSEExLCBTSEEyLlxuICovXG5leHBvcnQgY2xhc3MgSGFzaE1EIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIG91dHB1dExlbiwgcGFkT2Zmc2V0LCBpc0xFKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMucGFkT2Zmc2V0ID0gcGFkT2Zmc2V0O1xuICAgICAgICB0aGlzLmlzTEUgPSBpc0xFO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgdGhpcy52aWV3ID0gY3JlYXRlVmlldyh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dCwgY2FzdCBpdCB0byB2aWV3IGFuZCBwcm9jZXNzXG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9IGNyZWF0ZVZpZXcoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMpO1xuICAgICAgICBvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXG4gICAgICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XG4gICAgICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW5cbiAgICAgICAgLy8gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMucGFkT2Zmc2V0ID4gYmxvY2tMZW4gLSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxuICAgICAgICAgICAgYnVmZmVyW2ldID0gMDtcbiAgICAgICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuICAgICAgICAvLyBTbyB3ZSBqdXN0IHdyaXRlIGxvd2VzdCA2NCBiaXRzIG9mIHRoYXQgdmFsdWUuXG4gICAgICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICBjb25zdCBvdmlldyA9IGNyZWF0ZVZpZXcob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fbWQuanMubWFwIl0sIm5hbWVzIjpbImV4aXN0cyIsIm91dHB1dCIsIkhhc2giLCJjcmVhdGVWaWV3IiwidG9CeXRlcyIsInNldEJpZ1VpbnQ2NCIsInZpZXciLCJieXRlT2Zmc2V0IiwidmFsdWUiLCJpc0xFIiwiXzMybiIsIkJpZ0ludCIsIl91MzJfbWF4Iiwid2giLCJOdW1iZXIiLCJ3bCIsImgiLCJsIiwic2V0VWludDMyIiwiQ2hpIiwiYSIsImIiLCJjIiwiTWFqIiwiSGFzaE1EIiwiY29uc3RydWN0b3IiLCJibG9ja0xlbiIsIm91dHB1dExlbiIsInBhZE9mZnNldCIsImZpbmlzaGVkIiwibGVuZ3RoIiwicG9zIiwiZGVzdHJveWVkIiwiYnVmZmVyIiwiVWludDhBcnJheSIsInVwZGF0ZSIsImRhdGEiLCJsZW4iLCJ0YWtlIiwiTWF0aCIsIm1pbiIsImRhdGFWaWV3IiwicHJvY2VzcyIsInNldCIsInN1YmFycmF5Iiwicm91bmRDbGVhbiIsImRpZ2VzdEludG8iLCJvdXQiLCJmaWxsIiwiaSIsIm92aWV3IiwiRXJyb3IiLCJvdXRMZW4iLCJzdGF0ZSIsImdldCIsImRpZ2VzdCIsInJlcyIsInNsaWNlIiwiZGVzdHJveSIsIl9jbG9uZUludG8iLCJ0byJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/_md.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/_u64.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_u64.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   add3H: () => (/* binding */ add3H),\n/* harmony export */   add3L: () => (/* binding */ add3L),\n/* harmony export */   add4H: () => (/* binding */ add4H),\n/* harmony export */   add4L: () => (/* binding */ add4L),\n/* harmony export */   add5H: () => (/* binding */ add5H),\n/* harmony export */   add5L: () => (/* binding */ add5L),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   rotlBH: () => (/* binding */ rotlBH),\n/* harmony export */   rotlBL: () => (/* binding */ rotlBL),\n/* harmony export */   rotlSH: () => (/* binding */ rotlSH),\n/* harmony export */   rotlSL: () => (/* binding */ rotlSL),\n/* harmony export */   rotr32H: () => (/* binding */ rotr32H),\n/* harmony export */   rotr32L: () => (/* binding */ rotr32L),\n/* harmony export */   rotrBH: () => (/* binding */ rotrBH),\n/* harmony export */   rotrBL: () => (/* binding */ rotrBL),\n/* harmony export */   rotrSH: () => (/* binding */ rotrSH),\n/* harmony export */   rotrSL: () => (/* binding */ rotrSL),\n/* harmony export */   shrSH: () => (/* binding */ shrSH),\n/* harmony export */   shrSL: () => (/* binding */ shrSL),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le) return {\n        h: Number(n & U32_MASK64),\n        l: Number(n >> _32n & U32_MASK64)\n    };\n    return {\n        h: Number(n >> _32n & U32_MASK64) | 0,\n        l: Number(n & U32_MASK64) | 0\n    };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for(let i = 0; i < lst.length; i++){\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [\n            h,\n            l\n        ];\n    }\n    return [\n        Ah,\n        Al\n    ];\n}\nconst toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s)=>h >>> s;\nconst shrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s)=>h >>> s | l << 32 - s;\nconst rotrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;\nconst rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l)=>l;\nconst rotr32L = (h, _l)=>h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s)=>h << s | l >>> 32 - s;\nconst rotlSL = (h, l, s)=>l << s | h >>> 32 - s;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;\nconst rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return {\n        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,\n        l: l | 0\n    };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;\nconst add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig,\n    split,\n    toBig,\n    shrSH,\n    shrSL,\n    rotrSH,\n    rotrSL,\n    rotrBH,\n    rotrBL,\n    rotr32H,\n    rotr32L,\n    rotlSH,\n    rotlSL,\n    rotlBH,\n    rotlBL,\n    add,\n    add3L,\n    add3H,\n    add4L,\n    add4H,\n    add5H,\n    add5L\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64); //# sourceMappingURL=_u64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3U2NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQU1BLGFBQWEsYUFBYSxHQUFHQyxPQUFPLEtBQUssS0FBSztBQUNwRCxNQUFNQyxPQUFPLGFBQWEsR0FBR0QsT0FBTztBQUNwQywrRUFBK0U7QUFDL0UsU0FBU0UsUUFBUUMsQ0FBQyxFQUFFQyxLQUFLLEtBQUs7SUFDMUIsSUFBSUEsSUFDQSxPQUFPO1FBQUVDLEdBQUdDLE9BQU9ILElBQUlKO1FBQWFRLEdBQUdELE9BQU8sS0FBTUwsT0FBUUY7SUFBWTtJQUM1RSxPQUFPO1FBQUVNLEdBQUdDLE9BQU8sS0FBTUwsT0FBUUYsY0FBYztRQUFHUSxHQUFHRCxPQUFPSCxJQUFJSixjQUFjO0lBQUU7QUFDcEY7QUFDQSxTQUFTUyxNQUFNQyxHQUFHLEVBQUVMLEtBQUssS0FBSztJQUMxQixJQUFJTSxLQUFLLElBQUlDLFlBQVlGLElBQUlHLE1BQU07SUFDbkMsSUFBSUMsS0FBSyxJQUFJRixZQUFZRixJQUFJRyxNQUFNO0lBQ25DLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJTCxJQUFJRyxNQUFNLEVBQUVFLElBQUs7UUFDakMsTUFBTSxFQUFFVCxDQUFDLEVBQUVFLENBQUMsRUFBRSxHQUFHTCxRQUFRTyxHQUFHLENBQUNLLEVBQUUsRUFBRVY7UUFDakMsQ0FBQ00sRUFBRSxDQUFDSSxFQUFFLEVBQUVELEVBQUUsQ0FBQ0MsRUFBRSxDQUFDLEdBQUc7WUFBQ1Q7WUFBR0U7U0FBRTtJQUMzQjtJQUNBLE9BQU87UUFBQ0c7UUFBSUc7S0FBRztBQUNuQjtBQUNBLE1BQU1FLFFBQVEsQ0FBQ1YsR0FBR0UsSUFBTSxPQUFRRixNQUFNLE1BQU1KLE9BQVFELE9BQU9PLE1BQU07QUFDakUsdUJBQXVCO0FBQ3ZCLE1BQU1TLFFBQVEsQ0FBQ1gsR0FBR1ksSUFBSUMsSUFBTWIsTUFBTWE7QUFDbEMsTUFBTUMsUUFBUSxDQUFDZCxHQUFHRSxHQUFHVyxJQUFNLEtBQU8sS0FBS0EsSUFBT1gsTUFBTVc7QUFDcEQsb0NBQW9DO0FBQ3BDLE1BQU1FLFNBQVMsQ0FBQ2YsR0FBR0UsR0FBR1csSUFBTSxNQUFPQSxJQUFNWCxLQUFNLEtBQUtXO0FBQ3BELE1BQU1HLFNBQVMsQ0FBQ2hCLEdBQUdFLEdBQUdXLElBQU0sS0FBTyxLQUFLQSxJQUFPWCxNQUFNVztBQUNyRCxnRUFBZ0U7QUFDaEUsTUFBTUksU0FBUyxDQUFDakIsR0FBR0UsR0FBR1csSUFBTSxLQUFPLEtBQUtBLElBQU9YLE1BQU9XLElBQUk7QUFDMUQsTUFBTUssU0FBUyxDQUFDbEIsR0FBR0UsR0FBR1csSUFBTSxNQUFRQSxJQUFJLEtBQVFYLEtBQU0sS0FBS1c7QUFDM0QsK0NBQStDO0FBQy9DLE1BQU1NLFVBQVUsQ0FBQ0MsSUFBSWxCLElBQU1BO0FBQzNCLE1BQU1tQixVQUFVLENBQUNyQixHQUFHWSxLQUFPWjtBQUMzQixtQ0FBbUM7QUFDbkMsTUFBTXNCLFNBQVMsQ0FBQ3RCLEdBQUdFLEdBQUdXLElBQU0sS0FBTUEsSUFBTVgsTUFBTyxLQUFLVztBQUNwRCxNQUFNVSxTQUFTLENBQUN2QixHQUFHRSxHQUFHVyxJQUFNLEtBQU1BLElBQU1iLE1BQU8sS0FBS2E7QUFDcEQsK0RBQStEO0FBQy9ELE1BQU1XLFNBQVMsQ0FBQ3hCLEdBQUdFLEdBQUdXLElBQU0sS0FBT0EsSUFBSSxLQUFRYixNQUFPLEtBQUthO0FBQzNELE1BQU1ZLFNBQVMsQ0FBQ3pCLEdBQUdFLEdBQUdXLElBQU0sS0FBT0EsSUFBSSxLQUFRWCxNQUFPLEtBQUtXO0FBQzNELDhFQUE4RTtBQUM5RSwwRUFBMEU7QUFDMUUsU0FBU2EsSUFBSXJCLEVBQUUsRUFBRUcsRUFBRSxFQUFFbUIsRUFBRSxFQUFFQyxFQUFFO0lBQ3ZCLE1BQU0xQixJQUFJLENBQUNNLE9BQU8sS0FBTW9CLENBQUFBLE9BQU87SUFDL0IsT0FBTztRQUFFNUIsR0FBRyxLQUFNMkIsS0FBTSxLQUFLLEtBQUssS0FBTSxLQUFNO1FBQUd6QixHQUFHQSxJQUFJO0lBQUU7QUFDOUQ7QUFDQSxxQ0FBcUM7QUFDckMsTUFBTTJCLFFBQVEsQ0FBQ3JCLElBQUlvQixJQUFJRSxLQUFPLENBQUN0QixPQUFPLEtBQU1vQixDQUFBQSxPQUFPLEtBQU1FLENBQUFBLE9BQU87QUFDaEUsTUFBTUMsUUFBUSxDQUFDQyxLQUFLM0IsSUFBSXNCLElBQUlNLEtBQU8sS0FBTU4sS0FBS00sS0FBTSxPQUFPLEtBQUssS0FBTSxLQUFNO0FBQzVFLE1BQU1DLFFBQVEsQ0FBQzFCLElBQUlvQixJQUFJRSxJQUFJSyxLQUFPLENBQUMzQixPQUFPLEtBQU1vQixDQUFBQSxPQUFPLEtBQU1FLENBQUFBLE9BQU8sS0FBTUssQ0FBQUEsT0FBTztBQUNqRixNQUFNQyxRQUFRLENBQUNKLEtBQUszQixJQUFJc0IsSUFBSU0sSUFBSUksS0FBTyxLQUFNVixLQUFLTSxLQUFLSSxLQUFNLE9BQU8sS0FBSyxLQUFNLEtBQU07QUFDckYsTUFBTUMsUUFBUSxDQUFDOUIsSUFBSW9CLElBQUlFLElBQUlLLElBQUlJLEtBQU8sQ0FBQy9CLE9BQU8sS0FBTW9CLENBQUFBLE9BQU8sS0FBTUUsQ0FBQUEsT0FBTyxLQUFNSyxDQUFBQSxPQUFPLEtBQU1JLENBQUFBLE9BQU87QUFDbEcsTUFBTUMsUUFBUSxDQUFDUixLQUFLM0IsSUFBSXNCLElBQUlNLElBQUlJLElBQUlJLEtBQU8sS0FBTWQsS0FBS00sS0FBS0ksS0FBS0ksS0FBTSxPQUFPLEtBQUssS0FBTSxLQUFNO0FBQzlGLGtCQUFrQjtBQUMrSjtBQUNqTCxrQkFBa0I7QUFDbEIsTUFBTUMsTUFBTTtJQUNSN0M7SUFBU007SUFBT087SUFDaEJDO0lBQU9HO0lBQ1BDO0lBQVFDO0lBQVFDO0lBQVFDO0lBQ3hCQztJQUFTRTtJQUNUQztJQUFRQztJQUFRQztJQUFRQztJQUN4QkM7SUFBS0c7SUFBT0U7SUFBT0c7SUFBT0U7SUFBT0k7SUFBT0Y7QUFDNUM7QUFDQSxpRUFBZUksR0FBR0EsRUFBQyxDQUNuQixnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jZmFwcC8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fdTY0LmpzPzdkYzAiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgVTMyX01BU0s2NCA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMiAqKiAzMiAtIDEpO1xuY29uc3QgXzMybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMzIpO1xuLy8gV2UgYXJlIG5vdCB1c2luZyBCaWdVaW50NjRBcnJheSwgYmVjYXVzZSB0aGV5IGFyZSBleHRyZW1lbHkgc2xvdyBhcyBwZXIgMjAyMlxuZnVuY3Rpb24gZnJvbUJpZyhuLCBsZSA9IGZhbHNlKSB7XG4gICAgaWYgKGxlKVxuICAgICAgICByZXR1cm4geyBoOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpLCBsOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB9O1xuICAgIHJldHVybiB7IGg6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIHwgMCwgbDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSB8IDAgfTtcbn1cbmZ1bmN0aW9uIHNwbGl0KGxzdCwgbGUgPSBmYWxzZSkge1xuICAgIGxldCBBaCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBsZXQgQWwgPSBuZXcgVWludDMyQXJyYXkobHN0Lmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBoLCBsIH0gPSBmcm9tQmlnKGxzdFtpXSwgbGUpO1xuICAgICAgICBbQWhbaV0sIEFsW2ldXSA9IFtoLCBsXTtcbiAgICB9XG4gICAgcmV0dXJuIFtBaCwgQWxdO1xufVxuY29uc3QgdG9CaWcgPSAoaCwgbCkgPT4gKEJpZ0ludChoID4+PiAwKSA8PCBfMzJuKSB8IEJpZ0ludChsID4+PiAwKTtcbi8vIGZvciBTaGlmdCBpbiBbMCwgMzIpXG5jb25zdCBzaHJTSCA9IChoLCBfbCwgcykgPT4gaCA+Pj4gcztcbmNvbnN0IHNoclNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90clNIID0gKGgsIGwsIHMpID0+IChoID4+PiBzKSB8IChsIDw8ICgzMiAtIHMpKTtcbmNvbnN0IHJvdHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RyQkggPSAoaCwgbCwgcykgPT4gKGggPDwgKDY0IC0gcykpIHwgKGwgPj4+IChzIC0gMzIpKTtcbmNvbnN0IHJvdHJCTCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gKHMgLSAzMikpIHwgKGwgPDwgKDY0IC0gcykpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBzaGlmdD09PTMyIChqdXN0IHN3YXBzIGwmaClcbmNvbnN0IHJvdHIzMkggPSAoX2gsIGwpID0+IGw7XG5jb25zdCByb3RyMzJMID0gKGgsIF9sKSA9PiBoO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdGxTSCA9IChoLCBsLCBzKSA9PiAoaCA8PCBzKSB8IChsID4+PiAoMzIgLSBzKSk7XG5jb25zdCByb3RsU0wgPSAoaCwgbCwgcykgPT4gKGwgPDwgcykgfCAoaCA+Pj4gKDMyIC0gcykpO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RsQkggPSAoaCwgbCwgcykgPT4gKGwgPDwgKHMgLSAzMikpIHwgKGggPj4+ICg2NCAtIHMpKTtcbmNvbnN0IHJvdGxCTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAocyAtIDMyKSkgfCAobCA+Pj4gKDY0IC0gcykpO1xuLy8gSlMgdXNlcyAzMi1iaXQgc2lnbmVkIGludGVnZXJzIGZvciBiaXR3aXNlIG9wZXJhdGlvbnMgd2hpY2ggbWVhbnMgd2UgY2Fubm90XG4vLyBzaW1wbGUgdGFrZSBjYXJyeSBvdXQgb2YgbG93IGJpdCBzdW0gYnkgc2hpZnQsIHdlIG5lZWQgdG8gdXNlIGRpdmlzaW9uLlxuZnVuY3Rpb24gYWRkKEFoLCBBbCwgQmgsIEJsKSB7XG4gICAgY29uc3QgbCA9IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApO1xuICAgIHJldHVybiB7IGg6IChBaCArIEJoICsgKChsIC8gMiAqKiAzMikgfCAwKSkgfCAwLCBsOiBsIHwgMCB9O1xufVxuLy8gQWRkaXRpb24gd2l0aCBtb3JlIHRoYW4gMiBlbGVtZW50c1xuY29uc3QgYWRkM0wgPSAoQWwsIEJsLCBDbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApO1xuY29uc3QgYWRkM0ggPSAobG93LCBBaCwgQmgsIENoKSA9PiAoQWggKyBCaCArIENoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ0TCA9IChBbCwgQmwsIENsLCBEbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKTtcbmNvbnN0IGFkZDRIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNUwgPSAoQWwsIEJsLCBDbCwgRGwsIEVsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApICsgKEVsID4+PiAwKTtcbmNvbnN0IGFkZDVIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgsIEVoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyBFaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgeyBmcm9tQmlnLCBzcGxpdCwgdG9CaWcsIHNoclNILCBzaHJTTCwgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLCByb3RyMzJILCByb3RyMzJMLCByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCwgfTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdTY0ID0ge1xuICAgIGZyb21CaWcsIHNwbGl0LCB0b0JpZyxcbiAgICBzaHJTSCwgc2hyU0wsXG4gICAgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLFxuICAgIHJvdHIzMkgsIHJvdHIzMkwsXG4gICAgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLFxuICAgIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCxcbn07XG5leHBvcnQgZGVmYXVsdCB1NjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdTY0LmpzLm1hcCJdLCJuYW1lcyI6WyJVMzJfTUFTSzY0IiwiQmlnSW50IiwiXzMybiIsImZyb21CaWciLCJuIiwibGUiLCJoIiwiTnVtYmVyIiwibCIsInNwbGl0IiwibHN0IiwiQWgiLCJVaW50MzJBcnJheSIsImxlbmd0aCIsIkFsIiwiaSIsInRvQmlnIiwic2hyU0giLCJfbCIsInMiLCJzaHJTTCIsInJvdHJTSCIsInJvdHJTTCIsInJvdHJCSCIsInJvdHJCTCIsInJvdHIzMkgiLCJfaCIsInJvdHIzMkwiLCJyb3RsU0giLCJyb3RsU0wiLCJyb3RsQkgiLCJyb3RsQkwiLCJhZGQiLCJCaCIsIkJsIiwiYWRkM0wiLCJDbCIsImFkZDNIIiwibG93IiwiQ2giLCJhZGQ0TCIsIkRsIiwiYWRkNEgiLCJEaCIsImFkZDVMIiwiRWwiLCJhZGQ1SCIsIkVoIiwidTY0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/_u64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/cryptoNode.js":
/*!******************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/cryptoNode.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\n// The file will throw on node.js 14 and earlier.\n// @ts-ignore\n\nconst crypto = /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) && typeof /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) === \"object\" && \"webcrypto\" in /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) ? node_crypto__WEBPACK_IMPORTED_MODULE_0__.webcrypto : undefined; //# sourceMappingURL=cryptoNode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvTm9kZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxvRkFBb0Y7QUFDcEYsNEJBQTRCO0FBQzVCLGlEQUFpRDtBQUNqRCxhQUFhO0FBQ3FCO0FBQzNCLE1BQU1DLFNBQVNELDJNQUFFQSxJQUFJLE9BQU9BLDJNQUFFQSxLQUFLLFlBQVksME5BQWlCQSxHQUFHQSxrREFBWSxHQUFHRyxVQUFVLENBQ25HLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NmYXBwLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0b05vZGUuanM/ZGE1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIFNlZSB1dGlscy50cyBmb3IgZGV0YWlscy5cbi8vIFRoZSBmaWxlIHdpbGwgdGhyb3cgb24gbm9kZS5qcyAxNCBhbmQgZWFybGllci5cbi8vIEB0cy1pZ25vcmVcbmltcG9ydCAqIGFzIG5jIGZyb20gJ25vZGU6Y3J5cHRvJztcbmV4cG9ydCBjb25zdCBjcnlwdG8gPSBuYyAmJiB0eXBlb2YgbmMgPT09ICdvYmplY3QnICYmICd3ZWJjcnlwdG8nIGluIG5jID8gbmMud2ViY3J5cHRvIDogdW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvTm9kZS5qcy5tYXAiXSwibmFtZXMiOlsibmMiLCJjcnlwdG8iLCJ3ZWJjcnlwdG8iLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/hmac.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/hmac.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key){\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.hash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== \"function\") throw new Error(\"Expected instance of class which extends utils.Hash\");\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */ const hmac = (hash, key, message)=>new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key)=>new HMAC(hash, key); //# sourceMappingURL=hmac.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaG1hYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWdHO0FBQ3JEO0FBQzNDLGtCQUFrQjtBQUNYLE1BQU1RLGFBQWFGLDJDQUFJQTtJQUMxQkcsWUFBWVQsSUFBSSxFQUFFVSxJQUFJLENBQUU7UUFDcEIsS0FBSztRQUNMLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBQ2pCWCxnREFBVUEsQ0FBQ0Q7UUFDWCxNQUFNYSxNQUFNTixrREFBT0EsQ0FBQ0c7UUFDcEIsSUFBSSxDQUFDSSxLQUFLLEdBQUdkLEtBQUtlLE1BQU07UUFDeEIsSUFBSSxPQUFPLElBQUksQ0FBQ0QsS0FBSyxDQUFDRSxNQUFNLEtBQUssWUFDN0IsTUFBTSxJQUFJQyxNQUFNO1FBQ3BCLElBQUksQ0FBQ0MsUUFBUSxHQUFHLElBQUksQ0FBQ0osS0FBSyxDQUFDSSxRQUFRO1FBQ25DLElBQUksQ0FBQ0MsU0FBUyxHQUFHLElBQUksQ0FBQ0wsS0FBSyxDQUFDSyxTQUFTO1FBQ3JDLE1BQU1ELFdBQVcsSUFBSSxDQUFDQSxRQUFRO1FBQzlCLE1BQU1FLE1BQU0sSUFBSUMsV0FBV0g7UUFDM0Isd0NBQXdDO1FBQ3hDRSxJQUFJRSxHQUFHLENBQUNULElBQUlVLE1BQU0sR0FBR0wsV0FBV2xCLEtBQUtlLE1BQU0sR0FBR0MsTUFBTSxDQUFDSCxLQUFLVyxNQUFNLEtBQUtYO1FBQ3JFLElBQUssSUFBSVksSUFBSSxHQUFHQSxJQUFJTCxJQUFJRyxNQUFNLEVBQUVFLElBQzVCTCxHQUFHLENBQUNLLEVBQUUsSUFBSTtRQUNkLElBQUksQ0FBQ1gsS0FBSyxDQUFDRSxNQUFNLENBQUNJO1FBQ2xCLG1IQUFtSDtRQUNuSCxJQUFJLENBQUNNLEtBQUssR0FBRzFCLEtBQUtlLE1BQU07UUFDeEIsdUNBQXVDO1FBQ3ZDLElBQUssSUFBSVUsSUFBSSxHQUFHQSxJQUFJTCxJQUFJRyxNQUFNLEVBQUVFLElBQzVCTCxHQUFHLENBQUNLLEVBQUUsSUFBSSxPQUFPO1FBQ3JCLElBQUksQ0FBQ0MsS0FBSyxDQUFDVixNQUFNLENBQUNJO1FBQ2xCQSxJQUFJTyxJQUFJLENBQUM7SUFDYjtJQUNBWCxPQUFPWSxHQUFHLEVBQUU7UUFDUnZCLGtEQUFZQSxDQUFDLElBQUk7UUFDakIsSUFBSSxDQUFDUyxLQUFLLENBQUNFLE1BQU0sQ0FBQ1k7UUFDbEIsT0FBTyxJQUFJO0lBQ2Y7SUFDQUMsV0FBV0MsR0FBRyxFQUFFO1FBQ1p6QixrREFBWUEsQ0FBQyxJQUFJO1FBQ2pCRixpREFBV0EsQ0FBQzJCLEtBQUssSUFBSSxDQUFDWCxTQUFTO1FBQy9CLElBQUksQ0FBQ1IsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0csS0FBSyxDQUFDZSxVQUFVLENBQUNDO1FBQ3RCLElBQUksQ0FBQ0osS0FBSyxDQUFDVixNQUFNLENBQUNjO1FBQ2xCLElBQUksQ0FBQ0osS0FBSyxDQUFDRyxVQUFVLENBQUNDO1FBQ3RCLElBQUksQ0FBQ0MsT0FBTztJQUNoQjtJQUNBUCxTQUFTO1FBQ0wsTUFBTU0sTUFBTSxJQUFJVCxXQUFXLElBQUksQ0FBQ0ssS0FBSyxDQUFDUCxTQUFTO1FBQy9DLElBQUksQ0FBQ1UsVUFBVSxDQUFDQztRQUNoQixPQUFPQTtJQUNYO0lBQ0FFLFdBQVdDLEVBQUUsRUFBRTtRQUNYLG1HQUFtRztRQUNuR0EsTUFBT0EsQ0FBQUEsS0FBS0MsT0FBT25CLE1BQU0sQ0FBQ21CLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxFQUFDO1FBQ3pELE1BQU0sRUFBRVQsS0FBSyxFQUFFWixLQUFLLEVBQUVILFFBQVEsRUFBRUMsU0FBUyxFQUFFTSxRQUFRLEVBQUVDLFNBQVMsRUFBRSxHQUFHLElBQUk7UUFDdkVjLEtBQUtBO1FBQ0xBLEdBQUd0QixRQUFRLEdBQUdBO1FBQ2RzQixHQUFHckIsU0FBUyxHQUFHQTtRQUNmcUIsR0FBR2YsUUFBUSxHQUFHQTtRQUNkZSxHQUFHZCxTQUFTLEdBQUdBO1FBQ2ZjLEdBQUdQLEtBQUssR0FBR0EsTUFBTU0sVUFBVSxDQUFDQyxHQUFHUCxLQUFLO1FBQ3BDTyxHQUFHbkIsS0FBSyxHQUFHQSxNQUFNa0IsVUFBVSxDQUFDQyxHQUFHbkIsS0FBSztRQUNwQyxPQUFPbUI7SUFDWDtJQUNBRixVQUFVO1FBQ04sSUFBSSxDQUFDbkIsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ2MsS0FBSyxDQUFDSyxPQUFPO1FBQ2xCLElBQUksQ0FBQ2pCLEtBQUssQ0FBQ2lCLE9BQU87SUFDdEI7QUFDSjtBQUNBOzs7OztDQUtDLEdBQ00sTUFBTUssT0FBTyxDQUFDcEMsTUFBTWEsS0FBS3dCLFVBQVksSUFBSTdCLEtBQUtSLE1BQU1hLEtBQUtHLE1BQU0sQ0FBQ3FCLFNBQVNiLE1BQU0sR0FBRztBQUN6RlksS0FBS3JCLE1BQU0sR0FBRyxDQUFDZixNQUFNYSxNQUFRLElBQUlMLEtBQUtSLE1BQU1hLE1BQzVDLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NmYXBwLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2htYWMuanM/MGNjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoYXNoIGFzIGFzc2VydEhhc2gsIGJ5dGVzIGFzIGFzc2VydEJ5dGVzLCBleGlzdHMgYXMgYXNzZXJ0RXhpc3RzIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIEhNQUMgKFJGQyAyMTA0KVxuZXhwb3J0IGNsYXNzIEhNQUMgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBfa2V5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgYXNzZXJ0SGFzaChoYXNoKTtcbiAgICAgICAgY29uc3Qga2V5ID0gdG9CeXRlcyhfa2V5KTtcbiAgICAgICAgdGhpcy5pSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5pSGFzaC51cGRhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaCcpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICAgICAgY29uc3QgYmxvY2tMZW4gPSB0aGlzLmJsb2NrTGVuO1xuICAgICAgICBjb25zdCBwYWQgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIC8vIGJsb2NrTGVuIGNhbiBiZSBiaWdnZXIgdGhhbiBvdXRwdXRMZW5cbiAgICAgICAgcGFkLnNldChrZXkubGVuZ3RoID4gYmxvY2tMZW4gPyBoYXNoLmNyZWF0ZSgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpIDoga2V5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNjtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgLy8gQnkgZG9pbmcgdXBkYXRlIChwcm9jZXNzaW5nIG9mIGZpcnN0IGJsb2NrKSBvZiBvdXRlciBoYXNoIGhlcmUgd2UgY2FuIHJlLXVzZSBpdCBiZXR3ZWVuIG11bHRpcGxlIGNhbGxzIHZpYSBjbG9uZVxuICAgICAgICB0aGlzLm9IYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgLy8gVW5kbyBpbnRlcm5hbCBYT1IgJiYgYXBwbHkgb3V0ZXIgWE9SXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzYgXiAweDVjO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICBwYWQuZmlsbCgwKTtcbiAgICB9XG4gICAgdXBkYXRlKGJ1Zikge1xuICAgICAgICBhc3NlcnRFeGlzdHModGhpcyk7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKGJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhc3NlcnRFeGlzdHModGhpcyk7XG4gICAgICAgIGFzc2VydEJ5dGVzKG91dCwgdGhpcy5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2Ugd2l0aG91dCBjYWxsaW5nIGNvbnN0cnVjdG9yIHNpbmNlIGtleSBhbHJlYWR5IGluIHN0YXRlIGFuZCB3ZSBkb24ndCBrbm93IGl0LlxuICAgICAgICB0byB8fCAodG8gPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcbiAgICAgICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRvID0gdG87XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5vSGFzaCA9IG9IYXNoLl9jbG9uZUludG8odG8ub0hhc2gpO1xuICAgICAgICB0by5pSGFzaCA9IGlIYXNoLl9jbG9uZUludG8odG8uaUhhc2gpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vSGFzaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICAgIH1cbn1cbi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAcGFyYW0gaGFzaCAtIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgZGF0YVxuICovXG5leHBvcnQgY29uc3QgaG1hYyA9IChoYXNoLCBrZXksIG1lc3NhZ2UpID0+IG5ldyBITUFDKGhhc2gsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpO1xuaG1hYy5jcmVhdGUgPSAoaGFzaCwga2V5KSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG1hYy5qcy5tYXAiXSwibmFtZXMiOlsiaGFzaCIsImFzc2VydEhhc2giLCJieXRlcyIsImFzc2VydEJ5dGVzIiwiZXhpc3RzIiwiYXNzZXJ0RXhpc3RzIiwiSGFzaCIsInRvQnl0ZXMiLCJITUFDIiwiY29uc3RydWN0b3IiLCJfa2V5IiwiZmluaXNoZWQiLCJkZXN0cm95ZWQiLCJrZXkiLCJpSGFzaCIsImNyZWF0ZSIsInVwZGF0ZSIsIkVycm9yIiwiYmxvY2tMZW4iLCJvdXRwdXRMZW4iLCJwYWQiLCJVaW50OEFycmF5Iiwic2V0IiwibGVuZ3RoIiwiZGlnZXN0IiwiaSIsIm9IYXNoIiwiZmlsbCIsImJ1ZiIsImRpZ2VzdEludG8iLCJvdXQiLCJkZXN0cm95IiwiX2Nsb25lSW50byIsInRvIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJobWFjIiwibWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/hmac.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/sha256.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha256.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ \"(ssr)/./node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98,\n    0x71374491,\n    0xb5c0fbcf,\n    0xe9b5dba5,\n    0x3956c25b,\n    0x59f111f1,\n    0x923f82a4,\n    0xab1c5ed5,\n    0xd807aa98,\n    0x12835b01,\n    0x243185be,\n    0x550c7dc3,\n    0x72be5d74,\n    0x80deb1fe,\n    0x9bdc06a7,\n    0xc19bf174,\n    0xe49b69c1,\n    0xefbe4786,\n    0x0fc19dc6,\n    0x240ca1cc,\n    0x2de92c6f,\n    0x4a7484aa,\n    0x5cb0a9dc,\n    0x76f988da,\n    0x983e5152,\n    0xa831c66d,\n    0xb00327c8,\n    0xbf597fc7,\n    0xc6e00bf3,\n    0xd5a79147,\n    0x06ca6351,\n    0x14292967,\n    0x27b70a85,\n    0x2e1b2138,\n    0x4d2c6dfc,\n    0x53380d13,\n    0x650a7354,\n    0x766a0abb,\n    0x81c2c92e,\n    0x92722c85,\n    0xa2bfe8a1,\n    0xa81a664b,\n    0xc24b8b70,\n    0xc76c51a3,\n    0xd192e819,\n    0xd6990624,\n    0xf40e3585,\n    0x106aa070,\n    0x19a4c116,\n    0x1e376c08,\n    0x2748774c,\n    0x34b0bcb5,\n    0x391c0cb3,\n    0x4ed8aa4a,\n    0x5b9cca4f,\n    0x682e6ff3,\n    0x748f82ee,\n    0x78a5636f,\n    0x84c87814,\n    0x8cc70208,\n    0x90befffa,\n    0xa4506ceb,\n    0xbef9a3f7,\n    0xc67178f2\n]);\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667,\n    0xbb67ae85,\n    0x3c6ef372,\n    0xa54ff53a,\n    0x510e527f,\n    0x9b05688c,\n    0x1f83d9ab,\n    0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor(){\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [\n            A,\n            B,\n            C,\n            D,\n            E,\n            F,\n            G,\n            H\n        ];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);\n        for(let i = 16; i < 64; i++){\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ W15 >>> 3;\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ W2 >>> 10;\n            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for(let i = 0; i < 64; i++){\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = H + sigma1 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = sigma0 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Maj)(A, B, C) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = D + T1 | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = T1 + T2 | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = A + this.A | 0;\n        B = B + this.B | 0;\n        C = C + this.C | 0;\n        D = D + this.D | 0;\n        E = E + this.E | 0;\n        F = F + this.F | 0;\n        G = G + this.G | 0;\n        H = H + this.H | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor(){\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */ const sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(()=>new SHA256());\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(()=>new SHA224()); //# sourceMappingURL=sha256.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMjU2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNEM7QUFDTztBQUNuRCxnRUFBZ0U7QUFDaEUsMERBQTBEO0FBQzFELG1CQUFtQjtBQUNuQix5RkFBeUY7QUFDekYsa0JBQWtCO0FBQ2xCLE1BQU1LLFdBQVcsYUFBYSxHQUFHLElBQUlDLFlBQVk7SUFDN0M7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0NBQ3ZGO0FBQ0QsaUJBQWlCO0FBQ2pCLHdGQUF3RjtBQUN4RixrQkFBa0I7QUFDbEIsTUFBTUMsWUFBWSxhQUFhLEdBQUcsSUFBSUQsWUFBWTtJQUM5QztJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0NBQ3ZGO0FBQ0QsNERBQTREO0FBQzVELG1EQUFtRDtBQUNuRCxNQUFNRSxXQUFXLGFBQWEsR0FBRyxJQUFJRixZQUFZO0FBQ2pELE1BQU1HLGVBQWVULDBDQUFNQTtJQUN2QlUsYUFBYztRQUNWLEtBQUssQ0FBQyxJQUFJLElBQUksR0FBRztRQUNqQixtRUFBbUU7UUFDbkUsdURBQXVEO1FBQ3ZELElBQUksQ0FBQ0MsQ0FBQyxHQUFHSixTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3hCLElBQUksQ0FBQ0ssQ0FBQyxHQUFHTCxTQUFTLENB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QUcsYUFBYTtRQUN0QixJQUFJLENBQUNDLENBQUMsR0FBRyxhQUFhO1FBQ3RCLElBQUksQ0FBQ0MsQ0FBQyxHQUFHLGFBQWE7UUFDdEIsSUFBSSxDQUFDQyxDQUFDLEdBQUcsYUFBYTtRQUN0QixJQUFJLENBQUNDLENBQUMsR0FBRyxhQUFhO1FBQ3RCLElBQUksQ0FBQ0MsQ0FBQyxHQUFHLGFBQWE7UUFDdEIsSUFBSSxDQUFDQyxDQUFDLEdBQUcsYUFBYTtRQUN0QixJQUFJLENBQUNxQixTQUFTLEdBQUc7SUFDckI7QUFDSjtBQUNBOzs7Q0FHQyxHQUNNLE1BQU1DLFNBQVMsYUFBYSxHQUFHcEMsMERBQWVBLENBQUMsSUFBTSxJQUFJSyxVQUFVO0FBQ25FLE1BQU1nQyxTQUFTLGFBQWEsR0FBR3JDLDBEQUFlQSxDQUFDLElBQU0sSUFBSWtDLFVBQVUsQ0FDMUUsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2ZhcHAvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMjU2LmpzPzZmMWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSGFzaE1ELCBDaGksIE1haiB9IGZyb20gJy4vX21kLmpzJztcbmltcG9ydCB7IHJvdHIsIHdyYXBDb25zdHJ1Y3RvciB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gU0hBMi0yNTYgbmVlZCB0byB0cnkgMl4xMjggaGFzaGVzIHRvIGV4ZWN1dGUgYmlydGhkYXkgYXR0YWNrLlxuLy8gQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl42NyBoYXNoZXMvc2VjIGFzIHBlciBlYXJseSAyMDIzLlxuLy8gUm91bmQgY29uc3RhbnRzOlxuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0sgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LCAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl0pO1xuLy8gSW5pdGlhbCBzdGF0ZTpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0lWID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuXSk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbi8vIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxuY29uc3QgU0hBMjU2X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmNsYXNzIFNIQTI1NiBleHRlbmRzIEhhc2hNRCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAzMiwgOCwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgdGhpcy5BID0gU0hBMjU2X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gU0hBMjU2X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gU0hBMjU2X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gU0hBMjU2X0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gU0hBMjU2X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gU0hBMjU2X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gU0hBMjU2X0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gU0hBMjU2X0lWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gcm90cihXMiwgMTcpIF4gcm90cihXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gcm90cihFLCA2KSBeIHJvdHIoRSwgMTEpIF4gcm90cihFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyBNYWooQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEEyNTZfVy5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICB9XG59XG4vLyBDb25zdGFudHMgZnJvbSBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmXG5jbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkEgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQyA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkQgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkcgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIGRhdGEgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTI1NigpKTtcbmV4cG9ydCBjb25zdCBzaGEyMjQgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIl0sIm5hbWVzIjpbIkhhc2hNRCIsIkNoaSIsIk1haiIsInJvdHIiLCJ3cmFwQ29uc3RydWN0b3IiLCJTSEEyNTZfSyIsIlVpbnQzMkFycmF5IiwiU0hBMjU2X0lWIiwiU0hBMjU2X1ciLCJTSEEyNTYiLCJjb25zdHJ1Y3RvciIsIkEiLCJCIiwiQyIsIkQiLCJFIiwiRiIsIkciLCJIIiwiZ2V0Iiwic2V0IiwicHJvY2VzcyIsInZpZXciLCJvZmZzZXQiLCJpIiwiZ2V0VWludDMyIiwiVzE1IiwiVzIiLCJzMCIsInMxIiwic2lnbWExIiwiVDEiLCJzaWdtYTAiLCJUMiIsInJvdW5kQ2xlYW4iLCJmaWxsIiwiZGVzdHJveSIsImJ1ZmZlciIsIlNIQTIyNCIsIm91dHB1dExlbiIsInNoYTI1NiIsInNoYTIyNCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/sha256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/sha3.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha3.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Keccak: () => (/* binding */ Keccak),\n/* harmony export */   keccakP: () => (/* binding */ keccakP),\n/* harmony export */   keccak_224: () => (/* binding */ keccak_224),\n/* harmony export */   keccak_256: () => (/* binding */ keccak_256),\n/* harmony export */   keccak_384: () => (/* binding */ keccak_384),\n/* harmony export */   keccak_512: () => (/* binding */ keccak_512),\n/* harmony export */   sha3_224: () => (/* binding */ sha3_224),\n/* harmony export */   sha3_256: () => (/* binding */ sha3_256),\n/* harmony export */   sha3_384: () => (/* binding */ sha3_384),\n/* harmony export */   sha3_512: () => (/* binding */ sha3_512),\n/* harmony export */   shake128: () => (/* binding */ shake128),\n/* harmony export */   shake256: () => (/* binding */ shake256)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(ssr)/./node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n// Various per round constants calculations\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor(let round = 0, R = _1n, x = 1, y = 0; round < 24; round++){\n    // Pi\n    [x, y] = [\n        y,\n        (2 * x + 3 * y) % 5\n    ];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);\n    // Iota\n    let t = _0n;\n    for(let j = 0; j < 7; j++){\n        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;\n        if (R & _2n) t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.split)(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s)=>s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBH)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSH)(h, l, s);\nconst rotlL = (h, l, s)=>s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBL)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSL)(h, l, s);\n// Same as keccakf1600, but allows to skip some rounds\nfunction keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for(let round = 24 - rounds; round < 24; round++){\n        // Theta θ\n        for(let x = 0; x < 10; x++)B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for(let x = 0; x < 10; x += 2){\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for(let y = 0; y < 50; y += 10){\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (ρ) and Pi (π)\n        let curH = s[2];\n        let curL = s[3];\n        for(let t = 0; t < 24; t++){\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (χ)\n        for(let y = 0; y < 50; y += 10){\n            for(let x = 0; x < 10; x++)B[x] = s[y + x];\n            for(let x = 0; x < 10; x++)s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (ι)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nclass Keccak extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24){\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.number)(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200) throw new Error(\"Sha3 supports only keccak-f1600 function\");\n        this.state = new Uint8Array(200);\n        this.state32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(this.state);\n    }\n    keccak() {\n        if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLE) (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.byteSwap32)(this.state32);\n        keccakP(this.state32, this.rounds);\n        if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLE) (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.byteSwap32)(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.exists)(this);\n        const { blockLen, state } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for(let i = 0; i < take; i++)state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen) this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished) return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.exists)(this, false);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.bytes)(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for(let pos = 0, len = out.length; pos < len;){\n            if (this.posOut >= blockLen) this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF) throw new Error(\"XOF is not possible for this instance\");\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.number)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.output)(out, this);\n        if (this.finished) throw new Error(\"digest() was already called\");\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(()=>new Keccak(blockLen, suffix, outputLen));\nconst sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */ const sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\nconst sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\nconst sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\nconst keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */ const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\nconst keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\nconst keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapXOFConstructorWithOpts)((opts = {})=>new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nconst shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\nconst shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8); //# sourceMappingURL=sha3.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNkQ7QUFDSztBQUM4QztBQUNoSCxvR0FBb0c7QUFDcEcsaUNBQWlDO0FBQ2pDLDJDQUEyQztBQUMzQyxNQUFNZ0IsVUFBVSxFQUFFO0FBQ2xCLE1BQU1DLFlBQVksRUFBRTtBQUNwQixNQUFNQyxhQUFhLEVBQUU7QUFDckIsTUFBTUMsTUFBTSxhQUFhLEdBQUdDLE9BQU87QUFDbkMsTUFBTUMsTUFBTSxhQUFhLEdBQUdELE9BQU87QUFDbkMsTUFBTUUsTUFBTSxhQUFhLEdBQUdGLE9BQU87QUFDbkMsTUFBTUcsTUFBTSxhQUFhLEdBQUdILE9BQU87QUFDbkMsTUFBTUksUUFBUSxhQUFhLEdBQUdKLE9BQU87QUFDckMsTUFBTUssU0FBUyxhQUFhLEdBQUdMLE9BQU87QUFDdEMsSUFBSyxJQUFJTSxRQUFRLEdBQUdDLElBQUlOLEtBQUtPLElBQUksR0FBR0MsSUFBSSxHQUFHSCxRQUFRLElBQUlBLFFBQVM7SUFDNUQsS0FBSztJQUNMLENBQUNFLEdBQUdDLEVBQUUsR0FBRztRQUFDQTtRQUFJLEtBQUlELElBQUksSUFBSUMsQ0FBQUEsSUFBSztLQUFFO0lBQ2pDYixRQUFRYyxJQUFJLENBQUMsSUFBSyxLQUFJRCxJQUFJRCxDQUFBQTtJQUMxQixhQUFhO0lBQ2JYLFVBQVVhLElBQUksQ0FBQyxDQUFHSixRQUFRLEtBQU1BLENBQUFBLFFBQVEsS0FBTSxJQUFLO0lBQ25ELE9BQU87SUFDUCxJQUFJSyxJQUFJWjtJQUNSLElBQUssSUFBSWEsSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQUs7UUFDeEJMLElBQUksQ0FBQyxLQUFNTixNQUFRLENBQUNNLEtBQUtKLEdBQUUsSUFBS0UsTUFBTSxJQUFLRDtRQUMzQyxJQUFJRyxJQUFJTCxLQUNKUyxLQUFLVixPQUFRLENBQUNBLE9BQU8sYUFBYSxHQUFHRCxPQUFPWSxFQUFDLElB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QVcsYUFBYSxHQUFHSixJQUFJLE1BQU0sSUFBSSxNQUFNLEdBQUc7QUFDeEQsTUFBTUssYUFBYSxhQUFhLEdBQUdMLElBQUksTUFBTSxLQUFLLE1BQU0sR0FBRztBQUNsRTs7O0NBR0MsR0FDTSxNQUFNTSxhQUFhLGFBQWEsR0FBR04sSUFBSSxNQUFNLEtBQUssTUFBTSxHQUFHO0FBQzNELE1BQU1PLGFBQWEsYUFBYSxHQUFHUCxJQUFJLE1BQU0sS0FBSyxNQUFNLEdBQUc7QUFDM0QsTUFBTVEsYUFBYSxhQUFhLEdBQUdSLElBQUksTUFBTSxJQUFJLE1BQU0sR0FBRztBQUNqRSxNQUFNUyxXQUFXLENBQUMxQyxRQUFRRCxVQUFVRSxZQUFjOUMscUVBQTBCQSxDQUFDLENBQUN3RixPQUFPLENBQUMsQ0FBQyxHQUFLLElBQUk5QyxPQUFPRSxVQUFVQyxRQUFRMkMsS0FBS0MsS0FBSyxLQUFLQyxZQUFZNUMsWUFBWTBDLEtBQUtDLEtBQUssRUFBRTtBQUNySyxNQUFNRSxXQUFXLGFBQWEsR0FBR0osU0FBUyxNQUFNLEtBQUssTUFBTSxHQUFHO0FBQzlELE1BQU1LLFdBQVcsYUFBYSxHQUFHTCxTQUFTLE1BQU0sS0FBSyxNQUFNLEdBQUcsQ0FDckUsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2ZhcHAvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMy5qcz9iNDJlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGJ5dGVzLCBleGlzdHMsIG51bWJlciwgb3V0cHV0IH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IHJvdGxCSCwgcm90bEJMLCByb3RsU0gsIHJvdGxTTCwgc3BsaXQgfSBmcm9tICcuL191NjQuanMnO1xuaW1wb3J0IHsgSGFzaCwgdTMyLCB0b0J5dGVzLCB3cmFwQ29uc3RydWN0b3IsIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzLCBpc0xFLCBieXRlU3dhcDMyLCB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gU0hBMyAoa2VjY2FrKSBpcyBiYXNlZCBvbiBhIG5ldyBkZXNpZ246IGJhc2ljYWxseSwgdGhlIGludGVybmFsIHN0YXRlIGlzIGJpZ2dlciB0aGFuIG91dHB1dCBzaXplLlxuLy8gSXQncyBjYWxsZWQgYSBzcG9uZ2UgZnVuY3Rpb24uXG4vLyBWYXJpb3VzIHBlciByb3VuZCBjb25zdGFudHMgY2FsY3VsYXRpb25zXG5jb25zdCBTSEEzX1BJID0gW107XG5jb25zdCBTSEEzX1JPVEwgPSBbXTtcbmNvbnN0IF9TSEEzX0lPVEEgPSBbXTtcbmNvbnN0IF8wbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyKTtcbmNvbnN0IF83biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoNyk7XG5jb25zdCBfMjU2biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMjU2KTtcbmNvbnN0IF8weDcxbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMHg3MSk7XG5mb3IgKGxldCByb3VuZCA9IDAsIFIgPSBfMW4sIHggPSAxLCB5ID0gMDsgcm91bmQgPCAyNDsgcm91bmQrKykge1xuICAgIC8vIFBpXG4gICAgW3gsIHldID0gW3ksICgyICogeCArIDMgKiB5KSAlIDVdO1xuICAgIFNIQTNfUEkucHVzaCgyICogKDUgKiB5ICsgeCkpO1xuICAgIC8vIFJvdGF0aW9uYWxcbiAgICBTSEEzX1JPVEwucHVzaCgoKChyb3VuZCArIDEpICogKHJvdW5kICsgMikpIC8gMikgJSA2NCk7XG4gICAgLy8gSW90YVxuICAgIGxldCB0ID0gXzBuO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgNzsgaisrKSB7XG4gICAgICAgIFIgPSAoKFIgPDwgXzFuKSBeICgoUiA+PiBfN24pICogXzB4NzFuKSkgJSBfMjU2bjtcbiAgICAgICAgaWYgKFIgJiBfMm4pXG4gICAgICAgICAgICB0IF49IF8xbiA8PCAoKF8xbiA8PCAvKiBAX19QVVJFX18gKi8gQmlnSW50KGopKSAtIF8xbik7XG4gICAgfVxuICAgIF9TSEEzX0lPVEEucHVzaCh0KTtcbn1cbmNvbnN0IFtTSEEzX0lPVEFfSCwgU0hBM19JT1RBX0xdID0gLyogQF9fUFVSRV9fICovIHNwbGl0KF9TSEEzX0lPVEEsIHRydWUpO1xuLy8gTGVmdCByb3RhdGlvbiAod2l0aG91dCAwLCAzMiwgNjQpXG5jb25zdCByb3RsSCA9IChoLCBsLCBzKSA9PiAocyA+IDMyID8gcm90bEJIKGgsIGwsIHMpIDogcm90bFNIKGgsIGwsIHMpKTtcbmNvbnN0IHJvdGxMID0gKGgsIGwsIHMpID0+IChzID4gMzIgPyByb3RsQkwoaCwgbCwgcykgOiByb3RsU0woaCwgbCwgcykpO1xuLy8gU2FtZSBhcyBrZWNjYWtmMTYwMCwgYnV0IGFsbG93cyB0byBza2lwIHNvbWUgcm91bmRzXG5leHBvcnQgZnVuY3Rpb24ga2VjY2FrUChzLCByb3VuZHMgPSAyNCkge1xuICAgIGNvbnN0IEIgPSBuZXcgVWludDMyQXJyYXkoNSAqIDIpO1xuICAgIC8vIE5PVEU6IGFsbCBpbmRpY2VzIGFyZSB4MiBzaW5jZSB3ZSBzdG9yZSBzdGF0ZSBhcyB1MzIgaW5zdGVhZCBvZiB1NjQgKGJpZ2ludHMgdG8gc2xvdyBpbiBqcylcbiAgICBmb3IgKGxldCByb3VuZCA9IDI0IC0gcm91bmRzOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgICAgIC8vIFRoZXRhIM64XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgIEJbeF0gPSBzW3hdIF4gc1t4ICsgMTBdIF4gc1t4ICsgMjBdIF4gc1t4ICsgMzBdIF4gc1t4ICsgNDBdO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4ICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeDEgPSAoeCArIDgpICUgMTA7XG4gICAgICAgICAgICBjb25zdCBpZHgwID0gKHggKyAyKSAlIDEwO1xuICAgICAgICAgICAgY29uc3QgQjAgPSBCW2lkeDBdO1xuICAgICAgICAgICAgY29uc3QgQjEgPSBCW2lkeDAgKyAxXTtcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoQjAsIEIxLCAxKSBeIEJbaWR4MV07XG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKEIwLCBCMSwgMSkgXiBCW2lkeDEgKyAxXTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgICAgICAgICBzW3ggKyB5XSBePSBUaDtcbiAgICAgICAgICAgICAgICBzW3ggKyB5ICsgMV0gXj0gVGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmhvICjPgSkgYW5kIFBpICjPgClcbiAgICAgICAgbGV0IGN1ckggPSBzWzJdO1xuICAgICAgICBsZXQgY3VyTCA9IHNbM107XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgMjQ7IHQrKykge1xuICAgICAgICAgICAgY29uc3Qgc2hpZnQgPSBTSEEzX1JPVExbdF07XG4gICAgICAgICAgICBjb25zdCBUaCA9IHJvdGxIKGN1ckgsIGN1ckwsIHNoaWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IFRsID0gcm90bEwoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgICAgICAgY29uc3QgUEkgPSBTSEEzX1BJW3RdO1xuICAgICAgICAgICAgY3VySCA9IHNbUEldO1xuICAgICAgICAgICAgY3VyTCA9IHNbUEkgKyAxXTtcbiAgICAgICAgICAgIHNbUEldID0gVGg7XG4gICAgICAgICAgICBzW1BJICsgMV0gPSBUbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGkgKM+HKVxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICAgICAgQlt4XSA9IHNbeSArIHhdO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgICAgIHNbeSArIHhdIF49IH5CWyh4ICsgMikgJSAxMF0gJiBCWyh4ICsgNCkgJSAxMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW90YSAozrkpXG4gICAgICAgIHNbMF0gXj0gU0hBM19JT1RBX0hbcm91bmRdO1xuICAgICAgICBzWzFdIF49IFNIQTNfSU9UQV9MW3JvdW5kXTtcbiAgICB9XG4gICAgQi5maWxsKDApO1xufVxuZXhwb3J0IGNsYXNzIEtlY2NhayBleHRlbmRzIEhhc2gge1xuICAgIC8vIE5PVEU6IHdlIGFjY2VwdCBhcmd1bWVudHMgaW4gYnl0ZXMgaW5zdGVhZCBvZiBiaXRzIGhlcmUuXG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YgPSBmYWxzZSwgcm91bmRzID0gMjQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLnN1ZmZpeCA9IHN1ZmZpeDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMuZW5hYmxlWE9GID0gZW5hYmxlWE9GO1xuICAgICAgICB0aGlzLnJvdW5kcyA9IHJvdW5kcztcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLnBvc091dCA9IDA7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gQ2FuIGJlIHBhc3NlZCBmcm9tIHVzZXIgYXMgZGtMZW5cbiAgICAgICAgbnVtYmVyKG91dHB1dExlbik7XG4gICAgICAgIC8vIDE2MDAgPSA1eDUgbWF0cml4IG9mIDY0Yml0LiAgMTYwMCBiaXRzID09PSAyMDAgYnl0ZXNcbiAgICAgICAgaWYgKDAgPj0gdGhpcy5ibG9ja0xlbiB8fCB0aGlzLmJsb2NrTGVuID49IDIwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2hhMyBzdXBwb3J0cyBvbmx5IGtlY2Nhay1mMTYwMCBmdW5jdGlvbicpO1xuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IFVpbnQ4QXJyYXkoMjAwKTtcbiAgICAgICAgdGhpcy5zdGF0ZTMyID0gdTMyKHRoaXMuc3RhdGUpO1xuICAgIH1cbiAgICBrZWNjYWsoKSB7XG4gICAgICAgIGlmICghaXNMRSlcbiAgICAgICAgICAgIGJ5dGVTd2FwMzIodGhpcy5zdGF0ZTMyKTtcbiAgICAgICAga2VjY2FrUCh0aGlzLnN0YXRlMzIsIHRoaXMucm91bmRzKTtcbiAgICAgICAgaWYgKCFpc0xFKVxuICAgICAgICAgICAgYnl0ZVN3YXAzMih0aGlzLnN0YXRlMzIpO1xuICAgICAgICB0aGlzLnBvc091dCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFrZTsgaSsrKVxuICAgICAgICAgICAgICAgIHN0YXRlW3RoaXMucG9zKytdIF49IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBzdGF0ZSwgc3VmZml4LCBwb3MsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICAvLyBEbyB0aGUgcGFkZGluZ1xuICAgICAgICBzdGF0ZVtwb3NdIF49IHN1ZmZpeDtcbiAgICAgICAgaWYgKChzdWZmaXggJiAweDgwKSAhPT0gMCAmJiBwb3MgPT09IGJsb2NrTGVuIC0gMSlcbiAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgIHN0YXRlW2Jsb2NrTGVuIC0gMV0gXj0gMHg4MDtcbiAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICB9XG4gICAgd3JpdGVJbnRvKG91dCkge1xuICAgICAgICBleGlzdHModGhpcywgZmFsc2UpO1xuICAgICAgICBieXRlcyhvdXQpO1xuICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICBjb25zdCBidWZmZXJPdXQgPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBsZW4gPSBvdXQubGVuZ3RoOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3NPdXQgPj0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zT3V0LCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgb3V0LnNldChidWZmZXJPdXQuc3ViYXJyYXkodGhpcy5wb3NPdXQsIHRoaXMucG9zT3V0ICsgdGFrZSksIHBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvc091dCArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgeG9mSW50byhvdXQpIHtcbiAgICAgICAgLy8gU2hhMy9LZWNjYWsgdXNhZ2Ugd2l0aCBYT0YgaXMgcHJvYmFibHkgbWlzdGFrZSwgb25seSBTSEFLRSBpbnN0YW5jZXMgY2FuIGRvIFhPRlxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlWE9GKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdYT0YgaXMgbm90IHBvc3NpYmxlIGZvciB0aGlzIGluc3RhbmNlJyk7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlSW50byhvdXQpO1xuICAgIH1cbiAgICB4b2YoYnl0ZXMpIHtcbiAgICAgICAgbnVtYmVyKGJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMueG9mSW50byhuZXcgVWludDhBcnJheShieXRlcykpO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCgpIHdhcyBhbHJlYWR5IGNhbGxlZCcpO1xuICAgICAgICB0aGlzLndyaXRlSW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaWdlc3RJbnRvKG5ldyBVaW50OEFycmF5KHRoaXMub3V0cHV0TGVuKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdGF0ZS5maWxsKDApO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCByb3VuZHMsIGVuYWJsZVhPRiB9ID0gdGhpcztcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiwgcm91bmRzKSk7XG4gICAgICAgIHRvLnN0YXRlMzIuc2V0KHRoaXMuc3RhdGUzMik7XG4gICAgICAgIHRvLnBvcyA9IHRoaXMucG9zO1xuICAgICAgICB0by5wb3NPdXQgPSB0aGlzLnBvc091dDtcbiAgICAgICAgdG8uZmluaXNoZWQgPSB0aGlzLmZpbmlzaGVkO1xuICAgICAgICB0by5yb3VuZHMgPSByb3VuZHM7XG4gICAgICAgIC8vIFN1ZmZpeCBjYW4gY2hhbmdlIGluIGNTSEFLRVxuICAgICAgICB0by5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8uZW5hYmxlWE9GID0gZW5hYmxlWE9GO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSB0aGlzLmRlc3Ryb3llZDtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbmNvbnN0IGdlbiA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+IHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbikpO1xuZXhwb3J0IGNvbnN0IHNoYTNfMjI0ID0gLyogQF9fUFVSRV9fICovIGdlbigweDA2LCAxNDQsIDIyNCAvIDgpO1xuLyoqXG4gKiBTSEEzLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydCBjb25zdCBzaGEzXzI1NiA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwNiwgMTM2LCAyNTYgLyA4KTtcbmV4cG9ydCBjb25zdCBzaGEzXzM4NCA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwNiwgMTA0LCAzODQgLyA4KTtcbmV4cG9ydCBjb25zdCBzaGEzXzUxMiA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwNiwgNzIsIDUxMiAvIDgpO1xuZXhwb3J0IGNvbnN0IGtlY2Nha18yMjQgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDEsIDE0NCwgMjI0IC8gOCk7XG4vKipcbiAqIGtlY2Nhay0yNTYgaGFzaCBmdW5jdGlvbi4gRGlmZmVyZW50IGZyb20gU0hBMy0yNTYuXG4gKiBAcGFyYW0gbWVzc2FnZSAtIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydCBjb25zdCBrZWNjYWtfMjU2ID0gLyogQF9fUFVSRV9fICovIGdlbigweDAxLCAxMzYsIDI1NiAvIDgpO1xuZXhwb3J0IGNvbnN0IGtlY2Nha18zODQgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDEsIDEwNCwgMzg0IC8gOCk7XG5leHBvcnQgY29uc3Qga2VjY2FrXzUxMiA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwMSwgNzIsIDUxMiAvIDgpO1xuY29uc3QgZ2VuU2hha2UgPSAoc3VmZml4LCBibG9ja0xlbiwgb3V0cHV0TGVuKSA9PiB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cygob3B0cyA9IHt9KSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG9wdHMuZGtMZW4gPT09IHVuZGVmaW5lZCA/IG91dHB1dExlbiA6IG9wdHMuZGtMZW4sIHRydWUpKTtcbmV4cG9ydCBjb25zdCBzaGFrZTEyOCA9IC8qIEBfX1BVUkVfXyAqLyBnZW5TaGFrZSgweDFmLCAxNjgsIDEyOCAvIDgpO1xuZXhwb3J0IGNvbnN0IHNoYWtlMjU2ID0gLyogQF9fUFVSRV9fICovIGdlblNoYWtlKDB4MWYsIDEzNiwgMjU2IC8gOCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEzLmpzLm1hcCJdLCJuYW1lcyI6WyJieXRlcyIsImV4aXN0cyIsIm51bWJlciIsIm91dHB1dCIsInJvdGxCSCIsInJvdGxCTCIsInJvdGxTSCIsInJvdGxTTCIsInNwbGl0IiwiSGFzaCIsInUzMiIsInRvQnl0ZXMiLCJ3cmFwQ29uc3RydWN0b3IiLCJ3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyIsImlzTEUiLCJieXRlU3dhcDMyIiwiU0hBM19QSSIsIlNIQTNfUk9UTCIsIl9TSEEzX0lPVEEiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJfN24iLCJfMjU2biIsIl8weDcxbiIsInJvdW5kIiwiUiIsIngiLCJ5IiwicHVzaCIsInQiLCJqIiwiU0hBM19JT1RBX0giLCJTSEEzX0lPVEFfTCIsInJvdGxIIiwiaCIsImwiLCJzIiwicm90bEwiLCJrZWNjYWtQIiwicm91bmRzIiwiQiIsIlVpbnQzMkFycmF5IiwiaWR4MSIsImlkeDAiLCJCMCIsIkIxIiwiVGgiLCJUbCIsImN1ckgiLCJjdXJMIiwic2hpZnQiLCJQSSIsImZpbGwiLCJLZWNjYWsiLCJjb25zdHJ1Y3RvciIsImJsb2NrTGVuIiwic3VmZml4Iiwib3V0cHV0TGVuIiwiZW5hYmxlWE9GIiwicG9zIiwicG9zT3V0IiwiZmluaXNoZWQiLCJkZXN0cm95ZWQiLCJFcnJvciIsInN0YXRlIiwiVWludDhBcnJheSIsInN0YXRlMzIiLCJrZWNjYWsiLCJ1cGRhdGUiLCJkYXRhIiwibGVuIiwibGVuZ3RoIiwidGFrZSIsIk1hdGgiLCJtaW4iLCJpIiwiZmluaXNoIiwid3JpdGVJbnRvIiwib3V0IiwiYnVmZmVyT3V0Iiwic2V0Iiwic3ViYXJyYXkiLCJ4b2ZJbnRvIiwieG9mIiwiZGlnZXN0SW50byIsImRlc3Ryb3kiLCJkaWdlc3QiLCJfY2xvbmVJbnRvIiwidG8iLCJnZW4iLCJzaGEzXzIyNCIsInNoYTNfMjU2Iiwic2hhM18zODQiLCJzaGEzXzUxMiIsImtlY2Nha18yMjQiLCJrZWNjYWtfMjU2Iiwia2VjY2FrXzM4NCIsImtlY2Nha181MTIiLCJnZW5TaGFrZSIsIm9wdHMiLCJka0xlbiIsInVuZGVmaW5lZCIsInNoYWtlMTI4Iiwic2hha2UyNTYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/sha3.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   byteSwap: () => (/* binding */ byteSwap),\n/* harmony export */   byteSwap32: () => (/* binding */ byteSwap32),\n/* harmony export */   byteSwapIfBE: () => (/* binding */ byteSwapIfBE),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotl: () => (/* binding */ rotl),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/./node_modules/@noble/hashes/esm/cryptoNode.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@noble/hashes/esm/_assert.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nfunction isBytes(a) {\n    return a instanceof Uint8Array || a != null && typeof a === \"object\" && a.constructor.name === \"Uint8Array\";\n}\n// Cast array to different type\nconst u8 = (arr)=>new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr)=>new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr)=>new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift)=>word << 32 - shift | word >>> shift;\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift)=>word << shift | word >>> 32 - shift >>> 0;\nconst isLE = new Uint8Array(new Uint32Array([\n    0x11223344\n]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nconst byteSwap = (word)=>word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;\n// Conditionally byte swap if on a big-endian platform\nconst byteSwapIfBE = isLE ? (n)=>n : (n)=>byteSwap(n);\n// In place byte swap for Uint32Array\nfunction byteSwap32(arr) {\n    for(let i = 0; i < arr.length; i++){\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(bytes);\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = {\n    _0: 48,\n    _9: 57,\n    _A: 65,\n    _F: 70,\n    _a: 97,\n    _f: 102\n};\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2) throw new Error(\"padded hex string expected, got unpadded hex of length \" + hl);\n    const array = new Uint8Array(al);\n    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async ()=>{};\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for(let i = 0; i < iters; i++){\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick) continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */ function toBytes(data) {\n    if (typeof data === \"string\") data = utf8ToBytes(data);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */ function concatBytes(...arrays) {\n    let sum = 0;\n    for(let i = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== \"[object Object]\") throw new Error(\"Options should be object or undefined\");\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = ()=>hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */ function randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues === \"function\") {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error(\"crypto.getRandomValues must be defined\");\n} //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG9FQUFvRSxHQUNwRSxvRkFBb0Y7QUFDcEYsc0VBQXNFO0FBQ3RFLGtFQUFrRTtBQUNsRSw4REFBOEQ7QUFDOUQsK0RBQStEO0FBQy9ELDJFQUEyRTtBQUM3QjtBQUNDO0FBQy9DLDBDQUEwQztBQUMxQyxvRkFBb0Y7QUFDN0UsU0FBU0csUUFBUUMsQ0FBQztJQUNyQixPQUFRQSxhQUFhQyxjQUNoQkQsS0FBSyxRQUFRLE9BQU9BLE1BQU0sWUFBWUEsRUFBRUUsV0FBVyxDQUFDQyxJQUFJLEtBQUs7QUFDdEU7QUFDQSwrQkFBK0I7QUFDeEIsTUFBTUMsS0FBSyxDQUFDQyxNQUFRLElBQUlKLFdBQVdJLElBQUlDLE1BQU0sRUFBRUQsSUFBSUUsVUFBVSxFQUFFRixJQUFJRyxVQUFVLEVBQUU7QUFDL0UsTUFBTUMsTUFBTSxDQUFDSixNQUFRLElBQUlLLFlBQVlMLElBQUlDLE1BQU0sRUFBRUQsSUFBSUUsVUFBVSxFQUFFSSxLQUFLQyxLQUFLLENBQUNQLElBQUlHLFVBQVUsR0FBRyxJQUFJO0FBQ3hHLHFCQUFxQjtBQUNkLE1BQU1LLGFBQWEsQ0FBQ1IsTUFBUSxJQUFJUyxTQUFTVCxJQUFJQyxNQUFNLEVBQUVELElBQUlFLFVBQVUsRUFBRUYsSUFBSUcsVUFBVSxFQUFFO0FBQzVGLCtEQUErRDtBQUN4RCxNQUFNTyxPQUFPLENBQUNDLE1BQU1DLFFBQVUsUUFBVSxLQUFLQSxRQUFXRCxTQUFTQyxNQUFPO0FBQy9FLDZEQUE2RDtBQUN0RCxNQUFNQyxPQUFPLENBQUNGLE1BQU1DLFFBQVUsUUFBU0EsUUFBVSxTQUFXLEtBQUtBLFVBQVksRUFBRztBQUNoRixNQUFNRSxPQUFPLElBQUlsQixXQUFXLElBQUlTLFlBQVk7SUFBQztDQUFXLEVBQUVKLE1BQU0sQ0FBQyxDQUFDLEVBQUUsS0FBSyxLQUFL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TUwsU0FBUyxDQUFDO0lBQ3RCQyxNQUFNSyxTQUFTLEdBQUdELElBQUlDLFNBQVM7SUFDL0JMLE1BQU1NLFFBQVEsR0FBR0YsSUFBSUUsUUFBUTtJQUM3Qk4sTUFBTU8sTUFBTSxHQUFHLENBQUNkLE9BQVNNLFNBQVNOO0lBQ2xDLE9BQU9PO0FBQ1g7QUFDQTs7Q0FFQyxHQUNNLFNBQVNVLFlBQVlDLGNBQWMsRUFBRTtJQUN4QyxJQUFJdkcsd0RBQU1BLElBQUksT0FBT0Esd0RBQU1BLENBQUN3RyxlQUFlLEtBQUssWUFBWTtRQUN4RCxPQUFPeEcsd0RBQU1BLENBQUN3RyxlQUFlLENBQUMsSUFBSW5HLFdBQVdrRztJQUNqRDtJQUNBLE1BQU0sSUFBSXZELE1BQU07QUFDcEIsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jZmFwcC8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcz9lZjdmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0IGRlY2xhcmUgaXQgaW4gZ2xvYmFsIHNjb3BlLlxuLy8gRm9yIG5vZGUuanMsIHBhY2thZ2UuanNvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmcgcmV3cml0ZXMgaW1wb3J0XG4vLyBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCAoMjAyNS0wNC0zMCksIHdlIGNhbiBqdXN0IGRyb3AgdGhlIGltcG9ydC5cbmltcG9ydCB7IGNyeXB0byB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvY3J5cHRvJztcbmltcG9ydCB7IGJ5dGVzIGFzIGFieXRlcyB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG4vLyBleHBvcnQgeyBpc0J5dGVzIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbi8vIFdlIGNhbid0IHJldXNlIGlzQnl0ZXMgZnJvbSBfYXNzZXJ0LCBiZWNhdXNlIHNvbWVob3cgdGhpcyBjYXVzZXMgaHVnZSBwZXJmIGlzc3Vlc1xuZXhwb3J0IGZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbn1cbi8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcbmV4cG9ydCBjb25zdCB1OCA9IChhcnIpID0+IG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnQgY29uc3QgdTMyID0gKGFycikgPT4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xuLy8gQ2FzdCBhcnJheSB0byB2aWV3XG5leHBvcnQgY29uc3QgY3JlYXRlVmlldyA9IChhcnIpID0+IG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuLy8gVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5leHBvcnQgY29uc3Qgcm90ciA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG4vLyBUaGUgcm90YXRlIGxlZnQgKGNpcmN1bGFyIGxlZnQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5leHBvcnQgY29uc3Qgcm90bCA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgc2hpZnQpIHwgKCh3b3JkID4+PiAoMzIgLSBzaGlmdCkpID4+PiAwKTtcbmV4cG9ydCBjb25zdCBpc0xFID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NDtcbi8vIFRoZSBieXRlIHN3YXAgb3BlcmF0aW9uIGZvciB1aW50MzJcbmV4cG9ydCBjb25zdCBieXRlU3dhcCA9ICh3b3JkKSA9PiAoKHdvcmQgPDwgMjQpICYgMHhmZjAwMDAwMCkgfFxuICAgICgod29yZCA8PCA4KSAmIDB4ZmYwMDAwKSB8XG4gICAgKCh3b3JkID4+PiA4KSAmIDB4ZmYwMCkgfFxuICAgICgod29yZCA+Pj4gMjQpICYgMHhmZik7XG4vLyBDb25kaXRpb25hbGx5IGJ5dGUgc3dhcCBpZiBvbiBhIGJpZy1lbmRpYW4gcGxhdGZvcm1cbmV4cG9ydCBjb25zdCBieXRlU3dhcElmQkUgPSBpc0xFID8gKG4pID0+IG4gOiAobikgPT4gYnl0ZVN3YXAobik7XG4vLyBJbiBwbGFjZSBieXRlIHN3YXAgZm9yIFVpbnQzMkFycmF5XG5leHBvcnQgZnVuY3Rpb24gYnl0ZVN3YXAzMihhcnIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBieXRlU3dhcChhcnJbaV0pO1xuICAgIH1cbn1cbi8vIEFycmF5IHdoZXJlIGluZGV4IDB4ZjAgKDI0MCkgaXMgbWFwcGVkIHRvIHN0cmluZyAnZjAnXG5jb25zdCBoZXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF8sIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgYWJ5dGVzKGJ5dGVzKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLy8gV2UgdXNlIG9wdGltaXplZCB0ZWNobmlxdWUgdG8gY29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbmNvbnN0IGFzY2lpcyA9IHsgXzA6IDQ4LCBfOTogNTcsIF9BOiA2NSwgX0Y6IDcwLCBfYTogOTcsIF9mOiAxMDIgfTtcbmZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2hhcikge1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fMCAmJiBjaGFyIDw9IGFzY2lpcy5fOSlcbiAgICAgICAgcmV0dXJuIGNoYXIgLSBhc2NpaXMuXzA7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9BICYmIGNoYXIgPD0gYXNjaWlzLl9GKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX0EgLSAxMCk7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9hICYmIGNoYXIgPD0gYXNjaWlzLl9mKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX2EgLSAxMCk7XG4gICAgcmV0dXJuO1xufVxuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIGNvbnN0IGhsID0gaGV4Lmxlbmd0aDtcbiAgICBjb25zdCBhbCA9IGhsIC8gMjtcbiAgICBpZiAoaGwgJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgaGwpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYWwpO1xuICAgIGZvciAobGV0IGFpID0gMCwgaGkgPSAwOyBhaSA8IGFsOyBhaSsrLCBoaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IG4xID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSkpO1xuICAgICAgICBjb25zdCBuMiA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkgKyAxKSk7XG4gICAgICAgIGlmIChuMSA9PT0gdW5kZWZpbmVkIHx8IG4yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBoZXhbaGldICsgaGV4W2hpICsgMV07XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCBub24taGV4IGNoYXJhY3RlciBcIicgKyBjaGFyICsgJ1wiIGF0IGluZGV4ICcgKyBoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlbYWldID0gbjEgKiAxNiArIG4yO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBUaGVyZSBpcyBubyBzZXRJbW1lZGlhdGUgaW4gYnJvd3NlciBhbmQgc2V0VGltZW91dCBpcyBzbG93LlxuLy8gY2FsbCBvZiBhc3luYyBmbiB3aWxsIHJldHVybiBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uXG4vLyBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG4vLyBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNMb29wKGl0ZXJzLCB0aWNrLCBjYikge1xuICAgIGxldCB0cyA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyczsgaSsrKSB7XG4gICAgICAgIGNiKGkpO1xuICAgICAgICAvLyBEYXRlLm5vdygpIGlzIG5vdCBtb25vdG9uaWMsIHNvIGluIGNhc2UgaWYgY2xvY2sgZ29lcyBiYWNrd2FyZHMgd2UgcmV0dXJuIHJldHVybiBjb250cm9sIHRvb1xuICAgICAgICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIHRzO1xuICAgICAgICBpZiAoZGlmZiA+PSAwICYmIGRpZmYgPCB0aWNrKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGF3YWl0IG5leHRUaWNrKCk7XG4gICAgICAgIHRzICs9IGRpZmY7XG4gICAgfVxufVxuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vKipcbiAqIE5vcm1hbGl6ZXMgKG5vbi1oZXgpIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFVpbnQ4QXJyYXkuXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICBhYnl0ZXMoZGF0YSk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgYWJ5dGVzKGEpO1xuICAgICAgICBzdW0gKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHN1bSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuZXhwb3J0IGNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuY29uc3QgdG9TdHIgPSB7fS50b1N0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkICYmIHRvU3RyLmNhbGwob3B0cykgIT09ICdbb2JqZWN0IE9iamVjdF0nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG4vKipcbiAqIFNlY3VyZSBQUk5HLiBVc2VzIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYCwgd2hpY2ggZGVmZXJzIHRvIE9TLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xuICAgIGlmIChjcnlwdG8gJiYgdHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbImNyeXB0byIsImJ5dGVzIiwiYWJ5dGVzIiwiaXNCeXRlcyIsImEiLCJVaW50OEFycmF5IiwiY29uc3RydWN0b3IiLCJuYW1lIiwidTgiLCJhcnIiLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsInUzMiIsIlVpbnQzMkFycmF5IiwiTWF0aCIsImZsb29yIiwiY3JlYXRlVmlldyIsIkRhdGFWaWV3Iiwicm90ciIsIndvcmQiLCJzaGlmdCIsInJvdGwiLCJpc0xFIiwiYnl0ZVN3YXAiLCJieXRlU3dhcElmQkUiLCJuIiwiYnl0ZVN3YXAzMiIsImkiLCJsZW5ndGgiLCJoZXhlcyIsIkFycmF5IiwiZnJvbSIsIl8iLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiYnl0ZXNUb0hleCIsImhleCIsImFzY2lpcyIsIl8wIiwiXzkiLCJfQSIsIl9GIiwiX2EiLCJfZiIsImFzY2lpVG9CYXNlMTYiLCJjaGFyIiwiaGV4VG9CeXRlcyIsIkVycm9yIiwiaGwiLCJhbCIsImFycmF5IiwiYWkiLCJoaSIsIm4xIiwiY2hhckNvZGVBdCIsIm4yIiwidW5kZWZpbmVkIiwibmV4dFRpY2siLCJhc3luY0xvb3AiLCJpdGVycyIsInRpY2siLCJjYiIsInRzIiwiRGF0ZSIsIm5vdyIsImRpZmYiLCJ1dGY4VG9CeXRlcyIsInN0ciIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwidG9CeXRlcyIsImRhdGEiLCJjb25jYXRCeXRlcyIsImFycmF5cyIsInN1bSIsInJlcyIsInBhZCIsInNldCIsIkhhc2giLCJjbG9uZSIsIl9jbG9uZUludG8iLCJ0b1N0ciIsImNoZWNrT3B0cyIsImRlZmF1bHRzIiwib3B0cyIsImNhbGwiLCJtZXJnZWQiLCJPYmplY3QiLCJhc3NpZ24iLCJ3cmFwQ29uc3RydWN0b3IiLCJoYXNoQ29ucyIsImhhc2hDIiwibXNnIiwidXBkYXRlIiwiZGlnZXN0IiwidG1wIiwib3V0cHV0TGVuIiwiYmxvY2tMZW4iLCJjcmVhdGUiLCJ3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyIsIndyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzIiwicmFuZG9tQnl0ZXMiLCJieXRlc0xlbmd0aCIsImdldFJhbmRvbVZhbHVlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/utils.js\n");

/***/ })

};
;